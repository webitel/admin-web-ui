/*<!DOCTYPE html>
<html>
<head>
<meta charset="utf8"/>

    <title>Rappid - modular diagram builder</title>

<link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet" type="text/css" />

    <style type="text/css">
*/
/*
 Copyright 2013 client IO
 http://client.io

 Rappid General License Statement and Limited Warranty
 ======================================================

 Definitions
 -----------

 "Rappid" shall mean a programmer's toolkit 
 for building interactive diagramming applications as originally 
 created by client IO.

 "Software" shall mean Rappid, as originally created by
 client IO.

 "Licensee" is you, only if you agree to be bound by the terms
 and conditions set forth in this Agreement.

 "Source code" means the JavaScript files and other related files in the 
 Software package.


 This license statement and limited warranty constitutes a legal agreement 
 ("License Agreement") between You (either as an individual or a single entity) 
 and client IO for the software product ("Software") identified above, 
 including any software, media, and accompanying on-line or printed 
 documentation. By installing, copying, or otherwise using the
 Software, you are agreeing to be bound by the terms of this Agreement. If you
 do not agree to the terms of this Agreement, you are not authorized to use
 this Software.


 BY INSTALLING, COPYING, OR OTHERWISE USING THE SOFTWARE, YOU AGREE TO BE BOUND 
 BY ALL OF THE TERMS AND CONDITIONS OF THE LICENSE AGREEMENT.

 Upon your acceptance of the terms and conditions of the License Agreement, 
 client IO grants to you the right to use the Software in the manner provided 
 below. This license is perpetual, no additional payment is required to 
 maintain it, with the exception of you breaking any part of this license, in 
 which case you lose all rights under the license.

 You may transfer the rights granted to you under this agreement in and to the 
 Software and documentation on a permanent basis provided you retain no copies, 
 the recipient agrees to the terms of the License Agreement and the total number 
 of developers licensed to use the software does not exceed the number of 
 licensed developers at the time of license purchase. client IO must be informed 
 in writing of the transfer.

 Except as provided in the License Agreement, you may not transfer, 
 rent, lease, lend, copy, modify, translate, sublicense, time-share or 
 electronically transmit or receive the Software, media or documentation. When 
 transferring licenses, the whole of the licensed product must be transferred.

 In addition to the other terms contained herein, We grant to You a revocable, non-exclusive, 
 non-transferable and non-sublicensable license to install and use the Software (the "Trial License")
 strictly for Your internal evaluation and review purposes and not for production purposes. 
 This Trial License applies only if You have registered with Us for a Trial License of the Software and 
 shall be effective for thirty (30) consecutive days following the date of registration ("the Trial Period").
 You may only register for a Trial License once in any eighteen month period. You agree not to use a 
 Trial License for any purpose other than determining whether to purchase a license to the Software. 
 You are explicitly not permitted to distribute the Software to any user outside the Organization on whose 
 behalf you have undertaken this license. Your rights to use the Trial License will immediately terminate 
 upon the earlier of (i) the expiration of the Trial Period, or (ii) such time that You purchase a license 
 to the Software. We reserve the right to terminate Your Trial License at any time in Our absolute and 
 sole discretion.

 YOU ACKNOWLEDGE THAT TRIAL SOFTWARE MIGHT PLACE WATERMARKS ON OUTPUT, CONTAIN LIMITED FUNCTIONALITY, 
 FUNCTION FOR A LIMITED PERIOD OF TIME, OR LIMIT THE FUNCTIONALITY OR TIME OF FUNCTIONING OF ANY OUTPUT. 
 ACCESS TO AND/OR USE OF ANY FILES OR OUTPUT CREATED WITH SUCH SOFTWARE IS ENTIRELY AT YOUR OWN RISK. 
 WE ARE LICENSING THE SOFTWARE ON AN "AS IS" BASIS AT YOUR OWN RISK AND WE DISCLAIM ANY WARRANTY OR 
 LIABILITY TO YOU OF ANY KIND.


 Developer License Terms
 -----------------------

 To develop products using the Software, you require a number of development 
 licenses equal to the number of engineers developing the application area 
 that specifically uses the Software. This is the maximum number 
 of such developers over any 1 month sliding window. A development license is 
 not required in order to build an application that uses the software.

 A developer License may be installed on any number of computers 
 at any time. client IO grants to you non exclusive license to install
 and use the Software for the sole purposes of 
 designing, developing and testing application programs which you create.

 In addition to the right to install the complete software on the specified 
 number of computers, the Source code may also be placed on storage devices 
 for the purposes of version control, automated building and archiving. 
 The entire downloaded Software package may also be archived for backup purposes.


 Additional Redistribution Terms for Software
 ---------------------------------------------

 client IO hereby grants to you the worldwide, non exclusive, perpetual right 
 under all intellectual property rights in and to the Software to 
 incorporate the Software in whole or in part in your offerings and to 
 redistribute the Software as incorporated to your customers and distributors 
 and resellers. 

 Rappid must be part of a larger system. You may not expose the Rappid API for
 developer use in your product.


 Updates
 -------

 Free updates are provided for all versions of the Software for the period of twelve (12) months
 from the time of the license purchase. Updates are performed by downloading the updated Software package 
 through a link provided in the purchase process or sent to an email address provided in the purchase process.

 Marketing
 ---------

 client IO is permitted to reference you as a user of the Software in customer 
 lists on any of the web sites owned by client IO, in presentations to clients and at trade events.

 Limited Warranty
 ----------------

 client IO warrants that as provided the Software does not contain any malicious 
 code inserted to affect the functioning of the Software or any computer that 
 the Software runs on. Any developer using Rappid must have a broad 
 understanding of security issue relating to web application and must take all 
 reasonable steps at a system level to mitigate those risks.

 client IO warrants that the Software does not infringe any patent, copyright or 
 design secret of any third party. client IO is not aware of any facts upon which 
 such a claim for infringement could be based.


 TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, CLIENT IO AND ITS 
 SUPPLIERS DISCLAIM ALL OTHER WARRANTIES AND CONDITIONS, EITHER EXPRESSED OR 
 IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY, 
 FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT, WITH REGARD TO 
 THE SOFTWARE, AND THE PROVISION OF OR FAILURE TO PROVIDE SUPPORT SERVICES. THIS 
 LIMITED WARRANTY GIVES YOU SPECIFIC LEGAL RIGHTS. YOU MAY HAVE OTHERS, WHICH 
 VARY FROM STATE/JURISDICTION TO STATE/JURISDICTION.

 LIMITATION OF LIABILITY TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, IN 
 NO EVENT SHALL CLIENT IO OR ITS SUPPLIERS BE LIABLE FOR ANY SPECIAL, 
 INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT 
 LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS 
 OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF 
 OR INABILITY TO USE THE SOFTWARE PRODUCT OR THE PROVISION OF OR FAILURE TO 
 PROVIDE SUPPORT SERVICES, EVEN IF CLIENT IO HAS BEEN ADVISED OF THE 
 POSSIBILITY OF SUCH DAMAGES. BECAUSE SOME STATES AND JURISDICTIONS DO NOT 
 ALLOW THE EXCLUSION OR LIMITATION OF LIABILITY, THE ABOVE LIMITATION MAY NOT 
 APPLY TO YOU.


 General Provisions
 -------------------

 This License Agreement may only be modified in writing signed by you and
 client IO. If any provision of this License Agreement is found void or 
 unenforceable, the remainder will remain valid and enforceable according to its
 terms. If any remedy provided is determined to have failed for its essential
 purpose, all limitations of liability and exclusions of damages set forth in 
 the Limited Warranty shall remain in effect.

 Governing Law and Jurisdiction
 -------------------------------

 This Agreement shall be subject to and governed by the Law of The Netherlands. 
 Any dispute arising out of or in connection with this Agreement shall 
 be exclusively dealt with by the courts of The Netherlands. This License 
 Agreement gives you specific legal rights; you may have others which vary from 
 state to state and from country to country. client IO reserves all rights not 
 specifically granted in this License Agreement.

 Version 2.0 - 14.11.2013
 */
/*! Rappid - the diagramming toolkit

 Copyright (c) 2013 client IO

 2015-02-03 


 This Source Code Form is subject to the terms of the Rappid License
 , v. 2.0. If a copy of the Rappid License was not distributed with this
 file, You can obtain one at http://jointjs.com/license/rappid_v2.txt
 or from the Rappid archive as was distributed by client IO. See the LICENSE file.*/
/*.viewport {
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none
}

[magnet=true]:not(.element) {
    cursor: crosshair
}

[magnet=true]:not(.element):hover {
    opacity: .7
}

.element {
    cursor: move
}

.element * {
    vector-effect: non-scaling-stroke;
-moz-user-select: none;
user-drag: none
}

.connection-wrap {
    fill: none;
    stroke: black;
    stroke-width: 15;
    stroke-linecap: round;
    stroke-linejoin: round;
    opacity: 0;
    cursor: move
}

.connection-wrap:hover {
    opacity: .4;
    stroke-opacity: .4
}

.connection {
    fill: none;
    stroke-linejoin: round
}

.marker-source,.marker-target {
    vector-effect: non-scaling-stroke
}

.marker-vertices {
    opacity: 0;
    cursor: move
}

.marker-arrowheads {
    opacity: 0;
    cursor: move;
    cursor: -webkit-grab;
    cursor: -moz-grab
}

.link-tools {
    opacity: 0;
    cursor: pointer
}

.link-tools .tool-options {
    display: none
}

.link-tools .tool-remove circle {
    fill: red
}

.link-tools .tool-remove path {
    fill: white
}

.link:hover .marker-vertices,.link:hover .marker-arrowheads,.link:hover .link-tools {
    opacity: 1
}

.marker-vertex {
    fill: #1abc9c
}

.marker-vertex:hover {
    fill: #34495e;
    stroke: none
}

.marker-arrowhead {
    fill: #1abc9c
}

.marker-arrowhead:hover {
    fill: #f39c12;
    stroke: none
}

.marker-vertex-remove {
    cursor: pointer;
    opacity: .1;
    fill: white
}

.marker-vertex-group:hover .marker-vertex-remove {
    opacity: 1
}

.marker-vertex-remove-area {
    opacity: .1;
    cursor: pointer
}

.marker-vertex-group:hover .marker-vertex-remove-area {
    opacity: 1
}

.highlighted {
    opacity: .7
}

text.highlighted {
    fill: red
}

@media screen and (-webkit-min-device-pixel-ratio:0) {
.highlighted {
        outline: 2px solid red;
        opacity: initial
    }
}

.element .fobj body {
    background-color: transparent;
    margin: 0
}

.element .fobj div {
    text-align: center;
    vertical-align: middle;
    display: table-cell;
    padding: 0 5px 0 5px
}
*/
/*! Rappid - the diagramming toolkit

 Copyright (c) 2013 client IO

 2015-02-03 


 This Source Code Form is subject to the terms of the Rappid License
 , v. 2.0. If a copy of the Rappid License was not distributed with this
 file, You can obtain one at http://jointjs.com/license/rappid_v2.txt
 or from the Rappid archive as was distributed by client IO. See the LICENSE file.*/
/*.stencil {
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0
}

.stencil>.content {
    position: absolute;
    overflow-y: auto;
    overflow-x: hidden;
    height: auto;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0
}

.stencil.searchable>.content {
    top: 30px
}

.stencil .elements {
    background-color: white;
    height: 100%;
    width: 100%
}

.stencil-paper-drag {
    position: absolute;
    z-index: 100;
    width: 800;
    height: 800;
    top: -10000;
    left: -10000;
    display: none
}

.stencil-paper-drag.dragging {
    display: block;
    opacity: .7
}

.stencil .group {
    overflow: hidden;
    padding-left: 10px;
    margin-bottom: 1px;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    transition: max-height 400ms linear;
    max-height: 400px
}

.stencil .group.closed {
    height: 26px;
    max-height: 26px
}

.stencil .group>.group-label {
    padding: 5px 4px;
    position: relative;
    left: -10px;
    margin-right: -20px;
    margin-top: 0;
    margin-bottom: 0;
    font-size: 10px;
    font-weight: 700;
    text-transform: uppercase;
    border-top: 1px solid #3a3a3a;
    border-bottom: 2px solid #1f1f1f;
    background: #242424;
    cursor: pointer;
    color: #bcbcbc
}

.stencil .group>.group-label:before {
    content: '';
    width: 0;
    height: 0;
    display: inline-block;
    margin-left: 2px;
    margin-right: 5px;
    position: relative;
    top: 5px;
    border-top: 5px solid white;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-bottom: 5px solid transparent
}

.stencil .group.closed>.group-label:before {
    top: 2px;
    left: 2px;
    border-top: 5px solid transparent;
    border-bottom: 5px solid transparent;
    border-right: 5px solid transparent;
    border-left: 5px solid white
}

.stencil .element [magnet] {
    pointer-events: none
}

.stencil .unmatched {
    opacity: .3
}

.stencil .search {
    width: 100%;
    box-sizing: border-box;
    text-shadow: 0 -1px 0 #000;
    color: #ddd;
    box-shadow: inset 0 0 0 1px rgba(0,0,0,0.1),0 0 0 1px rgba(255,255,255,0.1);
    border: 1px solid black;
    background: #333;
    height: 30px;
    max-height: 30px;
    line-height: 30px;
    z-index: 1;
    position: relative
}

.stencil:after {
    display: block;
    content: '';
    pointer-events: none;
    position: absolute;
    top: 0;
    width: 100%;
    height: 20px;
    line-height: 20px;
    padding: 8px 0;
    text-align: center;
    font-size: 12px;
    font-weight: 700;
    background: #242424;
    color: #bcbcbc;
    opacity: 0;
    transition: top 100ms linear
}

.stencil.not-found:after {
    content: 'No matches found';
    top: 30px;
    opacity: 1
}

.stencil .element.unmatched {
    display: none
}

.stencil .group.unmatched {
    display: none
}
*/
/*! Rappid - the diagramming toolkit

 Copyright (c) 2013 client IO

 2015-02-03 


 This Source Code Form is subject to the terms of the Rappid License
 , v. 2.0. If a copy of the Rappid License was not distributed with this
 file, You can obtain one at http://jointjs.com/license/rappid_v2.txt
 or from the Rappid archive as was distributed by client IO. See the LICENSE file.*/
/*.navigator {
    overflow: hidden;
    position: relative;
    display: table-cell;
    text-align: center;
    vertical-align: middle;
    box-sizing: border-box;
    -moz-user-select: none;
    -webkit-user-select: none;
    -ms-user-select: none;
    background-color: #fff
}

.navigator>.paper {
    display: inline-block;
    cursor: pointer;
    box-shadow: 0 0 2px lightgray
}

.navigator>.paper>svg {
    shape-rendering: optimizeSpeed;
    pointer-events: none
}

.navigator .current-view {
    position: absolute;
    cursor: move;
    margin: -2px 0 0 -2px;
    border: 2px solid #31d0c6
}

.navigator .current-view-control {
    position: absolute;
    right: 0;
    bottom: 0;
    width: 10px;
    height: 10px;
    cursor: nwse-resize;
    margin: 0 -7px -7px 0;
    border-radius: 50%;
    border: 2px solid #31d0c6;
    background-color: #fff
}

.navigator .paper .element * {
    vector-effect: initial
}
*/
/*! Rappid - the diagramming toolkit

 Copyright (c) 2013 client IO

 2015-02-03 


 This Source Code Form is subject to the terms of the Rappid License
 , v. 2.0. If a copy of the Rappid License was not distributed with this
 file, You can obtain one at http://jointjs.com/license/rappid_v2.txt
 or from the Rappid archive as was distributed by client IO. See the LICENSE file.*/
/*.halo {
    position: absolute;
    pointer-events: none
}

.halo>div {
    position: absolute;
    pointer-events: auto;
    width: 20px;
    height: 20px;
    background-size: 20px 20px;
    background-repeat: no-repeat;
    -moz-user-select: none;
    -webkit-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-user-drag: none;
    user-drag: none
}

.halo .handle {
    cursor: pointer
}

.halo.animate>div {
    transition: background-size 80ms,width 80ms,height 80ms,top 150ms,left 150ms,bottom 150ms,right 150ms
}

.halo.small>div {
    width: 15px;
    height: 15px;
    background-size: 15px 15px
}

.halo.tiny>div {
    width: 10px;
    height: 10px;
    background-size: 10px 10px
}

.halo .handle.se {
    bottom: -25px;
    right: -25px
}

.halo.small .handle.se {
    bottom: -19px;
    right: -19px
}

.halo.tiny .handle.se {
    bottom: -13px;
    right: -13px
}

.halo .handle.nw {
    top: -21px;
    left: -25px
}

.halo.small .handle.nw {
    top: -19px;
    left: -19px
}

.halo.tiny .handle.nw {
    top: -13px;
    left: -13px
}

.halo .handle.n {
    top: -22px;
    left: 50%;
    margin-left: -10px
}

.halo.small .handle.n {
    top: -19px;
    margin-left: -7.5px
}

.halo.tiny .handle.n {
    top: -13px;
    margin-left: -5px
}

.halo .handle.e {
    right: -25px;
    top: -webkit-calc(50% - 10px);
    top: calc(50% - 10px)
}

.halo.small .handle.e {
    right: -19px;
    top: -webkit-calc(50% - 8px);
    top: calc(50% - 8px)
}

.halo.tiny .handle.e {
    right: -13px;
    top: -webkit-calc(50% - 5px);
    top: calc(50% - 5px)
}

.halo .handle.ne {
    top: -21px;
    right: -25px
}

.halo.small .handle.ne {
    top: -19px;
    right: -19px
}

.halo.tiny .handle.ne {
    top: -13px;
    right: -13px
}

.halo .handle.w {
    left: -25px;
    top: 50%;
    margin-top: -10px
}

.halo.small .handle.w {
    left: -19px;
    margin-top: -8px
}

.halo.tiny .handle.w {
    left: -13px;
    margin-top: -5px
}

.halo .handle.sw {
    bottom: -25px;
    left: -25px
}

.halo.small .handle.sw {
    bottom: -19px;
    left: -19px
}

.halo.tiny .handle.sw {
    bottom: -13px;
    left: -13px
}

.halo .handle.s {
    bottom: -24px;
    left: 50%;
    margin-left: -10px
}

.halo.small .handle.s {
    bottom: -19px;
    margin-left: -7.5px
}

.halo.tiny .handle.s {
    bottom: -13px;
    margin-left: -5px
}

.halo .resize {
    cursor: se-resize;
    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2RpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo2NjREODhDMjc4MkVFMjExODUyOEU5NTNCRjg5OEI3QiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowQTc4MzUwQjJGMEIxMUUyOTFFNUE1RTAwQ0EwMjU5NyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowQTc4MzUwQTJGMEIxMUUyOTFFNUE1RTAwQ0EwMjU5NyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2NjREODhDMjc4MkVFMjExODUyOEU5NTNCRjg5OEI3QiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo2NjREODhDMjc4MkVFMjExODUyOEU5NTNCRjg5OEI3QiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pk3oY88AAAEMSURBVHja7JftDYMgEIbRdABHcARG6CalGziCG3QE3KAj0A0cod3AEa6YUEMpcKeI9oeXvP5QuCeA90EBAGwPK7SU1hkZ12ldiT6F1oUycARDRHLBgiTiEzCwTNhNuRT8XOEog/AyMqlOXPEuZzx7q29aXGtIhLvQwfNuAgtrYgrcB+VWqH2BhceBD45ZE4EyB/7zIQTvCeAWgdpw1CqT2Sri2LsRZ4cddtg/GLfislo55oNZxE2ZLcFXT8haU7YED9yXpxsCGMvTn4Uqe7DIXJnsAqGYB5CjFnNT6yEE3qr7iIJT+60YXJUZQ3G8ALyof+JWfTV6xrluEuqkHw/ESW3CoJsBRVubtwADAI2b6h9uJAFqAAAAAElFTkSuQmCC)
}

.halo .remove {
    cursor: pointer;
    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAO5JREFUeNrUV9sNwyAMtLoAI3SEjJIRMgqjdBRG8CiMQGnlVHwEOBAE19L9OdwRGz+IcNsibISLCBk48dlooB0RXCDNgeXbbntWbovCyVlNtkf4AeQnvJwJ//IwCQdy8zAZeynm/gYBPpcT7gbyNDGb4/4CnyOLb1M+MED+MVPxZfEhQASnFQ4hp4qIlJxAEd+KaQGlpiIC8bmCRZOvRNBL/kvGltp+RdRLfqK5wZhCITMdjaury5lB5OFBCuxvQjAtCZc/w+WFaHkpXt6MVLTj5QOJipFs+VCqYixXsZioWM1GLaf7yK45ZT1/CzAAESidXQn9F/MAAAAASUVORK5CYII=)
}

.halo .clone {
    cursor: move;
    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2RpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo2NjREODhDMjc4MkVFMjExODUyOEU5NTNCRjg5OEI3QiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxNTM0NjJBRjJGMkQxMUUyQkRFM0FCRTMxMDhFQkE2QiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxNTM0NjJBRTJGMkQxMUUyQkRFM0FCRTMxMDhFQkE2QiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2NjREODhDMjc4MkVFMjExODUyOEU5NTNCRjg5OEI3QiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo2NjREODhDMjc4MkVFMjExODUyOEU5NTNCRjg5OEI3QiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PkJFWv4AAAD3SURBVHja5FfRDYMgED2bDsAIjsAIMAluoqs4CY7gCI7ABtTTnsEUNCVQanzJGT/Qx7t7HFBZa6EEHlAIxYh90HPYzCHul+pixM93TV1wfDRNA0qppGRSyh2x8A2q6xqEEIc/mqZpCcTZWJ/iaPR9D13XLe/fNqKiNd6lahxHMMb8jlhrvRlgGAbvYJwQTsytMcH9hjEGnPN0NUZS15khx2L2SMi1GwgqQfdSkKPJ1RRnau/ZMq9J3LbtVtfodezrw6H1nAp2NeWK2bm5Tx9lTyAfilNhXuOkTv/n7hTqwbFwN5DDVGcMHVIsM2fVu7lXt7s7vQQYAIMHB7xhVbHdAAAAAElFTkSuQmCC)
}

.halo .link {
    cursor: move;
    cursor: -moz-grabbing;
    cursor: -webkit-grabbing;
    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjIwRkVFNkM3MkU3RjExRTJBMDA3RkZBQzMyMzExQzIzIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjIwRkVFNkM4MkU3RjExRTJBMDA3RkZBQzMyMzExQzIzIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MjBGRUU2QzUyRTdGMTFFMkEwMDdGRkFDMzIzMTFDMjMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MjBGRUU2QzYyRTdGMTFFMkEwMDdGRkFDMzIzMTFDMjMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5hjT/5AAAA8ElEQVR42syXwQ3DIAxFUbtAR+gIHLsSN2+SboA6CSOEMbghJqCAHKlNmwYwkWvpKwdinmRsY4Sos2sSJJkknxRX8rgG+C/ZJG4YG2XQt9kuSVMHcK0J96qGzgOgi+Ya+GhoFfwo6C5890wBIGqto5SScuYf2fvTKcMW895T4G/ZblrARLh5bQ5VTjnMg+ClyUCL0yA4iJ7ONABewu17koQIz8z+2iTCaY3hG7zG7yQYjS3UbMnFVk5sDYStZbJdEizX4hnBDqeD21bNOedECKF8lVLCWttTuvekx9+MPmzDHut4yzrQsz5hDn+0PQUYAOGQcmTsT0IpAAAAAElFTkSuQmCC)
}

.halo .fork {
    cursor: move;
    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3QUUEAUZcNUVHAAAALtJREFUWMPtlt0RgjAMgL9zAkZglI7ACLoJm8RNHIERGMER6ksfsIeRtsGq9LvLW2i+oz8JNBoHYAZcTQEfQoCupoAH7sBZS1jGDAwbCgwh1yfEDejfCSx/3SsksXAcIxsTZYfiSQJrEiUCT1sQ45TFNQkJ33aphzB1f9ckZK9rKBkHM2YqfYgsJIr5aYnJshfkSJj3Ak3C5fQCSwmTh+hTEh4YTwUCF+D6DRNPcTuuPpD8/UhWfShtNFQe+d/oVK9MAB0AAAAASUVORK5CYII=)
}

.halo .unlink {
    cursor: pointer;
    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjJCNjcxNUZBMkU3RjExRTI5RURCRDA5NDlGRDBFMDgwIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjJCNjcxNUZCMkU3RjExRTI5RURCRDA5NDlGRDBFMDgwIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MkI2NzE1RjgyRTdGMTFFMjlFREJEMDk0OUZEMEUwODAiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MkI2NzE1RjkyRTdGMTFFMjlFREJEMDk0OUZEMEUwODAiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5htS6kAAABHElEQVR42uxW0Q2DIBBV0wEcwRHsBo7QERjBbkAnYARGaDdghI5gN9ANKCRHQy4HxFakH77kxeTAe95xd1JrrasSaKpCOIR3R2+oDLXHp+GQU3RAYhyezsZyCU8gwJGdgX3+wXcHfi1HyOwHGsQpuMjXprwFMU3QavGTtzHkwGJZIXoxFBBtyOer8opKog0ykQ0qrSoQpTsy7gfZg9EtKu/cnbBvm4iC454PijKUgQ4WYy9rot0Y6gBMhQvKoY70dYs+TERqAcOe4dXwsUXbWdF7IgsztM3/jsziqd69uLZqp/GbdgoNEJF7gMR+BC7KfuXInBIfwJrELF4Ss5yCLaiz4S3isyv6W8QXAbHXRaDI1ac+LvSHcC68BRgAHv/CnODh8mEAAAAASUVORK5CYII=)
}

.halo .rotate {
    cursor: move;
    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI1NTk5RUFBMkU3RjExRTI4OUIyQzYwMkMyN0MxMDE3IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI1NTk5RUFCMkU3RjExRTI4OUIyQzYwMkMyN0MxMDE3Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MjU1OTlFQTgyRTdGMTFFMjg5QjJDNjAyQzI3QzEwMTciIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MjU1OTlFQTkyRTdGMTFFMjg5QjJDNjAyQzI3QzEwMTciLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6W+5aDAAABJElEQVR42syXbRGDMAyGYTcBOBgSkICESWAOmAMcTAJzgAQksCnYHFRC13Jlx7qkDf0Acvf+6ZF7mjRNQ8o5T/ZqmVAt1AkxIa5JrvXqmywUsAVANkmf3BV6RqKjSvpWlqD+7OYBhKKHoMNS6EuddaPUqjUqfIJyPb2Ysyye0pC6Qm0I8680KJ/vhDmcFbU2mAb9glvk48KhMAtiYY7RYunxuRVWcI2cqa/ZegBYFGWA5jPYwAy4MrGhI1hf6FaA8gPg/PSA9tSbcAz8il2XOIRM9SILXVxki3GdEvUmD6bhIHYDQeFrtEwUvsYj0WBRx34Wc5cXJcQg8GMpMPrUBsBb6DHrbie1IdNUeRe6UNLVRB72Nh1v9zfQR/+FSbf6afsIMAB0elCwFZfPigAAAABJRU5ErkJggg==)
}

.halo .box {
    position: absolute;
    top: 100%;
    margin-top: 30px;
    left: -20px;
    right: -20px;
    text-align: center;
    color: white;
    font-size: 10px;
    line-height: 14px;
    background-color: #1abc9c;
    border-radius: 6px;
    padding: 6px
}

.halo.small .box {
    margin-top: 25px
}

.halo.tiny .box {
    margin-top: 20px
}

.halo .link.halo-magnet {
    opacity: .1;
    transition: none;
    display: none
}

.halo .link.halo-magnet:hover {
    opacity: 1
}
*/
/*! Rappid - the diagramming toolkit

 Copyright (c) 2013 client IO

 2015-02-03 


 This Source Code Form is subject to the terms of the Rappid License
 , v. 2.0. If a copy of the Rappid License was not distributed with this
 file, You can obtain one at http://jointjs.com/license/rappid_v2.txt
 or from the Rappid archive as was distributed by client IO. See the LICENSE file.*/
/*.free-transform {
    position: absolute;
    pointer-events: none;
    border: 1px dashed black;
    border-radius: 5px;
    -moz-user-select: none;
    -webkit-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-user-drag: none;
    user-drag: none
}

.free-transform>div {
    position: absolute;
    pointer-events: auto;
    background-color: #c0392b;
    border: 1px solid black
}

.free-transform>div:hover {
    background-color: #e74c3c
}

.free-transform .resize {
    border-radius: 6px;
    width: 8px;
    height: 8px
}

.free-transform .resize[data-position="top-left"] {
    top: -6px;
    left: -6px
}

.free-transform .resize[data-position="top-right"] {
    top: -6px;
    right: -6px
}

.free-transform .resize[data-position="bottom-left"] {
    bottom: -6px;
    left: -6px
}

.free-transform .resize[data-position="bottom-right"] {
    bottom: -6px;
    right: -6px
}

.free-transform .resize[data-position="top"] {
    top: -6px;
    left: 50%;
    margin-left: -6px
}

.free-transform .resize[data-position="bottom"] {
    bottom: -6px;
    left: 50%;
    margin-left: -6px
}

.free-transform .resize[data-position="left"] {
    left: -6px;
    top: 50%;
    margin-top: -8px
}

.free-transform .resize[data-position="right"] {
    right: -6px;
    top: 50%;
    margin-top: -8px
}

.free-transform.prevent-aspect-ratio .resize[data-position="top"],.free-transform.prevent-aspect-ratio .resize[data-position="bottom"],.free-transform.prevent-aspect-ratio .resize[data-position="left"],.free-transform.prevent-aspect-ratio .resize[data-position="right"] {
    display: none
}

.free-transform .resize.n {
    cursor: n-resize
}

.free-transform .resize.s {
    cursor: s-resize
}

.free-transform .resize.e {
    cursor: e-resize
}

.free-transform .resize.w {
    cursor: w-resize
}

.free-transform .resize.ne {
    cursor: ne-resize
}

.free-transform .resize.nw {
    cursor: nw-resize
}

.free-transform .resize.se {
    cursor: se-resize
}

.free-transform .resize.sw {
    cursor: sw-resize
}

.free-transform .rotate {
    border-radius: 6px;
    width: 10px;
    height: 10px;
    top: -20px;
    left: -20px;
    cursor: pointer
}

.free-transform.in-operation {
    border-style: hidden
}

.free-transform.in-operation>div {
    display: none
}

.free-transform>div.in-operation {
    display: block;
    background-color: #e74c3c
}
*/
/*! Rappid - the diagramming toolkit

 Copyright (c) 2013 client IO

 2015-02-03 


 This Source Code Form is subject to the terms of the Rappid License
 , v. 2.0. If a copy of the Rappid License was not distributed with this
 file, You can obtain one at http://jointjs.com/license/rappid_v2.txt
 or from the Rappid archive as was distributed by client IO. See the LICENSE file.*/
/*.selection {
    position: absolute;
    background-color: #3498db;
    opacity: .3;
    border: 2px solid #2980b9;
    overflow: visible
}

.selection.selected {
    background-color: transparent;
    border: 0;
    opacity: 1;
    cursor: move;
    position: static;
    height: 0 !important
}

.selection-box {
    position: absolute;
    border: 2px dashed #f39c12;
    padding-right: 5px;
    padding-bottom: 5px;
    margin-top: -4px;
    margin-left: -4px;
    box-sizing: content-box;
    box-shadow: 2px 2px 5px lightgray
}

.selection-wrapper {
    position: absolute;
    border: 2px solid #f39c12;
    box-shadow: 2px 2px 5px lightgray;
    margin-left: -6px;
    margin-top: -6px;
    padding-right: 9px;
    padding-bottom: 9px;
    pointer-events: none
}

.selection-wrapper[data-selection-length="0"],.selection-wrapper[data-selection-length="1"] {
    display: none
}

.selection .box {
    position: absolute;
    top: 100%;
    margin-top: 30px;
    left: -20px;
    right: -20px;
    text-align: center;
    color: white;
    font-size: 10px;
    line-height: 14px;
    background-color: #1abc9c;
    border-radius: 6px;
    padding: 6px
}

.selection .handle.se {
    bottom: -25px;
    right: -25px
}

.selection .handle.nw {
    top: -21px;
    left: -25px
}

.selection .handle.n {
    top: -22px;
    left: 50%;
    margin-left: -10px
}

.selection .handle.e {
    right: -25px;
    top: -webkit-calc(50% - 10px);
    top: calc(50% - 10px)
}

.selection .handle.ne {
    top: -21px;
    right: -25px
}

.selection .handle.w {
    left: -25px;
    top: 50%;
    margin-top: -10px
}

.selection .handle.sw {
    bottom: -25px;
    left: -25px
}

.selection .handle.s {
    bottom: -24px;
    left: 50%;
    margin-left: -10px
}

.selection .handle {
    position: absolute;
    pointer-events: auto;
    width: 20px;
    height: 20px;
    background-size: 20px 20px;
    background-repeat: no-repeat;
    -moz-user-select: none;
    -webkit-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-user-drag: none;
    user-drag: none;
    cursor: pointer
}

.selection .remove {
    cursor: pointer;
    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAO5JREFUeNrUV9sNwyAMtLoAI3SEjJIRMgqjdBRG8CiMQGnlVHwEOBAE19L9OdwRGz+IcNsibISLCBk48dlooB0RXCDNgeXbbntWbovCyVlNtkf4AeQnvJwJ//IwCQdy8zAZeynm/gYBPpcT7gbyNDGb4/4CnyOLb1M+MED+MVPxZfEhQASnFQ4hp4qIlJxAEd+KaQGlpiIC8bmCRZOvRNBL/kvGltp+RdRLfqK5wZhCITMdjaury5lB5OFBCuxvQjAtCZc/w+WFaHkpXt6MVLTj5QOJipFs+VCqYixXsZioWM1GLaf7yK45ZT1/CzAAESidXQn9F/MAAAAASUVORK5CYII=)
}

.selection .rotate {
    cursor: move;
    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI1NTk5RUFBMkU3RjExRTI4OUIyQzYwMkMyN0MxMDE3IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI1NTk5RUFCMkU3RjExRTI4OUIyQzYwMkMyN0MxMDE3Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MjU1OTlFQTgyRTdGMTFFMjg5QjJDNjAyQzI3QzEwMTciIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MjU1OTlFQTkyRTdGMTFFMjg5QjJDNjAyQzI3QzEwMTciLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6W+5aDAAABJElEQVR42syXbRGDMAyGYTcBOBgSkICESWAOmAMcTAJzgAQksCnYHFRC13Jlx7qkDf0Acvf+6ZF7mjRNQ8o5T/ZqmVAt1AkxIa5JrvXqmywUsAVANkmf3BV6RqKjSvpWlqD+7OYBhKKHoMNS6EuddaPUqjUqfIJyPb2Ysyye0pC6Qm0I8680KJ/vhDmcFbU2mAb9glvk48KhMAtiYY7RYunxuRVWcI2cqa/ZegBYFGWA5jPYwAy4MrGhI1hf6FaA8gPg/PSA9tSbcAz8il2XOIRM9SILXVxki3GdEvUmD6bhIHYDQeFrtEwUvsYj0WBRx34Wc5cXJcQg8GMpMPrUBsBb6DHrbie1IdNUeRe6UNLVRB72Nh1v9zfQR/+FSbf6afsIMAB0elCwFZfPigAAAABJRU5ErkJggg==)
}
*/
/*! Rappid - the diagramming toolkit

 Copyright (c) 2013 client IO

 2015-02-03 


 This Source Code Form is subject to the terms of the Rappid License
 , v. 2.0. If a copy of the Rappid License was not distributed with this
 file, You can obtain one at http://jointjs.com/license/rappid_v2.txt
 or from the Rappid archive as was distributed by client IO. See the LICENSE file.*/
/*.paper-scroller {
    position: relative;
    overflow: scroll;
    cursor: move;
    cursor: -moz-grabbing;
    cursor: -webkit-grabbing;
    box-sizing: border-box
}

.paper-scroller>.paper {
    margin: 0;
    position: relative;
    display: inline-block
}

.paper-scroller>.paper>svg {
    display: block
}
*/
/*! Rappid - the diagramming toolkit

 Copyright (c) 2013 client IO

 2015-02-03 


 This Source Code Form is subject to the terms of the Rappid License
 , v. 2.0. If a copy of the Rappid License was not distributed with this
 file, You can obtain one at http://jointjs.com/license/rappid_v2.txt
 or from the Rappid archive as was distributed by client IO. See the LICENSE file.*/
/*
.inspector {
    position: absolute;
    top: 0;
    bottom: 0;
    right: 0;
    left: 0;
    overflow: auto
}

.inspector label {
    display: block;
    margin-top: 5px;
    margin-bottom: 10px;
    font-size: 12px
}

.inspector input,.inspector textarea {
    width: 200px;
    text-shadow: 0 -1px 0 #000;
    color: #ddd;
    box-shadow: inset 0 0 0 1px rgba(0,0,0,0.1),0 0 0 1px rgba(255,255,255,0.1);
    border: 1px solid black;
    background: transparent;
    height: 20px;
    line-height: 20px
}

.inspector input[type="range"] {
    height: 1px;
    line-height: 1px
}

@media screen and (min-width: 0\0) {
.inspector input[type="range"] {
        height:20px;
        line-height: 20px
    }
}

@media screen and (-ms-high-contrast:active),(-ms-high-contrast:none) {
.inspector .group>.field>form {
        height: 60px
    }

.inspector input[type="range"] {
        height: 10px;
        border-style: hidden;
        box-shadow: none
    }

.inspector input[type="range"]::-ms-fill-lower {
        background-color: lightgray
    }

.inspector input[type="range"]::-ms-fill-upper {
        background-color: white
    }

.inspector input[type="range"]::-ms-track {
        color: transparent
    }

.inspector input[type="range"]::-ms-thumb {
        background-color: #242424;
        border-style: hidden
    }

.inspector input[type="range"]::-ms-tooltip {
        display: none
    }
}

.inspector .group {
    overflow: hidden;
    padding: 10px
}

.inspector .group.closed {
    height: 16px
}

.inspector .group.closed .field {
    display: none
}

.inspector .group>.group-label {
    padding: 5px 4px;
    position: relative;
    left: -10px;
    margin-right: -20px;
    margin-top: 0;
    margin-bottom: 0;
    font-size: 10px;
    font-weight: 700;
    text-transform: uppercase;
    border-top: 1px solid #3a3a3a;
    border-bottom: 2px solid #1f1f1f;
    background: #242424;
    cursor: pointer;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none
}

.inspector .group>.group-label:before {
    content: '';
    width: 0;
    height: 0;
    display: inline-block;
    margin-left: 2px;
    margin-right: 5px;
    position: relative;
    top: 5px;
    border-top: 5px solid white;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-bottom: 5px solid transparent
}

.inspector .group.closed>.group-label:before {
    top: 2px;
    left: 2px;
    border-top: 5px solid transparent;
    border-bottom: 5px solid transparent;
    border-right: 5px solid transparent;
    border-left: 5px solid white
}

.link-tools .tool-options {
    display: block
}

.inspector .toggle {
    position: relative;
    width: 97px;
    height: 14px
}

.inspector .toggle input {
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    -ms-filter: "alpha(opacity=0)";
    filter: alpha(opacity=0);
    -moz-opacity: 0;
    opacity: 0;
    z-index: 100;
    position: absolute;
    width: 100%;
    height: 100%;
    cursor: pointer;
    box-sizing: border-box;
    padding: 0;
    box-shadow: none;
    -webkit-appearance: none
}

.inspector .toggle input:checked+span {
    background: #9abb82
}

.inspector .toggle span {
    display: block;
    width: 100%;
    height: 100%;
    background: #a5a39d;
    border-radius: 40px;
    box-shadow: inset 0 3px 8px 1px rgba(0,0,0,0.2),0 1px 0 rgba(255,255,255,0.5);
    position: relative
}

.inspector .toggle span:before {
    box-sizing: border-box;
    padding: 0;
    margin: 0;
    content: "";
    position: absolute;
    z-index: -1;
    top: -18px;
    right: -18px;
    bottom: -18px;
    left: -18px;
    border-radius: inherit;
    background: #eee;
    background: -moz-linear-gradient(#e5e7e6,#eee);
    background: -ms-linear-gradient(#e5e7e6,#eee);
    background: -o-linear-gradient(#e5e7e6,#eee);
    background: -webkit-gradient(linear,0 0,0 100%,from(#e5e7e6),to(#eee));
    background: -webkit-linear-gradient(#e5e7e6,#eee);
    background: linear-gradient(#e5e7e6,#eee);
    box-shadow: 0 1px 0 rgba(255,255,255,0.5)
}

.inspector .toggle input:checked+span i {
    right: -1%
}

.inspector .toggle input:checked+span i:before {
    content: "on";
    right: 115%;
    color: #82a06a;
    text-shadow: 0 1px 0 #afcb9b,0 -1px 0 #6b8659
}

.inspector .toggle span i {
    display: block;
    height: 100%;
    width: 60%;
    border-radius: inherit;
    background: silver;
    position: absolute;
    z-index: 2;
    right: 40%;
    top: 0;
    background: #b2ac9e;
    background: -moz-linear-gradient(#f7f2f6,#b2ac9e);
    background: -ms-linear-gradient(#f7f2f6,#b2ac9e);
    background: -o-linear-gradient(#f7f2f6,#b2ac9e);
    background: -webkit-gradient(linear,0 0,0 100%,from(#f7f2f6),to(#b2ac9e));
    background: -webkit-linear-gradient(#f7f2f6,#b2ac9e);
    background: linear-gradient(#f7f2f6,#b2ac9e);
    box-shadow: inset 0 1px 0 white,0 0 8px rgba(0,0,0,0.3),0 5px 5px rgba(0,0,0,0.2)
}

.inspector .toggle span i:before {
    content: "off";
    text-transform: uppercase;
    font-style: normal;
    font-weight: bold;
    color: rgba(0,0,0,0.4);
    text-shadow: 0 1px 0 #bcb8ae,0 -1px 0 #97958e;
    font-family: Helvetica,Arial,sans-serif;
    font-size: 10px;
    position: absolute;
    top: 50%;
    margin-top: -5px;
    right: -50%
}

.inspector .btn-list-add,.inspector .btn-list-del {
    background: transparent;
    color: white;
    border: 1px solid gray;
    cursor: pointer;
    border-radius: 2px;
    box-shadow: 1px 1px 1px black;
    width: 23px;
    margin: 2px;
    margin-right: 8px
}

.inspector .btn-list-add:hover,.inspector .btn-list-del:hover {
    box-shadow: inset 1px 1px 1px black
}

.inspector .list-items {
    margin-top: 4px
}

.inspector .list-item {
    margin-top: 2px;
    border: 1px solid #242424;
    padding: 10px;
    background-color: #3a3a3a;
    box-shadow: inset 0 0 2px gray
}

.inspector .list-item input {
    width: 150px
}

.inspector .list-item .list-item input {
    width: 125px
}

.inspector .list-item>.field>label {
    display: none
}

.inspector .field {
    display: inline
}

.inspector .hidden {
    display: none
}
*/
/*! Rappid - the diagramming toolkit

 Copyright (c) 2013 client IO

 2015-02-03 


 This Source Code Form is subject to the terms of the Rappid License
 , v. 2.0. If a copy of the Rappid License was not distributed with this
 file, You can obtain one at http://jointjs.com/license/rappid_v2.txt
 or from the Rappid archive as was distributed by client IO. See the LICENSE file.*/
/*.tooltip {
    position: fixed;
    z-index: 100;
    border-radius: 5px;
    background-color: #333;
    border: 2px solid #242424;
    color: #bcbcbc;
    pointer-events: none;
    padding: 10px;
    font-size: 14px;
    text-shadow: 0 -1px 0 #000
}

.tooltip.small {
    padding: 5px;
    font-size: 10px
}

.tooltip:after,.tooltip:before {
    border: solid transparent;
    content: " ";
    height: 0;
    width: 0;
    position: absolute;
    pointer-events: none
}

.tooltip.left:after,.tooltip.left:before {
    right: 100%;
    top: 50%
}

.tooltip.right:after,.tooltip.right:before {
    top: 50%;
    left: 100%
}

.tooltip.top:after,.tooltip.top:before {
    left: 50%;
    bottom: 100%
}

.tooltip.bottom:after,.tooltip.bottom:before {
    left: 50%;
    top: 100%
}

.tooltip:after {
    border-width: 6px
}

.tooltip.left:after {
    border-right-color: #333;
    margin-top: -6px
}

.tooltip.right:after {
    border-left-color: #333;
    margin-top: -6px
}

.tooltip.top:after {
    border-bottom-color: #333;
    margin-left: -6px
}

.tooltip.bottom:after {
    border-top-color: #333;
    margin-left: -6px
}

.tooltip:before {
    border-width: 8px
}

.tooltip.left:before {
    border-right-color: #242424;
    margin-top: -8px
}

.tooltip.right:before {
    border-left-color: #242424;
    margin-top: -8px
}

.tooltip.top:before {
    border-bottom-color: #242424;
    margin-left: -8px
}

.tooltip.bottom:before {
    border-top-color: #242424;
    margin-left: -8px
}
*/
/*! Rappid - the diagramming toolkit

 Copyright (c) 2013 client IO

 2015-02-03 


 This Source Code Form is subject to the terms of the Rappid License
 , v. 2.0. If a copy of the Rappid License was not distributed with this
 file, You can obtain one at http://jointjs.com/license/rappid_v2.txt
 or from the Rappid archive as was distributed by client IO. See the LICENSE file.*/
/*.snaplines {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none
}

.snapline {
    position: absolute;
    pointer-events: none;
    opacity: 1
}

.snapline.horizontal {
    width: 100%;
    border-bottom: 1px solid #2ecc71
}

.snapline.vertical {
    height: 100%;
    border-right: 1px solid #2ecc71
}
*/
/*! Rappid - the diagramming toolkit

 Copyright (c) 2013 client IO

 2015-02-03 


 This Source Code Form is subject to the terms of the Rappid License
 , v. 2.0. If a copy of the Rappid License was not distributed with this
 file, You can obtain one at http://jointjs.com/license/rappid_v2.txt
 or from the Rappid archive as was distributed by client IO. See the LICENSE file.*/
/*@media print {
@page {
        margin: 5mm
    }

    body {
        margin: 0 !important;
        padding: 0 !important
    }

    body:before {
        content: 'JointJS';
        font-size: 15mm;
        position: absolute;
        top: 5mm;
        right: 5mm;
        z-index: 100000
    }

.fobj>body:before {
        display: none
    }

.printarea {
        left: 0 !important;
        top: 0 !important;
        background: none !important;
        border: none !important;
        margin: 0 !important;
        padding: 0 !important;
        overflow: visible !important;
        z-index: 99999
    }

.printarea>*:not(svg) {
        display: none
    }
}

@media print and (orientation:landscape) {
.printarea.a4 {
        width: 270mm !important;
        height: 168mm !important
    }
}

@media print and (orientation:portrait) {
.printarea.a4 {
        width: 200mm !important;
        height: 232mm !important
    }
}

.toolbar-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding-left: 246px;
    height: 40px
}

.stencil-container {
    position: absolute;
    left: 0;
    top: 40px;
    bottom: 20px;
    width: 240px
}

.inspector-container {
    position: absolute;
    top: 40px;
    right: 0;
    bottom: 140px;
    width: 240px
}

.navigator-container {
    position: absolute;
    height: 120px;
    right: 0;
    bottom: 20px;
    width: 240px
}

.paper-container {
    position: absolute;
    top: 40px;
    left: 241px;
    right: 241px;
    bottom: 20px;
    overflow: hidden
}

.paper-container .paper-scroller {
    width: 100%;
    height: 100%
}

.statusbar-container {
    position: absolute;
    left: 0;
    bottom: 0;
    right: 0;
    height: 20px
}

.paper-scroller {
    background-color: hsla(220,11%,97%,.95)
}

.paper-scroller>.paper {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAHUlEQVQYV2NkYGAwBuKzQIwXMBJSAJMfVUidcAQAnUQBC6jEGBUAAAAASUVORK5CYII=');
    background-color: white;
    box-shadow: 0 0 2px lightgray
}

.element.basic.Rect rect,.element.basic.Circle circle,.element.devs.Atomic rect {
    -webkit-svg-shadow: 2px 2px 5px gray
}

.element.basic.Path path {
    -webkit-svg-shadow: 1px 1px 2px gray
}

.inspector-container {
    border: 1px solid #333;
    border-top: 1px solid #4f4f4f;
    color: #bcbcbc;
    text-shadow: 0 -1px 0 #000;
    background-color: #333
}

.stencil-container {
    border-top: 1px solid #4f4f4f;
    border-right: 1px solid lightgray;
    background-color: hsla(220,11%,97%,.95);
    color: #bcbcbc
}

.stencil-container>label {
    display: block;
    text-align: center;
    background-color: #333;
    font-size: 10px;
    line-height: 20px;
    height: 20px;
    text-shadow: 0 -1px 0 #000
}

.stencil-container>.btn-expand,.stencil-container>.btn-collapse {
    position: absolute;
    top: 2px;
    left: 2px;
    background: 0;
    border: 0;
    outline: 0;
    color: #bcbcbc;
    cursor: pointer;
    width: 20px;
    height: 16px;
    line-height: 16px;
    margin: 0;
    padding: 0;
    border: 1px solid #4f4f4f
}

.stencil-container>.btn-collapse {
    left: 25px
}

.stencil {
    top: 20px;
    background: #333
}

.stencil>.content {
    background: hsla(220,11%,97%,.95)
}

.stencil .search {
    background: transparent
}

.stencil .search:focus {
    outline: 0
}

.stencil.searchable>.content {
    top: 30px
}

.stencil .group {
    max-height: 700px
}

.stencil .group .elements {
    margin-left: -10px;
    background: transparent
}

.stencil .elements .element.basic.Image text,.stencil .elements .element.devs.Atomic .inPorts text,.stencil .elements .element.devs.Atomic .outPorts text,.stencil .elements .element.pn.Transition text {
    display: none
}

.stencil .element.unmatched {
    display: none
}

.stencil .group.unmatched {
    display: none
}

.halo .box {
    box-shadow: 2px 2px 5px lightgray;
    border: 1px solid #4f4f4f;
    text-shadow: 0 -1px 0 #000;
    font-size: 8px;
    color: #bcbcbc;
    background-color: #333
}

.selection-box {
    border: 2px dashed #f39c12;
    padding-right: 5px;
    padding-bottom: 5px;
    margin-top: -4px;
    margin-left: -4px;
    box-shadow: 2px 2px 5px lightgray
}

.toolbar-container {
    background-color: #333;
    color: #bcbcbc;
    text-shadow: 0 -1px 0 #000;
    border-top: 1px solid #4f4f4f
}

.toolbar-container .btn {
    background-color: #fafafa;
    background-image: -webkit-linear-gradient(top,#fff,#f2f2f2);
    background-image: -moz-linear-gradient(top,#fff,#f2f2f2);
    background-image: linear-gradient(top,#fff,#f2f2f2);
    background-repeat: repeat-x;
    border: 1px solid #d4d4d4;
    color: #333;
    text-shadow: none;
    border-top: 0
}

.toolbar-container label,.toolbar-container output {
    font-size: .8em
}

.toolbar-container label {
    margin-left: 10px
}

.toolbar-container input[type="range"] {
    width: 80px;
    text-shadow: 0 -1px 0 #000;
    color: #ddd;
    box-shadow: inset 0 0 0 1px rgba(0,0,0,0.1),0 0 0 1px rgba(255,255,255,0.1);
    border: 1px solid black;
    background: transparent;
    height: 1px;
    vertical-align: middle
}

.toolbar-container .panel {
    width: 40px;
    display: inline-block;
    text-align: center;
    font-size: .8em
}

@media screen and (min-width: 0\0) {
.toolbar-container input[type="range"] {
        height:20px;
        text-align: right
    }

    #output-gridsize {
        display: none
    }
}

@media screen and (-ms-high-contrast:active),(-ms-high-contrast:none) {
.toolbar-container input[type="range"] {
        height: 5px;
        border-style: hidden;
        box-shadow: none;
        position: absolute
    }

    #output-gridsize {
        margin-left: 90px;
        display: inline
    }

.toolbar-container input[type="range"]::-ms-fill-lower {
        background-color: lightgray
    }

.toolbar-container input[type="range"]::-ms-fill-upper {
        background-color: white
    }

.toolbar-container input[type="range"]::-ms-track {
        color: transparent
    }

.toolbar-container input[type="range"]::-ms-thumb {
        background-color: #242424;
        border-style: hidden
    }

.toolbar-container input[type="range"]::-ms-tooltip {
        display: none
    }
}

.statusbar-container {
    background-color: hsla(220,11%,97%,.95);
    border-top: 1px solid lightgray
}

.statusbar-container.error {
    background-color: #e74c3c;
    color: white;
    text-shadow: 0 -1px 0 rgba(0,0,0,0.25);
    background-image: -webkit-linear-gradient(top,#e74c3c,#c0392b);
    background-image: -moz-linear-gradient(top,#e74c3c,#c0392b);
    border-color: rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);
    font-size: 10px;
    line-height: 20px
}

.free-transform .rotate {
    display: none
}

.free-transform .resize {
    width: 6px;
    height: 6px;
    background-color: white;
    border-width: 2px
}

.free-transform>div.in-operation,.free-transform .resize[data-position]:hover {
    width: 10px;
    height: 10px;
    background-color: white;
    z-index: 9
}

.free-transform .resize[data-position="top-left"] {
    border-radius: 0 0 5px 0;
    top: -1px;
    left: -1px;
    z-index: 3
}

.free-transform .resize[data-position="top-right"] {
    border-radius: 0 0 0 5px;
    top: -1px;
    right: -1px;
    z-index: 2
}

.free-transform .resize[data-position="bottom-left"] {
    border-radius: 0 5px 0 0;
    bottom: -1px;
    left: -1px;
    z-index: 2
}

.free-transform .resize[data-position="bottom-right"] {
    border-radius: 5px 0 0 0;
    bottom: -1px;
    right: -1px;
    z-index: 3
}

.free-transform .resize[data-position="top"] {
    border-radius: 0 0 5px 5px;
    top: -1px;
    left: 50%;
    margin-left: -5px;
    z-index: 1
}

.free-transform .resize[data-position="bottom"] {
    border-radius: 5px 5px 0 0;
    bottom: -1px;
    left: 50%;
    margin-left: -5px;
    z-index: 1
}

.free-transform .resize[data-position="left"] {
    border-radius: 0 5px 5px 0;
    left: -1px;
    top: 50%;
    margin-top: -5px;
    z-index: 1
}

.free-transform .resize[data-position="right"] {
    border-radius: 5px 0 0 5px;
    right: -1px;
    top: 50%;
    margin-top: -5px;
    z-index: 1
}

.free-transform .resize[data-position="bottom"]:hover,.free-transform .resize[data-position="top"]:hover,.free-transform .resize[data-position="bottom"].in-operation,.free-transform .resize[data-position="top"].in-operation {
    margin-left: -7px
}

.free-transform .resize[data-position="left"]:hover,.free-transform .resize[data-position="right"]:hover,.free-transform .resize[data-position="left"].in-operation,.free-transform .resize[data-position="right"].in-operation {
    margin-top: -7px
}

.free-transform[data-type="devs.Atomic"] .resize[data-position="left"],.free-transform[data-type="devs.Atomic"] .resize[data-position="right"] {
    display: none
}

.navigator-container {
    border: 1px solid hsla(220,11%,97%,.95);
    border-left-color: lightgray
}

.navigator>.paper {
    background-color: #fff
}

.navigator {
    background-color: hsla(220,11%,97%,.95)
}

.navigator .current-view-control {
    display: none
}

html,body {
    margin: 0;
    padding: 0
}

body {
    -webkit-user-select: none;
    -moz-user-select: -moz-none;
    -khtml-user-select: none;
    -ms-user-select: none;
    user-select: none;
    font-family: Arial;
    font-family: "Source Sans Pro",sans-serif
}

h1 {
    position: absolute;
    z-index: 1;
    top: 8px;
    color: white;
    margin: 0;
    padding: 0;
    font-size: 18px;
    width: 240px;
    text-align: center
}

.btn {
    background-color: #49afcd;
    padding: 4px 8px;
    color: white;
    text-shadow: 0 -1px 0 rgba(0,0,0,0.25);
    font-size: 11px;
    line-height: 30px;
    border: 1px solid #ccc;
    background-image: -webkit-linear-gradient(top,#5bc0de,#2f96b4);
    background-image: -moz-linear-gradient(top,#5bc0de,#2f96b4);
    background-image: linear-gradient(top,#5bc0de,#2f96b4);
    border-color: rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);
    margin: 0;
    margin-left: -5px;
    cursor: pointer
}

.btn:hover {
    opacity: .9
}

.btn>img {
    vertical-align: middle;
    height: 20px
}
</style>

<style type="text/css">

.toolbar-container .btn-secondary {
    background-color: #f1c40f;
    padding: 12px 18px 13px;
    line-height: 13px;
    border: none;
    color: white;
    font-size: 18px;
    text-shadow: none;
    cursor: pointer;
    border-radius: 5px;
    display: block;
    text-decoration: none;
    float: right;
    width: 60px;
    position: absolute;
    top: 0;
    right: 1px;
}
.toolbar-container .btn-secondary:hover {
    background-color: #f5d313;
}
.twitter-share-button {
    position: absolute;
    z-index: -1;
    top: 10px;
    right: 80px;
}
#___plusone_0 {
    position: absolute;
    z-index: -1;
    top: 13px;
    right: 188px;
}
h1 > a {
    text-decoration: none;
    color: white;
}
</style>
</head>
<body>
<h1><a href="/about-rappid">Rappid</a></h1>
<div class="toolbar-container">
    <button id="btn-undo" data-tooltip="Undo" class="btn"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABEElEQVR4XsWX4W2DMBCFDysDMAIblBHqCZJuABOkI8AkyQaFCcII3qDZINmAvn8HsjjLLvg+6fuJ3uMOZJkSuZEKHD7TTpiE8IZ2xOiEM0YnnDE64YzRCWeKf4RbWuPgO7rAzmN/wgmOcIgsIIcnlunhXSyQYecT/NpaT5Hpg3PQcgnGUB5q+FBYgUcPO2kCLbzTcVxhmfgbpiO8JE8gYRJ2YQt7OFGYMy04BZrS1iSEsBJ+87g9PuUVyOuIebaCP7CWnjURO4vlCS10wdPwwBJv2AYLHFzCwUEskKHEuF4Nc0r6j2PwQ503gSwlmNErkJmBFGjgDG9ax/EHn4Y6/GreJ2v4gqXmZfZCSlSwI4E/JYY7X+odiRcAAAAASUVORK5CYII=" alt="Undo"/></button>
    <button id="btn-redo" data-tooltip="Redo" class="btn"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABD0lEQVR4XsWTwQ2CQBBFRSmAEuhASsAK0JtHrMASwA60grUDsQK1AzrQDqQD/CEkm5CJs5kwmZ+883u7sIsZ54DpeknEcuaIEjjDAB9hGOAjDALICD7AMiIWChKQhUcMO1CCCIRuCwqQg1QQfaUi4sATVIxUfBMRc803kPMC+U1Ef+SPyXfWiKBfga6c/wlrUAE/xU+wJK7+qC/3W00E+xF2Ws+wANye4AU+A36PEDkXkANqHbiAM+jkJ+cDEkLegp0/7Xxy4hmS8o2SnA8Y6zsdOR/QgFZJTgdMrvquIGcDWiJGIJcH3IFohFwU0ADzOdCDUkfAv4LTKFhb38LbMiABX5BZRmyBA6arQaop+AEtOTirltYeOAAAAABJRU5ErkJggg==" alt="Redo"/></button>
    <button id="btn-clear" data-tooltip="Clear Paper" class="btn"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABmJLR0QA/wD/AP+gvaeTAAADGklEQVRoge2ZTWgUSRTHf68n3eNH2EAE8esiRPTUEAojwZxEPKhXL0ZByHFBkBjd07IqiCAeBK8iih68exFEchCCEyojgXga8CCRze5BRNGeZqZrLz2hM2NnUp2ezKzM71T16lXV/029ft1MCRlQSu0wxsyIyAXgALAtyzpAAHwEnnqed3dubu6H7QJiO8H3/Z2u674GxmzntuEtcEJr/d1mkmO7i+u618lfPMAx4KrtpIEMG002GsaYa8Vi8UGWowcYHx/fHobhZeBObLoI3LRZwzqFlFI1oAAQBEFxaWkptF0jycjISHFoaCiIuzWttWsz3zqFiMUDbFY8QKVSqSa61hnRcgLxsf4JnAP2k73C5EUALIvI88HBwVuzs7NBcnBNAEqpHSLyyhgzvqUSN84bz/NOJZ+5NSlkjJnpYfEAE9Vq9UrSsCbnROR8o73ZCpMXzZVKRCaB243x5hSqE59KHhUmL5oqVV1rvfrDN1eh1X6viIeWSlVIjmUpoz1Fc90NAQ9AKXWn1b0nSJ5GSwAlYCJuX98SOfaUkp01KSQi08DnLZVjx2fHcaaThpY3se/7uz3PO2uMeZgw/9FxaT9nNY1FZCoMwxeLi4v/JB1SP+aUUqbR1lpbf/TlwUY0/HJVqC1jY2MH6/X6JDAYm74VCoVnpVLpQ94+HQmgXq+/BA412S4AR/L22QhZUuiQiNzQWovWWkTkBnC4Qz4dCaCn6AfQbfoBdJt+AN2mH0C36QfQbfoBdJt+AN2mH0C3+d8HkOWSLzTGnFRKbQMwxkzQ9Hdfjj5tsb+TErlvjLkCHI9NNeBeJ3w2pCdtQCn1DdgJ4DjO3vn5+b9tF98Mo6Oj+xzHWY67X7XWv/3ML/UZMMa8b7SjKLqUr7z2iEhyz6U0v/VS6DFwNG7fVEoRRdHDcrn8bw76UvF9f7frulPAXwnzkzT/1BSKr3VKgJ+fvEy8C4LgWNqNUWoKVSqVaq1WOw2UOyatPQtRFJ1Z77qrkDYAsLKy8nV4ePjRwMDAJxHZA+wiW+m1oWqMKTuOcwv4fWFh4ct6zv8BQPRFE7ZPzhYAAAAASUVORK5CYII=" alt="Clear"/></button>
    <button id="btn-svg" data-tooltip="Open as SVG in a New Window" class="btn">open as SVG</button>
    <button id="btn-png" data-tooltip="Open as PNG in a New Window" class="btn">open as PNG</button>
    <button id="btn-zoom-in" data-tooltip="Zoom In" class="btn"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABmJLR0QA/wD/AP+gvaeTAAADsklEQVRogc3ZS4gcVRQG4G+a4GRmTJxORkgQ3AhifMQoGTU+8IW6UVeu3QSXEtGgiGShcSUuhCAqQVEEQRGMoq4UH2CU0aj4iJqAC8lC1OgYnZmoMz0ubjdop051VVd1Z344m6p7/vOfvrdvnXPviP6xCpfgemzBJmzoGvMzDuILvIWP8E+FmLVgGk/iFyyXtF/xNK4YumpslX7FsqIje9+QEhnHHizWKL5jLezFmkGJ34SvBiC82w7hwrrFX4nZIYjv2Bxuqkv8NH4vEHRRWss72wlvRLNtG7ANO/C2tPv04pvH1VXFny1tf3mBFvAITi/B28SD+LMH9yw29yt+XNqz8wLsw5n9BpBm6YUeMQ5hbT/kj+WQtrAbIxXE/xf3Yikn3jNlCc8Xr9MWttehugu3ibfnFi4tQ/ZaQLSMh2uTfCJ25sR9tyjJRVLGWSSvKrZsFgL/8QK+z+ckUWhX2hs4z+GMIgQVE2jiaOD/Ui/nUfwWOD9aUHzVBGBX4D+vR6lxbeC45MTyeJAJrMHxgOPWyKnRTiALM/ixYPA68AfeCd5dFzk1xEXUvqqK+sArwfMteU5fy562q4Lxfwfjy1rWur4gGHskL4Gos9p4EhIYC8aGbWgjICIVVcPGQtu6sQoTWQ4N8UdquSZRdaGV9bAh/fuzcNrgtIQYlZZRN+Zkz4yGVPtn4ayaRJVBFPNo5NCQau8sXB48P0Vadt12PBg/EYzPmvko5vfBcw18Gby7JXIaIKKY+/OcbpC9dS1iqkTwqqXEuLTWszhuznMcw7HAcfcQE7gn8D+GU3s5R+X0guL9b5UEpsRHOE8VCX5Z4LwsNeCDTuCJnPjbCsb3Zg7JrqIkfeDOnLhvlCG6WNxgL0kNeN24UVxbLbU1lcKegKyzK91dh+o27pBfGB7BZFnSCelCIq+KfFa57bUbk3i8R4yOzfSTxGa9z0Vncb+gQgywGncpfzHysdT0l8I1UjPdi3xeOnbZjvPaIjsYxTm4HS9LpUMZ4ZWTmMZPFYLWbQeVO2QA5+LbFSC+Y5/oYybW4jnxyV0VW8QPJX0OYF3ZJEgHre/VKP516UB5UlrjQ0mCdEbzorhyzLNZ6Yp2axdnU1oeZbhmsLrKWf+EtFtFF91/Sd3eYXyAD6XT5vmAryld45b5+j5URnARjLSF9HW7Ii2LA4rPwuGKegeCdfhUsQSiNvakYz0+0zuBqJ9fEViPz+UnMMgyvxZMif8T+/2/dFmxGMMD+E7qEb7BfVKt5V+/8SIUe2mE0AAAAABJRU5ErkJggg==" alt="Zoom in"/></button>
    <button id="btn-zoom-out" data-tooltip="Zoom Out" class="btn"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABmJLR0QA/wD/AP+gvaeTAAADoklEQVRogc3ZS2hcZRQH8F+GYprE1qSN0CK4EcT6qFUatT7whbpRV67dFJei2KKIdKF1JS6EIipFUQRBEayirhQfYJVoVXxUbcGFdCHaaqwmqZpkXHwzYCf33Dt37p1p/nA2d+75n/+Z75tvzjnfkN6xCpfhRmzBJmzoeOdXHMRXeAef4N8KMWvBFJ7GUTRL2m94FlcNXDW2St9iWdGRfWhAiYxiDxZqFN+2JezFmn6J34Rv+iC80w7h4rrFX42ZAYhv2yxuqUv8FP7oIuiCtJd3thLeiImWbcA23IN3pdOniG8O11YVf650/OUFmsdjOLME7wQexl8F3DPY3Kv4UenMzguwD2f3GkBapZcKYhzC2l7In8ghXcJuDFUQ/3/cj8WceM+VJbxQvE+XsL0O1R24Q3w8L+HyMmRvBERNPFqb5OXYmRP3/W5JLpEyziJ5XX3bJsKLQeymLk+lvYHzLM6qX+8yTOBYoOGVIudh/B44P94fvZnYFWiYU1BqXB84LlpeHvcTa3Ai0HJ75NSQEsjCNH6uV2Mu/sR7wWc3RE4NcRG1r6qiHvBa8HxLntO3spftmuD9f4L3y1rWvr4oePdIXgJRZ7XxFCQwErwbtqGNgIhUVA0a8y3rxCqMZTk0xH9SzZpE1YWlrIcN6defhTP6pyXEsLSNOjEre2U0pNo/C+fUJKoMopjHIoeGVHtn4crg+WnStqtqWSsfxfwxL4Gvg89ui5z6iCjm/jynm2QfXQuYrFNdAUalvZ6l5dY8xxEcDxx390/vMuwINBzH6UXOUTk9r1r/2y0mxSOcZ7ohuCJwbkoNeL/xVE78bd2SvJ1DsqtevSfh7py4b5UhulTcYC9KDXjduFlcWy22NJXCnoCsfSrdV4fqFu6SXxgewXhZ0jHpQiKvinxeteN1HE8WxGjbdC9JbFY8F53Bg4IKMcBq3Kv8xcinUtNfCtdJzXQR+Zw0dtmOC1oi2xjGebgTr0qlQxnhlZOYwi8VgtZtB/UwZDgf368A8W37TA8rsRYviCd3VWwBP5X0OYB1ZZMgDVo/qFH8m9JAeVza4wNJgjSjeVlcOebZjHRFu7WDc0LaHmW4prG6ytB2TDqtoovuv6Vu7zA+wsfStHku4JuQrnHL/Ps+UkZwNxhqCenpdkXaFgd0vwqHK+rtC9bhc90lcOIUaSzEenyhOIGon18RWI8v5SfQzzK/FkyKfxP7nVy6rFiM4CH8IPUI3+EBqdbyH40n8SlrBGmdAAAAAElFTkSuQmCC" alt="Zoom out"/></button>
    <button id="btn-fullscreen" class="btn" data-tooltip="Toggle Fullscreen Mode"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAQAAADYBBcfAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJiS0dEAP+Hj8y/AAAACXBIWXMAAABIAAAASABGyWs+AAABbUlEQVQ4y5WUz07CQBCHP7oloT0KHjSejZjoC+gB9CSJVwzSSoKPJF70aVAfgdCS6MX4J0ZvcrEprYfapi3brcxeOpP5+pvM7Cy8EBAunTlDqihMY5OKJP7MOwFKCyXHwcaA1cCACVY5tgx63LJWjmlLEcEhp5irK4YEuFyUo6EUnWGVoXHqT2aeAS59NRolTrhhmtN16aKrQQebOhZOBvS5olYMfuNgYwIGfdxUsXe0JF1P7JKTZNwG5zgEhCwY00YHBIa84Coi5Rn0mOIxpo0AdI645uw/czXpMqKFDugc84CHm7uEQr45OsafWpt7gmQ4RvLrDsNiZS3B4uFEqiYDXObFYI0Ri9yyWTSwo86LYhKDPdZTfoMm2/RolrUp6nD2Inqxr1L0eeKDXRrJ41JBxN9CqenzyGcGTU2EUvSLJvU8WgaCzys77OcztVLQ5JQD1XoVYQNm0ldCaYJOatEyj4u6VI0NtiTxkLdfAa7UTxSrv/cAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTQtMDEtMThUMTI6NTI6MTMrMDE6MDDIgE2/AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTAxLTE4VDEyOjUyOjAzKzAxOjAwdXf1nQAAAABJRU5ErkJggg==" alt="Fullscreen"/></button>
    <button id="btn-to-front" data-tooltip="Bring Object to Front" class="btn">to front</button>
<button id="btn-to-back" data-tooltip="Send Object to Back" class="btn">to back</button>
<button id="btn-layout" data-tooltip="Auto-layout Graph" class="btn">layout</button>
    <label data-tooltip="Change Grid Size">Grid size:</label>
<input type="range" value="10" min="1" max="50" step="1" id="input-gridsize" />
    <output id="output-gridsize">10</output>
    <label data-tooltip="Enable/Disable Snaplines">Snaplines:</label>
<input type="checkbox" id="snapline-switch" checked/>

<a href="http://twitter.com/share" class="twitter-share-button" data-size="small" data-url="http://jointjs.com/rappid" data-count="horizontal" data-via="jointjs">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js">
    </script>
<div class="g-plusone" data-size="small" data-href="http://www.jointjs.com"></div>
    <script type="text/javascript">

    (function() {
        var po = document.createElement('script');
        po.type = 'text/javascript';
        po.async = true;
        po.src = 'https://apis.google.com/js/plusone.js';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(po, s);
    })();
</script>

<a class="btn-secondary" href="/about-rappid">README</a>
    </div>
    <div class="stencil-container">
    <label>Stencil</label>
    <button class="btn-expand" title="Expand all">+</button>
    <button class="btn-collapse" title="Collapse all">-</button>
    </div>
    <div class="paper-container"></div>
    <div class="inspector-container"></div>
    <div class="navigator-container"></div>
    <div class="statusbar-container" style="font-size: 11px; line-height: 20px">
    &nbsp;&nbsp;&nbsp;Copyright &copy; 2014 <a target="_blank" href="http://client.io">client IO</a>. All rights reserved. Part of the <b><a href="http://jointjs.com">JointJS</a> diagramming library</b>. <span class="rt-colab"></span>
</div>

<script type="text/javascript">
*/

/*
         Copyright 2013 client IO
         http://client.io

         Rappid General License Statement and Limited Warranty
         ======================================================

         Definitions
         -----------

         "Rappid" shall mean a programmer's toolkit 
         for building interactive diagramming applications as originally 
         created by client IO.

         "Software" shall mean Rappid, as originally created by
         client IO.

         "Licensee" is you, only if you agree to be bound by the terms
         and conditions set forth in this Agreement.

         "Source code" means the JavaScript files and other related files in the 
         Software package.


         This license statement and limited warranty constitutes a legal agreement 
         ("License Agreement") between You (either as an individual or a single entity) 
         and client IO for the software product ("Software") identified above, 
         including any software, media, and accompanying on-line or printed 
         documentation. By installing, copying, or otherwise using the
         Software, you are agreeing to be bound by the terms of this Agreement. If you
         do not agree to the terms of this Agreement, you are not authorized to use
         this Software.


         BY INSTALLING, COPYING, OR OTHERWISE USING THE SOFTWARE, YOU AGREE TO BE BOUND 
         BY ALL OF THE TERMS AND CONDITIONS OF THE LICENSE AGREEMENT.

         Upon your acceptance of the terms and conditions of the License Agreement, 
         client IO grants to you the right to use the Software in the manner provided 
         below. This license is perpetual, no additional payment is required to 
         maintain it, with the exception of you breaking any part of this license, in 
         which case you lose all rights under the license.

         You may transfer the rights granted to you under this agreement in and to the 
         Software and documentation on a permanent basis provided you retain no copies, 
         the recipient agrees to the terms of the License Agreement and the total number 
         of developers licensed to use the software does not exceed the number of 
         licensed developers at the time of license purchase. client IO must be informed 
         in writing of the transfer.

         Except as provided in the License Agreement, you may not transfer, 
         rent, lease, lend, copy, modify, translate, sublicense, time-share or 
         electronically transmit or receive the Software, media or documentation. When 
         transferring licenses, the whole of the licensed product must be transferred.

         In addition to the other terms contained herein, We grant to You a revocable, non-exclusive, 
         non-transferable and non-sublicensable license to install and use the Software (the "Trial License")
         strictly for Your internal evaluation and review purposes and not for production purposes. 
         This Trial License applies only if You have registered with Us for a Trial License of the Software and 
         shall be effective for thirty (30) consecutive days following the date of registration ("the Trial Period").
         You may only register for a Trial License once in any eighteen month period. You agree not to use a 
         Trial License for any purpose other than determining whether to purchase a license to the Software. 
         You are explicitly not permitted to distribute the Software to any user outside the Organization on whose 
         behalf you have undertaken this license. Your rights to use the Trial License will immediately terminate 
         upon the earlier of (i) the expiration of the Trial Period, or (ii) such time that You purchase a license 
         to the Software. We reserve the right to terminate Your Trial License at any time in Our absolute and 
         sole discretion.

         YOU ACKNOWLEDGE THAT TRIAL SOFTWARE MIGHT PLACE WATERMARKS ON OUTPUT, CONTAIN LIMITED FUNCTIONALITY, 
         FUNCTION FOR A LIMITED PERIOD OF TIME, OR LIMIT THE FUNCTIONALITY OR TIME OF FUNCTIONING OF ANY OUTPUT. 
         ACCESS TO AND/OR USE OF ANY FILES OR OUTPUT CREATED WITH SUCH SOFTWARE IS ENTIRELY AT YOUR OWN RISK. 
         WE ARE LICENSING THE SOFTWARE ON AN "AS IS" BASIS AT YOUR OWN RISK AND WE DISCLAIM ANY WARRANTY OR 
         LIABILITY TO YOU OF ANY KIND.


         Developer License Terms
         -----------------------

         To develop products using the Software, you require a number of development 
         licenses equal to the number of engineers developing the application area 
         that specifically uses the Software. This is the maximum number 
         of such developers over any 1 month sliding window. A development license is 
         not required in order to build an application that uses the software.

         A developer License may be installed on any number of computers 
         at any time. client IO grants to you non exclusive license to install
         and use the Software for the sole purposes of 
         designing, developing and testing application programs which you create.

         In addition to the right to install the complete software on the specified 
         number of computers, the Source code may also be placed on storage devices 
         for the purposes of version control, automated building and archiving. 
         The entire downloaded Software package may also be archived for backup purposes.


         Additional Redistribution Terms for Software
         ---------------------------------------------

         client IO hereby grants to you the worldwide, non exclusive, perpetual right 
         under all intellectual property rights in and to the Software to 
         incorporate the Software in whole or in part in your offerings and to 
         redistribute the Software as incorporated to your customers and distributors 
         and resellers. 

         Rappid must be part of a larger system. You may not expose the Rappid API for
         developer use in your product.


         Updates
         -------

         Free updates are provided for all versions of the Software for the period of twelve (12) months
         from the time of the license purchase. Updates are performed by downloading the updated Software package 
         through a link provided in the purchase process or sent to an email address provided in the purchase process.

         Marketing
         ---------

         client IO is permitted to reference you as a user of the Software in customer 
         lists on any of the web sites owned by client IO, in presentations to clients and at trade events.

         Limited Warranty
         ----------------

         client IO warrants that as provided the Software does not contain any malicious 
         code inserted to affect the functioning of the Software or any computer that 
         the Software runs on. Any developer using Rappid must have a broad 
         understanding of security issue relating to web application and must take all 
         reasonable steps at a system level to mitigate those risks.

         client IO warrants that the Software does not infringe any patent, copyright or 
         design secret of any third party. client IO is not aware of any facts upon which 
         such a claim for infringement could be based.


         TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, CLIENT IO AND ITS 
         SUPPLIERS DISCLAIM ALL OTHER WARRANTIES AND CONDITIONS, EITHER EXPRESSED OR 
         IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY, 
         FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT, WITH REGARD TO 
         THE SOFTWARE, AND THE PROVISION OF OR FAILURE TO PROVIDE SUPPORT SERVICES. THIS 
         LIMITED WARRANTY GIVES YOU SPECIFIC LEGAL RIGHTS. YOU MAY HAVE OTHERS, WHICH 
         VARY FROM STATE/JURISDICTION TO STATE/JURISDICTION.

         LIMITATION OF LIABILITY TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, IN 
         NO EVENT SHALL CLIENT IO OR ITS SUPPLIERS BE LIABLE FOR ANY SPECIAL, 
         INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT 
         LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS 
         OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF 
         OR INABILITY TO USE THE SOFTWARE PRODUCT OR THE PROVISION OF OR FAILURE TO 
         PROVIDE SUPPORT SERVICES, EVEN IF CLIENT IO HAS BEEN ADVISED OF THE 
         POSSIBILITY OF SUCH DAMAGES. BECAUSE SOME STATES AND JURISDICTIONS DO NOT 
         ALLOW THE EXCLUSION OR LIMITATION OF LIABILITY, THE ABOVE LIMITATION MAY NOT 
         APPLY TO YOU.


         General Provisions
         -------------------

         This License Agreement may only be modified in writing signed by you and
         client IO. If any provision of this License Agreement is found void or 
         unenforceable, the remainder will remain valid and enforceable according to its
         terms. If any remedy provided is determined to have failed for its essential
         purpose, all limitations of liability and exclusions of damages set forth in 
         the Limited Warranty shall remain in effect.

         Governing Law and Jurisdiction
         -------------------------------

         This Agreement shall be subject to and governed by the Law of The Netherlands. 
         Any dispute arising out of or in connection with this Agreement shall 
         be exclusively dealt with by the courts of The Netherlands. This License 
         Agreement gives you specific legal rights; you may have others which vary from 
         state to state and from country to country. client IO reserves all rights not 
         specifically granted in this License Agreement.

         Version 2.0 - 14.11.2013
         */

//
//    jQuery,    .
//
//
(function(window, undefined) {
        var rootjQuery, readyList, core_strundefined = typeof undefined, location = window.location, document = window.document, docElem = document.documentElement, _jQuery = window.jQuery, _$ = window.$, class2type = {}, core_deletedIds = [], core_version = "2.0.3", core_concat = core_deletedIds.concat, core_push = core_deletedIds.push, core_slice = core_deletedIds.slice, core_indexOf = core_deletedIds.indexOf, core_toString = class2type.toString, core_hasOwn = class2type.hasOwnProperty, core_trim = core_version.trim, jQuery = function(selector, context) {
            return new jQuery.fn.init(selector, context, rootjQuery)
        }, core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, core_rnotwhite = /\S+/g, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function(all, letter) {
            return letter.toUpperCase()
        }, completed = function() {
            document.removeEventListener("DOMContentLoaded", completed, false);
            window.removeEventListener("load", completed, false);
            jQuery.ready()
        };
        jQuery.fn = jQuery.prototype = {jquery: core_version,constructor: jQuery,init: function(selector, context, rootjQuery) {
            var match, elem;
            if (!selector) {
                return this
            }
            if (typeof selector === "string") {
                if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                    match = [null, selector, null]
                } else {
                    match = rquickExpr.exec(selector)
                }
                if (match && (match[1] || !context)) {
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;
                        jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            for (match in context) {
                                if (jQuery.isFunction(this[match])) {
                                    this[match](context[match])
                                } else {
                                    this.attr(match, context[match])
                                }
                            }
                        }
                        return this
                    } else {
                        elem = document.getElementById(match[2]);
                        if (elem && elem.parentNode) {
                            this.length = 1;
                            this[0] = elem
                        }
                        this.context = document;
                        this.selector = selector;
                        return this
                    }
                } else if (!context || context.jquery) {
                    return (context || rootjQuery).find(selector)
                } else {
                    return this.constructor(context).find(selector)
                }
            } else if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this
            } else if (jQuery.isFunction(selector)) {
                return rootjQuery.ready(selector)
            }
            if (selector.selector !== undefined) {
                this.selector = selector.selector;
                this.context = selector.context
            }
            return jQuery.makeArray(selector, this)
        },selector: "",length: 0,toArray: function() {
            return core_slice.call(this)
        },get: function(num) {
            return num == null ? this.toArray() : num < 0 ? this[this.length + num] : this[num]
        },pushStack: function(elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            ret.context = this.context;
            return ret
        },each: function(callback, args) {
            return jQuery.each(this, callback, args)
        },ready: function(fn) {
            jQuery.ready.promise().done(fn);
            return this
        },slice: function() {
            return this.pushStack(core_slice.apply(this, arguments))
        },first: function() {
            return this.eq(0)
        },last: function() {
            return this.eq(-1)
        },eq: function(i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : [])
        },map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem)
            }))
        },end: function() {
            return this.prevObject || this.constructor(null)
        },push: core_push,sort: [].sort,splice: [].splice};
        jQuery.fn.init.prototype = jQuery.fn;
        jQuery.extend = jQuery.fn.extend = function() {
            var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
            if (typeof target === "boolean") {
                deep = target;
                target = arguments[1] || {};
                i = 2
            }
            if (typeof target !== "object" && !jQuery.isFunction(target)) {
                target = {}
            }
            if (length === i) {
                target = this;
                --i
            }
            for (; i < length; i++) {
                if ((options = arguments[i]) != null) {
                    for (name in options) {
                        src = target[name];
                        copy = options[name];
                        if (target === copy) {
                            continue
                        }
                        if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                            if (copyIsArray) {
                                copyIsArray = false;
                                clone = src && jQuery.isArray(src) ? src : []
                            } else {
                                clone = src && jQuery.isPlainObject(src) ? src : {}
                            }
                            target[name] = jQuery.extend(deep, clone, copy)
                        } else if (copy !== undefined) {
                            target[name] = copy
                        }
                    }
                }
            }
            return target
        };
        jQuery.extend({expando: "jQuery" + (core_version + Math.random()).replace(/\D/g, ""),noConflict: function(deep) {
            if (window.$ === jQuery) {
                window.$ = _$
            }
            if (deep && window.jQuery === jQuery) {
                window.jQuery = _jQuery
            }
            return jQuery
        },isReady: false,readyWait: 1,holdReady: function(hold) {
            if (hold) {
                jQuery.readyWait++
            } else {
                jQuery.ready(true)
            }
        },ready: function(wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
                return
            }
            readyList.resolveWith(document, [jQuery]);
            if (jQuery.fn.trigger) {
                jQuery(document).trigger("ready").off("ready")
            }
        },isFunction: function(obj) {
            return jQuery.type(obj) === "function"
        },isArray: Array.isArray,isWindow: function(obj) {
            return obj != null && obj === obj.window
        },isNumeric: function(obj) {
            return !isNaN(parseFloat(obj)) && isFinite(obj)
        },type: function(obj) {
            if (obj == null) {
                return String(obj)
            }
            return typeof obj === "object" || typeof obj === "function" ? class2type[core_toString.call(obj)] || "object" : typeof obj
        },isPlainObject: function(obj) {
            if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                return false
            }
            try {
                if (obj.constructor && !core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                    return false
                }
            } catch (e) {
                return false
            }
            return true
        },isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
                return false
            }
            return true
        },error: function(msg) {
            throw new Error(msg)
        },parseHTML: function(data, context, keepScripts) {
            if (!data || typeof data !== "string") {
                return null
            }
            if (typeof context === "boolean") {
                keepScripts = context;
                context = false
            }
            context = context || document;
            var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
            if (parsed) {
                return [context.createElement(parsed[1])]
            }
            parsed = jQuery.buildFragment([data], context, scripts);
            if (scripts) {
                jQuery(scripts).remove()
            }
            return jQuery.merge([], parsed.childNodes)
        },parseJSON: JSON.parse,parseXML: function(data) {
            var xml, tmp;
            if (!data || typeof data !== "string") {
                return null
            }
            try {
                tmp = new DOMParser;
                xml = tmp.parseFromString(data, "text/xml")
            } catch (e) {
                xml = undefined
            }
            if (!xml || xml.getElementsByTagName("parsererror").length) {
                jQuery.error("Invalid XML: " + data)
            }
            return xml
        },noop: function() {
        },globalEval: function(code) {
            var script, indirect = eval;
            code = jQuery.trim(code);
            if (code) {
                if (code.indexOf("use strict") === 1) {
                    script = document.createElement("script");
                    script.text = code;
                    document.head.appendChild(script).parentNode.removeChild(script)
                } else {
                    indirect(code)
                }
            }
        },camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase)
        },nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase()
        },each: function(obj, callback, args) {
            var value, i = 0, length = obj.length, isArray = isArraylike(obj);
            if (args) {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break
                        }
                    }
                }
            } else {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break
                        }
                    }
                }
            }
            return obj
        },trim: function(text) {
            return text == null ? "" : core_trim.call(text)
        },makeArray: function(arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArraylike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === "string" ? [arr] : arr)
                } else {
                    core_push.call(ret, arr)
                }
            }
            return ret
        },inArray: function(elem, arr, i) {
            return arr == null ? -1 : core_indexOf.call(arr, elem, i)
        },merge: function(first, second) {
            var l = second.length, i = first.length, j = 0;
            if (typeof l === "number") {
                for (; j < l; j++) {
                    first[i++] = second[j]
                }
            } else {
                while (second[j] !== undefined) {
                    first[i++] = second[j++]
                }
            }
            first.length = i;
            return first
        },grep: function(elems, callback, inv) {
            var retVal, ret = [], i = 0, length = elems.length;
            inv = !!inv;
            for (; i < length; i++) {
                retVal = !!callback(elems[i], i);
                if (inv !== retVal) {
                    ret.push(elems[i])
                }
            }
            return ret
        },map: function(elems, callback, arg) {
            var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
            if (isArray) {
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret[ret.length] = value
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret[ret.length] = value
                    }
                }
            }
            return core_concat.apply([], ret)
        },guid: 1,proxy: function(fn, context) {
            var tmp, args, proxy;
            if (typeof context === "string") {
                tmp = fn[context];
                context = fn;
                fn = tmp
            }
            if (!jQuery.isFunction(fn)) {
                return undefined
            }
            args = core_slice.call(arguments, 2);
            proxy = function() {
                return fn.apply(context || this, args.concat(core_slice.call(arguments)))
            };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy
        },access: function(elems, fn, key, value, chainable, emptyGet, raw) {
            var i = 0, length = elems.length, bulk = key == null;
            if (jQuery.type(key) === "object") {
                chainable = true;
                for (i in key) {
                    jQuery.access(elems, fn, i, key[i], true, emptyGet, raw)
                }
            } else if (value !== undefined) {
                chainable = true;
                if (!jQuery.isFunction(value)) {
                    raw = true
                }
                if (bulk) {
                    if (raw) {
                        fn.call(elems, value);
                        fn = null
                    } else {
                        bulk = fn;
                        fn = function(elem, key, value) {
                            return bulk.call(jQuery(elem), value)
                        }
                    }
                }
                if (fn) {
                    for (; i < length; i++) {
                        fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)))
                    }
                }
            }
            return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet
        },now: Date.now,swap: function(elem, options, callback, args) {
            var ret, name, old = {};
            for (name in options) {
                old[name] = elem.style[name];
                elem.style[name] = options[name]
            }
            ret = callback.apply(elem, args || []);
            for (name in options) {
                elem.style[name] = old[name]
            }
            return ret
        }});
        jQuery.ready.promise = function(obj) {
            if (!readyList) {
                readyList = jQuery.Deferred();
                if (document.readyState === "complete") {
                    setTimeout(jQuery.ready)
                } else {
                    document.addEventListener("DOMContentLoaded", completed, false);
                    window.addEventListener("load", completed, false)
                }
            }
            return readyList.promise(obj)
        };
        jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase()
        });
        function isArraylike(obj) {
            var length = obj.length, type = jQuery.type(obj);
            if (jQuery.isWindow(obj)) {
                return false
            }
            if (obj.nodeType === 1 && length) {
                return true
            }
            return type === "array" || type !== "function" && (length === 0 || typeof length === "number" && length > 0 && length - 1 in obj)
        }
        rootjQuery = jQuery(document);
        (function(window, undefined) {
            var i, support, cachedruns, Expr, getText, isXML, compile, outermostContext, sortInput, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + -new Date, preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), hasDuplicate = false, sortOrder = function(a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0
                }
                return 0
            }, strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = arr.indexOf || function(elem) {
                    var i = 0, len = this.length;
                    for (; i < len; i++) {
                        if (this[i] === elem) {
                            return i
                        }
                    }
                    return -1
                }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", identifier = characterEncoding.replace("w", "w#"), attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace + "*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]", pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace(3, 8) + ")*)|.*)\\)|)", rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rsibling = new RegExp(whitespace + "*[+~]"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {ID: new RegExp("^#(" + characterEncoding + ")"),CLASS: new RegExp("^\\.(" + characterEncoding + ")"),TAG: new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),ATTR: new RegExp("^" + attributes),PSEUDO: new RegExp("^" + pseudos),CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),bool: new RegExp("^(?:" + booleans + ")$", "i"),needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")}, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rescape = /'|\\/g, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
                var high = "0x" + escaped - 65536;
                return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
            };
            try {
                push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
                arr[preferredDoc.childNodes.length].nodeType
            } catch (e) {
                push = {apply: arr.length ? function(target, els) {
                    push_native.apply(target, slice.call(els))
                } : function(target, els) {
                    var j = target.length, i = 0;
                    while (target[j++] = els[i++]) {
                    }
                    target.length = j - 1
                }}
            }
            function Sizzle(selector, context, results, seed) {
                var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
                if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                    setDocument(context)
                }
                context = context || document;
                results = results || [];
                if (!selector || typeof selector !== "string") {
                    return results
                }
                if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
                    return []
                }
                if (documentIsHTML && !seed) {
                    if (match = rquickExpr.exec(selector)) {
                        if (m = match[1]) {
                            if (nodeType === 9) {
                                elem = context.getElementById(m);
                                if (elem && elem.parentNode) {
                                    if (elem.id === m) {
                                        results.push(elem);
                                        return results
                                    }
                                } else {
                                    return results
                                }
                            } else {
                                if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                    results.push(elem);
                                    return results
                                }
                            }
                        } else if (match[2]) {
                            push.apply(results, context.getElementsByTagName(selector));
                            return results
                        } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                            push.apply(results, context.getElementsByClassName(m));
                            return results
                        }
                    }
                    if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                        nid = old = expando;
                        newContext = context;
                        newSelector = nodeType === 9 && selector;
                        if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                            groups = tokenize(selector);
                            if (old = context.getAttribute("id")) {
                                nid = old.replace(rescape, "\\$&")
                            } else {
                                context.setAttribute("id", nid)
                            }
                            nid = "[id='" + nid + "'] ";
                            i = groups.length;
                            while (i--) {
                                groups[i] = nid + toSelector(groups[i])
                            }
                            newContext = rsibling.test(selector) && context.parentNode || context;
                            newSelector = groups.join(",")
                        }
                        if (newSelector) {
                            try {
                                push.apply(results, newContext.querySelectorAll(newSelector));
                                return results
                            } catch (qsaError) {
                            }finally {
                                if (!old) {
                                    context.removeAttribute("id")
                                }
                            }
                        }
                    }
                }
                return select(selector.replace(rtrim, "$1"), context, results, seed)
            }
            function createCache() {
                var keys = [];
                function cache(key, value) {
                    if (keys.push(key += " ") > Expr.cacheLength) {
                        delete cache[keys.shift()]
                    }
                    return cache[key] = value
                }
                return cache
            }
            function markFunction(fn) {
                fn[expando] = true;
                return fn
            }
            function assert(fn) {
                var div = document.createElement("div");
                try {
                    return !!fn(div)
                } catch (e) {
                    return false
                }finally {
                    if (div.parentNode) {
                        div.parentNode.removeChild(div)
                    }
                    div = null
                }
            }
            function addHandle(attrs, handler) {
                var arr = attrs.split("|"), i = attrs.length;
                while (i--) {
                    Expr.attrHandle[arr[i]] = handler
                }
            }
            function siblingCheck(a, b) {
                var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
                if (diff) {
                    return diff
                }
                if (cur) {
                    while (cur = cur.nextSibling) {
                        if (cur === b) {
                            return -1
                        }
                    }
                }
                return a ? 1 : -1
            }
            function createInputPseudo(type) {
                return function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === type
                }
            }
            function createButtonPseudo(type) {
                return function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && elem.type === type
                }
            }
            function createPositionalPseudo(fn) {
                return markFunction(function(argument) {
                    argument = +argument;
                    return markFunction(function(seed, matches) {
                        var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                        while (i--) {
                            if (seed[j = matchIndexes[i]]) {
                                seed[j] = !(matches[j] = seed[j])
                            }
                        }
                    })
                })
            }
            isXML = Sizzle.isXML = function(elem) {
                var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                return documentElement ? documentElement.nodeName !== "HTML" : false
            };
            support = Sizzle.support = {};
            setDocument = Sizzle.setDocument = function(node) {
                var doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
                if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                    return document
                }
                document = doc;
                docElem = doc.documentElement;
                documentIsHTML = !isXML(doc);
                if (parent && parent.attachEvent && parent !== parent.top) {
                    parent.attachEvent("onbeforeunload", function() {
                        setDocument()
                    })
                }
                support.attributes = assert(function(div) {
                    div.className = "i";
                    return !div.getAttribute("className")
                });
                support.getElementsByTagName = assert(function(div) {
                    div.appendChild(doc.createComment(""));
                    return !div.getElementsByTagName("*").length
                });
                support.getElementsByClassName = assert(function(div) {
                    div.innerHTML = "<div class='a'></div><div class='a i'></div>";
                    div.firstChild.className = "i";
                    return div.getElementsByClassName("i").length === 2
                });
                support.getById = assert(function(div) {
                    docElem.appendChild(div).id = expando;
                    return !doc.getElementsByName || !doc.getElementsByName(expando).length
                });
                if (support.getById) {
                    Expr.find["ID"] = function(id, context) {
                        if (typeof context.getElementById !== strundefined && documentIsHTML) {
                            var m = context.getElementById(id);
                            return m && m.parentNode ? [m] : []
                        }
                    };
                    Expr.filter["ID"] = function(id) {
                        var attrId = id.replace(runescape, funescape);
                        return function(elem) {
                            return elem.getAttribute("id") === attrId
                        }
                    }
                } else {
                    delete Expr.find["ID"];
                    Expr.filter["ID"] = function(id) {
                        var attrId = id.replace(runescape, funescape);
                        return function(elem) {
                            var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
                            return node && node.value === attrId
                        }
                    }
                }
                Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
                    if (typeof context.getElementsByTagName !== strundefined) {
                        return context.getElementsByTagName(tag)
                    }
                } : function(tag, context) {
                    var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                    if (tag === "*") {
                        while (elem = results[i++]) {
                            if (elem.nodeType === 1) {
                                tmp.push(elem)
                            }
                        }
                        return tmp
                    }
                    return results
                };
                Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                        if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
                            return context.getElementsByClassName(className)
                        }
                    };
                rbuggyMatches = [];
                rbuggyQSA = [];
                if (support.qsa = rnative.test(doc.querySelectorAll)) {
                    assert(function(div) {
                        div.innerHTML = "<select><option selected=''></option></select>";
                        if (!div.querySelectorAll("[selected]").length) {
                            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")")
                        }
                        if (!div.querySelectorAll(":checked").length) {
                            rbuggyQSA.push(":checked")
                        }
                    });
                    assert(function(div) {
                        var input = doc.createElement("input");
                        input.setAttribute("type", "hidden");
                        div.appendChild(input).setAttribute("t", "");
                        if (div.querySelectorAll("[t^='']").length) {
                            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")")
                        }
                        if (!div.querySelectorAll(":enabled").length) {
                            rbuggyQSA.push(":enabled", ":disabled")
                        }
                        div.querySelectorAll("*,:x");
                        rbuggyQSA.push(",.*:")
                    })
                }
                if (support.matchesSelector = rnative.test(matches = docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                    assert(function(div) {
                        support.disconnectedMatch = matches.call(div, "div");
                        matches.call(div, "[s!='']:x");
                        rbuggyMatches.push("!=", pseudos)
                    })
                }
                rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
                rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
                contains = rnative.test(docElem.contains) || docElem.compareDocumentPosition ? function(a, b) {
                    var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                    return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16))
                } : function(a, b) {
                    if (b) {
                        while (b = b.parentNode) {
                            if (b === a) {
                                return true
                            }
                        }
                    }
                    return false
                };
                sortOrder = docElem.compareDocumentPosition ? function(a, b) {
                    if (a === b) {
                        hasDuplicate = true;
                        return 0
                    }
                    var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition(b);
                    if (compare) {
                        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                            if (a === doc || contains(preferredDoc, a)) {
                                return -1
                            }
                            if (b === doc || contains(preferredDoc, b)) {
                                return 1
                            }
                            return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0
                        }
                        return compare & 4 ? -1 : 1
                    }
                    return a.compareDocumentPosition ? -1 : 1
                } : function(a, b) {
                    var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                    if (a === b) {
                        hasDuplicate = true;
                        return 0
                    } else if (!aup || !bup) {
                        return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0
                    } else if (aup === bup) {
                        return siblingCheck(a, b)
                    }
                    cur = a;
                    while (cur = cur.parentNode) {
                        ap.unshift(cur)
                    }
                    cur = b;
                    while (cur = cur.parentNode) {
                        bp.unshift(cur)
                    }
                    while (ap[i] === bp[i]) {
                        i++
                    }
                    return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0
                };
                return doc
            };
            Sizzle.matches = function(expr, elements) {
                return Sizzle(expr, null, null, elements)
            };
            Sizzle.matchesSelector = function(elem, expr) {
                if ((elem.ownerDocument || elem) !== document) {
                    setDocument(elem)
                }
                expr = expr.replace(rattributeQuotes, "='$1']");
                if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                    try {
                        var ret = matches.call(elem, expr);
                        if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                            return ret
                        }
                    } catch (e) {
                    }
                }
                return Sizzle(expr, document, null, [elem]).length > 0
            };
            Sizzle.contains = function(context, elem) {
                if ((context.ownerDocument || context) !== document) {
                    setDocument(context)
                }
                return contains(context, elem)
            };
            Sizzle.attr = function(elem, name) {
                if ((elem.ownerDocument || elem) !== document) {
                    setDocument(elem)
                }
                var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
                return val === undefined ? support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null : val
            };
            Sizzle.error = function(msg) {
                throw new Error("Syntax error, unrecognized expression: " + msg)
            };
            Sizzle.uniqueSort = function(results) {
                var elem, duplicates = [], j = 0, i = 0;
                hasDuplicate = !support.detectDuplicates;
                sortInput = !support.sortStable && results.slice(0);
                results.sort(sortOrder);
                if (hasDuplicate) {
                    while (elem = results[i++]) {
                        if (elem === results[i]) {
                            j = duplicates.push(i)
                        }
                    }
                    while (j--) {
                        results.splice(duplicates[j], 1)
                    }
                }
                return results
            };
            getText = Sizzle.getText = function(elem) {
                var node, ret = "", i = 0, nodeType = elem.nodeType;
                if (!nodeType) {
                    for (; node = elem[i]; i++) {
                        ret += getText(node)
                    }
                } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                    if (typeof elem.textContent === "string") {
                        return elem.textContent
                    } else {
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            ret += getText(elem)
                        }
                    }
                } else if (nodeType === 3 || nodeType === 4) {
                    return elem.nodeValue
                }
                return ret
            };
            Expr = Sizzle.selectors = {cacheLength: 50,createPseudo: markFunction,match: matchExpr,attrHandle: {},find: {},relative: {">": {dir: "parentNode",first: true}," ": {dir: "parentNode"},"+": {dir: "previousSibling",first: true},"~": {dir: "previousSibling"}},preFilter: {ATTR: function(match) {
                match[1] = match[1].replace(runescape, funescape);
                match[3] = (match[4] || match[5] || "").replace(runescape, funescape);
                if (match[2] === "~=") {
                    match[3] = " " + match[3] + " "
                }
                return match.slice(0, 4)
            },CHILD: function(match) {
                match[1] = match[1].toLowerCase();
                if (match[1].slice(0, 3) === "nth") {
                    if (!match[3]) {
                        Sizzle.error(match[0])
                    }
                    match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                    match[5] = +(match[7] + match[8] || match[3] === "odd")
                } else if (match[3]) {
                    Sizzle.error(match[0])
                }
                return match
            },PSEUDO: function(match) {
                var excess, unquoted = !match[5] && match[2];
                if (matchExpr["CHILD"].test(match[0])) {
                    return null
                }
                if (match[3] && match[4] !== undefined) {
                    match[2] = match[4]
                } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                    match[0] = match[0].slice(0, excess);
                    match[2] = unquoted.slice(0, excess)
                }
                return match.slice(0, 3)
            }},filter: {TAG: function(nodeNameSelector) {
                var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                return nodeNameSelector === "*" ? function() {
                    return true
                } : function(elem) {
                    return elem.nodeName && elem.nodeName.toLowerCase() === nodeName
                }
            },CLASS: function(className) {
                var pattern = classCache[className + " "];
                return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "")
                    })
            },ATTR: function(name, operator, check) {
                return function(elem) {
                    var result = Sizzle.attr(elem, name);
                    if (result == null) {
                        return operator === "!="
                    }
                    if (!operator) {
                        return true
                    }
                    result += "";
                    return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false
                }
            },CHILD: function(type, what, argument, first, last) {
                var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                return first === 1 && last === 0 ? function(elem) {
                    return !!elem.parentNode
                } : function(elem, context, xml) {
                    var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                    if (parent) {
                        if (simple) {
                            while (dir) {
                                node = elem;
                                while (node = node[dir]) {
                                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                        return false
                                    }
                                }
                                start = dir = type === "only" && !start && "nextSibling"
                            }
                            return true
                        }
                        start = [forward ? parent.firstChild : parent.lastChild];
                        if (forward && useCache) {
                            outerCache = parent[expando] || (parent[expando] = {});
                            cache = outerCache[type] || [];
                            nodeIndex = cache[0] === dirruns && cache[1];
                            diff = cache[0] === dirruns && cache[2];
                            node = nodeIndex && parent.childNodes[nodeIndex];
                            while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                if (node.nodeType === 1 && ++diff && node === elem) {
                                    outerCache[type] = [dirruns, nodeIndex, diff];
                                    break
                                }
                            }
                        } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                            diff = cache[1]
                        } else {
                            while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                    if (useCache) {
                                        (node[expando] || (node[expando] = {}))[type] = [dirruns, diff]
                                    }
                                    if (node === elem) {
                                        break
                                    }
                                }
                            }
                        }
                        diff -= last;
                        return diff === first || diff % first === 0 && diff / first >= 0
                    }
                }
            },PSEUDO: function(pseudo, argument) {
                var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                if (fn[expando]) {
                    return fn(argument)
                }
                if (fn.length > 1) {
                    args = [pseudo, pseudo, "", argument];
                    return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                        var idx, matched = fn(seed, argument), i = matched.length;
                        while (i--) {
                            idx = indexOf.call(seed, matched[i]);
                            seed[idx] = !(matches[idx] = matched[i])
                        }
                    }) : function(elem) {
                        return fn(elem, 0, args)
                    }
                }
                return fn
            }},pseudos: {not: markFunction(function(selector) {
                var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                    var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                    while (i--) {
                        if (elem = unmatched[i]) {
                            seed[i] = !(matches[i] = elem)
                        }
                    }
                }) : function(elem, context, xml) {
                    input[0] = elem;
                    matcher(input, null, xml, results);
                    return !results.pop()
                }
            }),has: markFunction(function(selector) {
                return function(elem) {
                    return Sizzle(selector, elem).length > 0
                }
            }),contains: markFunction(function(text) {
                return function(elem) {
                    return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1
                }
            }),lang: markFunction(function(lang) {
                if (!ridentifier.test(lang || "")) {
                    Sizzle.error("unsupported lang: " + lang)
                }
                lang = lang.replace(runescape, funescape).toLowerCase();
                return function(elem) {
                    var elemLang;
                    do {
                        if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                            elemLang = elemLang.toLowerCase();
                            return elemLang === lang || elemLang.indexOf(lang + "-") === 0
                        }
                    } while ((elem = elem.parentNode) && elem.nodeType === 1);
                    return false
                }
            }),target: function(elem) {
                var hash = window.location && window.location.hash;
                return hash && hash.slice(1) === elem.id
            },root: function(elem) {
                return elem === docElem
            },focus: function(elem) {
                return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex)
            },enabled: function(elem) {
                return elem.disabled === false
            },disabled: function(elem) {
                return elem.disabled === true
            },checked: function(elem) {
                var nodeName = elem.nodeName.toLowerCase();
                return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected
            },selected: function(elem) {
                if (elem.parentNode) {
                    elem.parentNode.selectedIndex
                }
                return elem.selected === true
            },empty: function(elem) {
                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                    if (elem.nodeName > "@" || elem.nodeType === 3 || elem.nodeType === 4) {
                        return false
                    }
                }
                return true
            },parent: function(elem) {
                return !Expr.pseudos["empty"](elem)
            },header: function(elem) {
                return rheader.test(elem.nodeName)
            },input: function(elem) {
                return rinputs.test(elem.nodeName)
            },button: function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === "button" || name === "button"
            },text: function(elem) {
                var attr;
                return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === elem.type)
            },first: createPositionalPseudo(function() {
                return [0]
            }),last: createPositionalPseudo(function(matchIndexes, length) {
                return [length - 1]
            }),eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                return [argument < 0 ? argument + length : argument]
            }),even: createPositionalPseudo(function(matchIndexes, length) {
                var i = 0;
                for (; i < length; i += 2) {
                    matchIndexes.push(i)
                }
                return matchIndexes
            }),odd: createPositionalPseudo(function(matchIndexes, length) {
                var i = 1;
                for (; i < length; i += 2) {
                    matchIndexes.push(i)
                }
                return matchIndexes
            }),lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                var i = argument < 0 ? argument + length : argument;
                for (; --i >= 0; ) {
                    matchIndexes.push(i)
                }
                return matchIndexes
            }),gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                var i = argument < 0 ? argument + length : argument;
                for (; ++i < length; ) {
                    matchIndexes.push(i)
                }
                return matchIndexes
            })}};
            Expr.pseudos["nth"] = Expr.pseudos["eq"];
            for (i in {radio: true,checkbox: true,file: true,password: true,image: true}) {
                Expr.pseudos[i] = createInputPseudo(i)
            }
            for (i in {submit: true,reset: true}) {
                Expr.pseudos[i] = createButtonPseudo(i)
            }
            function setFilters() {
            }
            setFilters.prototype = Expr.filters = Expr.pseudos;
            Expr.setFilters = new setFilters;
            function tokenize(selector, parseOnly) {
                var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
                if (cached) {
                    return parseOnly ? 0 : cached.slice(0)
                }
                soFar = selector;
                groups = [];
                preFilters = Expr.preFilter;
                while (soFar) {
                    if (!matched || (match = rcomma.exec(soFar))) {
                        if (match) {
                            soFar = soFar.slice(match[0].length) || soFar
                        }
                        groups.push(tokens = [])
                    }
                    matched = false;
                    if (match = rcombinators.exec(soFar)) {
                        matched = match.shift();
                        tokens.push({value: matched,type: match[0].replace(rtrim, " ")});
                        soFar = soFar.slice(matched.length)
                    }
                    for (type in Expr.filter) {
                        if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                            matched = match.shift();
                            tokens.push({value: matched,type: type,matches: match});
                            soFar = soFar.slice(matched.length)
                        }
                    }
                    if (!matched) {
                        break
                    }
                }
                return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0)
            }
            function toSelector(tokens) {
                var i = 0, len = tokens.length, selector = "";
                for (; i < len; i++) {
                    selector += tokens[i].value
                }
                return selector
            }
            function addCombinator(matcher, combinator, base) {
                var dir = combinator.dir, checkNonElements = base && dir === "parentNode", doneName = done++;
                return combinator.first ? function(elem, context, xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            return matcher(elem, context, xml)
                        }
                    }
                } : function(elem, context, xml) {
                    var data, cache, outerCache, dirkey = dirruns + " " + doneName;
                    if (xml) {
                        while (elem = elem[dir]) {
                            if (elem.nodeType === 1 || checkNonElements) {
                                if (matcher(elem, context, xml)) {
                                    return true
                                }
                            }
                        }
                    } else {
                        while (elem = elem[dir]) {
                            if (elem.nodeType === 1 || checkNonElements) {
                                outerCache = elem[expando] || (elem[expando] = {});
                                if ((cache = outerCache[dir]) && cache[0] === dirkey) {
                                    if ((data = cache[1]) === true || data === cachedruns) {
                                        return data === true
                                    }
                                } else {
                                    cache = outerCache[dir] = [dirkey];
                                    cache[1] = matcher(elem, context, xml) || cachedruns;
                                    if (cache[1] === true) {
                                        return true
                                    }
                                }
                            }
                        }
                    }
                }
            }
            function elementMatcher(matchers) {
                return matchers.length > 1 ? function(elem, context, xml) {
                    var i = matchers.length;
                    while (i--) {
                        if (!matchers[i](elem, context, xml)) {
                            return false
                        }
                    }
                    return true
                } : matchers[0]
            }
            function condense(unmatched, map, filter, context, xml) {
                var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
                for (; i < len; i++) {
                    if (elem = unmatched[i]) {
                        if (!filter || filter(elem, context, xml)) {
                            newUnmatched.push(elem);
                            if (mapped) {
                                map.push(i)
                            }
                        }
                    }
                }
                return newUnmatched
            }
            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                if (postFilter && !postFilter[expando]) {
                    postFilter = setMatcher(postFilter)
                }
                if (postFinder && !postFinder[expando]) {
                    postFinder = setMatcher(postFinder, postSelector)
                }
                return markFunction(function(seed, results, context, xml) {
                    var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                    if (matcher) {
                        matcher(matcherIn, matcherOut, context, xml)
                    }
                    if (postFilter) {
                        temp = condense(matcherOut, postMap);
                        postFilter(temp, [], context, xml);
                        i = temp.length;
                        while (i--) {
                            if (elem = temp[i]) {
                                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem)
                            }
                        }
                    }
                    if (seed) {
                        if (postFinder || preFilter) {
                            if (postFinder) {
                                temp = [];
                                i = matcherOut.length;
                                while (i--) {
                                    if (elem = matcherOut[i]) {
                                        temp.push(matcherIn[i] = elem)
                                    }
                                }
                                postFinder(null, matcherOut = [], temp, xml)
                            }
                            i = matcherOut.length;
                            while (i--) {
                                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                                    seed[temp] = !(results[temp] = elem)
                                }
                            }
                        }
                    } else {
                        matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                        if (postFinder) {
                            postFinder(null, results, matcherOut, xml)
                        } else {
                            push.apply(results, matcherOut)
                        }
                    }
                })
            }
            function matcherFromTokens(tokens) {
                var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                    return elem === checkContext
                }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                    return indexOf.call(checkContext, elem) > -1
                }, implicitRelative, true), matchers = [function(elem, context, xml) {
                    return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml))
                }];
                for (; i < len; i++) {
                    if (matcher = Expr.relative[tokens[i].type]) {
                        matchers = [addCombinator(elementMatcher(matchers), matcher)]
                    } else {
                        matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                        if (matcher[expando]) {
                            j = ++i;
                            for (; j < len; j++) {
                                if (Expr.relative[tokens[j].type]) {
                                    break
                                }
                            }
                            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens))
                        }
                        matchers.push(matcher)
                    }
                }
                return elementMatcher(matchers)
            }
            function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                var matcherCachedRuns = 0, bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, expandContext) {
                    var elem, j, matcher, setMatched = [], matchedCount = 0, i = "0", unmatched = seed && [], outermost = expandContext != null, contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", expandContext && context.parentNode || context), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || .1;
                    if (outermost) {
                        outermostContext = context !== document && context;
                        cachedruns = matcherCachedRuns
                    }
                    for (; (elem = elems[i]) != null; i++) {
                        if (byElement && elem) {
                            j = 0;
                            while (matcher = elementMatchers[j++]) {
                                if (matcher(elem, context, xml)) {
                                    results.push(elem);
                                    break
                                }
                            }
                            if (outermost) {
                                dirruns = dirrunsUnique;
                                cachedruns = ++matcherCachedRuns
                            }
                        }
                        if (bySet) {
                            if (elem = !matcher && elem) {
                                matchedCount--
                            }
                            if (seed) {
                                unmatched.push(elem)
                            }
                        }
                    }
                    matchedCount += i;
                    if (bySet && i !== matchedCount) {
                        j = 0;
                        while (matcher = setMatchers[j++]) {
                            matcher(unmatched, setMatched, context, xml)
                        }
                        if (seed) {
                            if (matchedCount > 0) {
                                while (i--) {
                                    if (!(unmatched[i] || setMatched[i])) {
                                        setMatched[i] = pop.call(results)
                                    }
                                }
                            }
                            setMatched = condense(setMatched)
                        }
                        push.apply(results, setMatched);
                        if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                            Sizzle.uniqueSort(results)
                        }
                    }
                    if (outermost) {
                        dirruns = dirrunsUnique;
                        outermostContext = contextBackup
                    }
                    return unmatched
                };
                return bySet ? markFunction(superMatcher) : superMatcher
            }
            compile = Sizzle.compile = function(selector, group) {
                var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
                if (!cached) {
                    if (!group) {
                        group = tokenize(selector)
                    }
                    i = group.length;
                    while (i--) {
                        cached = matcherFromTokens(group[i]);
                        if (cached[expando]) {
                            setMatchers.push(cached)
                        } else {
                            elementMatchers.push(cached)
                        }
                    }
                    cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers))
                }
                return cached
            };
            function multipleContexts(selector, contexts, results) {
                var i = 0, len = contexts.length;
                for (; i < len; i++) {
                    Sizzle(selector, contexts[i], results)
                }
                return results
            }
            function select(selector, context, results, seed) {
                var i, tokens, token, type, find, match = tokenize(selector);
                if (!seed) {
                    if (match.length === 1) {
                        tokens = match[0] = match[0].slice(0);
                        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                            context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                            if (!context) {
                                return results
                            }
                            selector = selector.slice(tokens.shift().value.length)
                        }
                        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                        while (i--) {
                            token = tokens[i];
                            if (Expr.relative[type = token.type]) {
                                break
                            }
                            if (find = Expr.find[type]) {
                                if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && context.parentNode || context)) {
                                    tokens.splice(i, 1);
                                    selector = seed.length && toSelector(tokens);
                                    if (!selector) {
                                        push.apply(results, seed);
                                        return results
                                    }
                                    break
                                }
                            }
                        }
                    }
                }
                compile(selector, match)(seed, context, !documentIsHTML, results, rsibling.test(selector));
                return results
            }
            support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
            support.detectDuplicates = hasDuplicate;
            setDocument();
            support.sortDetached = assert(function(div1) {
                return div1.compareDocumentPosition(document.createElement("div")) & 1
            });
            if (!assert(function(div) {
                    div.innerHTML = "<a href='#'></a>";
                    return div.firstChild.getAttribute("href") === "#"
                })) {
                addHandle("type|href|height|width", function(elem, name, isXML) {
                    if (!isXML) {
                        return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2)
                    }
                })
            }
            if (!support.attributes || !assert(function(div) {
                    div.innerHTML = "<input/>";
                    div.firstChild.setAttribute("value", "");
                    return div.firstChild.getAttribute("value") === ""
                })) {
                addHandle("value", function(elem, name, isXML) {
                    if (!isXML && elem.nodeName.toLowerCase() === "input") {
                        return elem.defaultValue
                    }
                })
            }
            if (!assert(function(div) {
                    return div.getAttribute("disabled") == null
                })) {
                addHandle(booleans, function(elem, name, isXML) {
                    var val;
                    if (!isXML) {
                        return (val = elem.getAttributeNode(name)) && val.specified ? val.value : elem[name] === true ? name.toLowerCase() : null
                    }
                })
            }
            jQuery.find = Sizzle;
            jQuery.expr = Sizzle.selectors;
            jQuery.expr[":"] = jQuery.expr.pseudos;
            jQuery.unique = Sizzle.uniqueSort;
            jQuery.text = Sizzle.getText;
            jQuery.isXMLDoc = Sizzle.isXML;
            jQuery.contains = Sizzle.contains
        })(window);
        var optionsCache = {};
        function createOptions(options) {
            var object = optionsCache[options] = {};
            jQuery.each(options.match(core_rnotwhite) || [], function(_, flag) {
                object[flag] = true
            });
            return object
        }
        jQuery.Callbacks = function(options) {
            options = typeof options === "string" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
            var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [], fire = function(data) {
                memory = options.memory && data;
                fired = true;
                firingIndex = firingStart || 0;
                firingStart = 0;
                firingLength = list.length;
                firing = true;
                for (; list && firingIndex < firingLength; firingIndex++) {
                    if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                        memory = false;
                        break
                    }
                }
                firing = false;
                if (list) {
                    if (stack) {
                        if (stack.length) {
                            fire(stack.shift())
                        }
                    } else if (memory) {
                        list = []
                    } else {
                        self.disable()
                    }
                }
            }, self = {add: function() {
                if (list) {
                    var start = list.length;
                    (function add(args) {
                        jQuery.each(args, function(_, arg) {
                            var type = jQuery.type(arg);
                            if (type === "function") {
                                if (!options.unique || !self.has(arg)) {
                                    list.push(arg)
                                }
                            } else if (arg && arg.length && type !== "string") {
                                add(arg)
                            }
                        })
                    })(arguments);
                    if (firing) {
                        firingLength = list.length
                    } else if (memory) {
                        firingStart = start;
                        fire(memory)
                    }
                }
                return this
            },remove: function() {
                if (list) {
                    jQuery.each(arguments, function(_, arg) {
                        var index;
                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
                            list.splice(index, 1);
                            if (firing) {
                                if (index <= firingLength) {
                                    firingLength--
                                }
                                if (index <= firingIndex) {
                                    firingIndex--
                                }
                            }
                        }
                    })
                }
                return this
            },has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length)
            },empty: function() {
                list = [];
                firingLength = 0;
                return this
            },disable: function() {
                list = stack = memory = undefined;
                return this
            },disabled: function() {
                return !list
            },lock: function() {
                stack = undefined;
                if (!memory) {
                    self.disable()
                }
                return this
            },locked: function() {
                return !stack
            },fireWith: function(context, args) {
                if (list && (!fired || stack)) {
                    args = args || [];
                    args = [context, args.slice ? args.slice() : args];
                    if (firing) {
                        stack.push(args)
                    } else {
                        fire(args)
                    }
                }
                return this
            },fire: function() {
                self.fireWith(this, arguments);
                return this
            },fired: function() {
                return !!fired
            }};
            return self
        };
        jQuery.extend({Deferred: function(func) {
            var tuples = [["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]], state = "pending", promise = {state: function() {
                return state
            },always: function() {
                deferred.done(arguments).fail(arguments);
                return this
            },then: function() {
                var fns = arguments;
                return jQuery.Deferred(function(newDefer) {
                    jQuery.each(tuples, function(i, tuple) {
                        var action = tuple[0], fn = jQuery.isFunction(fns[i]) && fns[i];
                        deferred[tuple[1]](function() {
                            var returned = fn && fn.apply(this, arguments);
                            if (returned && jQuery.isFunction(returned.promise)) {
                                returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify)
                            } else {
                                newDefer[action + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments)
                            }
                        })
                    });
                    fns = null
                }).promise()
            },promise: function(obj) {
                return obj != null ? jQuery.extend(obj, promise) : promise
            }}, deferred = {};
            promise.pipe = promise.then;
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[3];
                promise[tuple[1]] = list.add;
                if (stateString) {
                    list.add(function() {
                        state = stateString
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock)
                }
                deferred[tuple[0]] = function() {
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                    return this
                };
                deferred[tuple[0] + "With"] = list.fireWith
            });
            promise.promise(deferred);
            if (func) {
                func.call(deferred, deferred)
            }
            return deferred
        },when: function(subordinate) {
            var i = 0, resolveValues = core_slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function(i, contexts, values) {
                return function(value) {
                    contexts[i] = this;
                    values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;
                    if (values === progressValues) {
                        deferred.notifyWith(contexts, values)
                    } else if (!--remaining) {
                        deferred.resolveWith(contexts, values)
                    }
                }
            }, progressValues, progressContexts, resolveContexts;
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (; i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues))
                    } else {
                        --remaining
                    }
                }
            }
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues)
            }
            return deferred.promise()
        }});
        jQuery.support = function(support) {
            var input = document.createElement("input"), fragment = document.createDocumentFragment(), div = document.createElement("div"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
            if (!input.type) {
                return support
            }
            input.type = "checkbox";
            support.checkOn = input.value !== "";
            support.optSelected = opt.selected;
            support.reliableMarginRight = true;
            support.boxSizingReliable = true;
            support.pixelPosition = false;
            input.checked = true;
            support.noCloneChecked = input.cloneNode(true).checked;
            select.disabled = true;
            support.optDisabled = !opt.disabled;
            input = document.createElement("input");
            input.value = "t";
            input.type = "radio";
            support.radioValue = input.value === "t";
            input.setAttribute("checked", "t");
            input.setAttribute("name", "t");
            fragment.appendChild(input);
            support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;
            support.focusinBubbles = "onfocusin" in window;
            div.style.backgroundClip = "content-box";
            div.cloneNode(true).style.backgroundClip = "";
            support.clearCloneStyle = div.style.backgroundClip === "content-box";
            jQuery(function() {
                var container, marginDiv, divReset = "padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box", body = document.getElementsByTagName("body")[0];
                if (!body) {
                    return
                }
                container = document.createElement("div");
                container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";
                body.appendChild(container).appendChild(div);
                div.innerHTML = "";
                div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%";
                jQuery.swap(body, body.style.zoom != null ? {zoom: 1} : {}, function() {
                    support.boxSizing = div.offsetWidth === 4
                });
                if (window.getComputedStyle) {
                    support.pixelPosition = (window.getComputedStyle(div, null) || {}).top !== "1%";
                    support.boxSizingReliable = (window.getComputedStyle(div, null) || {width: "4px"}).width === "4px";
                    marginDiv = div.appendChild(document.createElement("div"));
                    marginDiv.style.cssText = div.style.cssText = divReset;
                    marginDiv.style.marginRight = marginDiv.style.width = "0";
                    div.style.width = "1px";
                    support.reliableMarginRight = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight)
                }
                body.removeChild(container)
            });
            return support
        }({});
        var data_user, data_priv, rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/, rmultiDash = /([A-Z])/g;
        function Data() {
            Object.defineProperty(this.cache = {}, 0, {get: function() {
                return {}
            }});
            this.expando = jQuery.expando + Math.random()
        }
        Data.uid = 1;
        Data.accepts = function(owner) {
            return owner.nodeType ? owner.nodeType === 1 || owner.nodeType === 9 : true
        };
        Data.prototype = {key: function(owner) {
            if (!Data.accepts(owner)) {
                return 0
            }
            var descriptor = {}, unlock = owner[this.expando];
            if (!unlock) {
                unlock = Data.uid++;
                try {
                    descriptor[this.expando] = {value: unlock};
                    Object.defineProperties(owner, descriptor)
                } catch (e) {
                    descriptor[this.expando] = unlock;
                    jQuery.extend(owner, descriptor)
                }
            }
            if (!this.cache[unlock]) {
                this.cache[unlock] = {}
            }
            return unlock
        },set: function(owner, data, value) {
            var prop, unlock = this.key(owner), cache = this.cache[unlock];
            if (typeof data === "string") {
                cache[data] = value
            } else {
                if (jQuery.isEmptyObject(cache)) {
                    jQuery.extend(this.cache[unlock], data)
                } else {
                    for (prop in data) {
                        cache[prop] = data[prop]
                    }
                }
            }
            return cache
        },get: function(owner, key) {
            var cache = this.cache[this.key(owner)];
            return key === undefined ? cache : cache[key]
        },access: function(owner, key, value) {
            var stored;
            if (key === undefined || key && typeof key === "string" && value === undefined) {
                stored = this.get(owner, key);
                return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key))
            }
            this.set(owner, key, value);
            return value !== undefined ? value : key
        },remove: function(owner, key) {
            var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
            if (key === undefined) {
                this.cache[unlock] = {}
            } else {
                if (jQuery.isArray(key)) {
                    name = key.concat(key.map(jQuery.camelCase))
                } else {
                    camel = jQuery.camelCase(key);
                    if (key in cache) {
                        name = [key, camel]
                    } else {
                        name = camel;
                        name = name in cache ? [name] : name.match(core_rnotwhite) || []
                    }
                }
                i = name.length;
                while (i--) {
                    delete cache[name[i]]
                }
            }
        },hasData: function(owner) {
            return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {})
        },discard: function(owner) {
            if (owner[this.expando]) {
                delete this.cache[owner[this.expando]]
            }
        }};
        data_user = new Data;
        data_priv = new Data;
        jQuery.extend({acceptData: Data.accepts,hasData: function(elem) {
            return data_user.hasData(elem) || data_priv.hasData(elem)
        },data: function(elem, name, data) {
            return data_user.access(elem, name, data)
        },removeData: function(elem, name) {
            data_user.remove(elem, name)
        },_data: function(elem, name, data) {
            return data_priv.access(elem, name, data)
        },_removeData: function(elem, name) {
            data_priv.remove(elem, name)
        }});
        jQuery.fn.extend({data: function(key, value) {
            var attrs, name, elem = this[0], i = 0, data = null;
            if (key === undefined) {
                if (this.length) {
                    data = data_user.get(elem);
                    if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
                        attrs = elem.attributes;
                        for (; i < attrs.length; i++) {
                            name = attrs[i].name;
                            if (name.indexOf("data-") === 0) {
                                name = jQuery.camelCase(name.slice(5));
                                dataAttr(elem, name, data[name])
                            }
                        }
                        data_priv.set(elem, "hasDataAttrs", true)
                    }
                }
                return data
            }
            if (typeof key === "object") {
                return this.each(function() {
                    data_user.set(this, key)
                })
            }
            return jQuery.access(this, function(value) {
                var data, camelKey = jQuery.camelCase(key);
                if (elem && value === undefined) {
                    data = data_user.get(elem, key);
                    if (data !== undefined) {
                        return data
                    }
                    data = data_user.get(elem, camelKey);
                    if (data !== undefined) {
                        return data
                    }
                    data = dataAttr(elem, camelKey, undefined);
                    if (data !== undefined) {
                        return data
                    }
                    return
                }
                this.each(function() {
                    var data = data_user.get(this, camelKey);
                    data_user.set(this, camelKey, value);
                    if (key.indexOf("-") !== -1 && data !== undefined) {
                        data_user.set(this, key, value)
                    }
                })
            }, null, value, arguments.length > 1, null, true)
        },removeData: function(key) {
            return this.each(function() {
                data_user.remove(this, key)
            })
        }});
        function dataAttr(elem, key, data) {
            var name;
            if (data === undefined && elem.nodeType === 1) {
                name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
                data = elem.getAttribute(name);
                if (typeof data === "string") {
                    try {
                        data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? JSON.parse(data) : data
                    } catch (e) {
                    }
                    data_user.set(elem, key, data)
                } else {
                    data = undefined
                }
            }
            return data
        }
        jQuery.extend({queue: function(elem, type, data) {
            var queue;
            if (elem) {
                type = (type || "fx") + "queue";
                queue = data_priv.get(elem, type);
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = data_priv.access(elem, type, jQuery.makeArray(data))
                    } else {
                        queue.push(data)
                    }
                }
                return queue || []
            }
        },dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type)
            };
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--
            }
            if (fn) {
                if (type === "fx") {
                    queue.unshift("inprogress")
                }
                delete hooks.stop;
                fn.call(elem, next, hooks)
            }
            if (!startLength && hooks) {
                hooks.empty.fire()
            }
        },_queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return data_priv.get(elem, key) || data_priv.access(elem, key, {empty: jQuery.Callbacks("once memory").add(function() {
                    data_priv.remove(elem, [type + "queue", key])
                })})
        }});
        jQuery.fn.extend({queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type)
            }
            return data === undefined ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type)
                }
            })
        },dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type)
            })
        },delay: function(time, type) {
            time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
            type = type || "fx";
            return this.queue(type, function(next, hooks) {
                var timeout = setTimeout(next, time);
                hooks.stop = function() {
                    clearTimeout(timeout)
                }
            })
        },clearQueue: function(type) {
            return this.queue(type || "fx", [])
        },promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                if (!--count) {
                    defer.resolveWith(elements, [elements])
                }
            };
            if (typeof type !== "string") {
                obj = type;
                type = undefined
            }
            type = type || "fx";
            while (i--) {
                tmp = data_priv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve)
                }
            }
            resolve();
            return defer.promise(obj)
        }});
        var nodeHook, boolHook, rclass = /[\t\r\n\f]/g, rreturn = /\r/g, rfocusable = /^(?:input|select|textarea|button)$/i;
        jQuery.fn.extend({attr: function(name, value) {
            return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1)
        },removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name)
            })
        },prop: function(name, value) {
            return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1)
        },removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name]
            })
        },addClass: function(value) {
            var classes, elem, cur, clazz, j, i = 0, len = this.length, proceed = typeof value === "string" && value;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).addClass(value.call(this, j, this.className))
                })
            }
            if (proceed) {
                classes = (value || "").match(core_rnotwhite) || [];
                for (; i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(" " + clazz + " ") < 0) {
                                cur += clazz + " "
                            }
                        }
                        elem.className = jQuery.trim(cur)
                    }
                }
            }
            return this
        },removeClass: function(value) {
            var classes, elem, cur, clazz, j, i = 0, len = this.length, proceed = arguments.length === 0 || typeof value === "string" && value;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).removeClass(value.call(this, j, this.className))
                })
            }
            if (proceed) {
                classes = (value || "").match(core_rnotwhite) || [];
                for (; i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            while (cur.indexOf(" " + clazz + " ") >= 0) {
                                cur = cur.replace(" " + clazz + " ", " ")
                            }
                        }
                        elem.className = value ? jQuery.trim(cur) : ""
                    }
                }
            }
            return this
        },toggleClass: function(value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === "boolean" && type === "string") {
                return stateVal ? this.addClass(value) : this.removeClass(value)
            }
            if (jQuery.isFunction(value)) {
                return this.each(function(i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal)
                })
            }
            return this.each(function() {
                if (type === "string") {
                    var className, i = 0, self = jQuery(this), classNames = value.match(core_rnotwhite) || [];
                    while (className = classNames[i++]) {
                        if (self.hasClass(className)) {
                            self.removeClass(className)
                        } else {
                            self.addClass(className)
                        }
                    }
                } else if (type === core_strundefined || type === "boolean") {
                    if (this.className) {
                        data_priv.set(this, "__className__", this.className)
                    }
                    this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || ""
                }
            })
        },hasClass: function(selector) {
            var className = " " + selector + " ", i = 0, l = this.length;
            for (; i < l; i++) {
                if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
                    return true
                }
            }
            return false
        },val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret
                    }
                    ret = elem.value;
                    return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret
                }
                return
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function(i) {
                var val;
                if (this.nodeType !== 1) {
                    return
                }
                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val())
                } else {
                    val = value
                }
                if (val == null) {
                    val = ""
                } else if (typeof val === "number") {
                    val += ""
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function(value) {
                        return value == null ? "" : value + ""
                    })
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val
                }
            })
        }});
        jQuery.extend({valHooks: {option: {get: function(elem) {
            var val = elem.attributes.value;
            return !val || val.specified ? elem.value : elem.text
        }},select: {get: function(elem) {
            var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one" || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
            for (; i < max; i++) {
                option = options[i];
                if ((option.selected || i === index) && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                    value = jQuery(option).val();
                    if (one) {
                        return value
                    }
                    values.push(value)
                }
            }
            return values
        },set: function(elem, value) {
            var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
            while (i--) {
                option = options[i];
                if (option.selected = jQuery.inArray(jQuery(option).val(), values) >= 0) {
                    optionSet = true
                }
            }
            if (!optionSet) {
                elem.selectedIndex = -1
            }
            return values
        }}},attr: function(elem, name, value) {
            var hooks, ret, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return
            }
            if (typeof elem.getAttribute === core_strundefined) {
                return jQuery.prop(elem, name, value)
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook)
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name)
                } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret
                } else {
                    elem.setAttribute(name, value + "");
                    return value
                }
            } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret
            } else {
                ret = jQuery.find.attr(elem, name);
                return ret == null ? undefined : ret
            }
        },removeAttr: function(elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(core_rnotwhite);
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    propName = jQuery.propFix[name] || name;
                    if (jQuery.expr.match.bool.test(name)) {
                        elem[propName] = false
                    }
                    elem.removeAttribute(name)
                }
            }
        },attrHooks: {type: {set: function(elem, value) {
            if (!jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                var val = elem.value;
                elem.setAttribute("type", value);
                if (val) {
                    elem.value = val
                }
                return value
            }
        }}},propFix: {"for": "htmlFor","class": "className"},prop: function(elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return
            }
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
            if (notxml) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name]
            }
            if (value !== undefined) {
                return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value
            } else {
                return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name]
            }
        },propHooks: {tabIndex: {get: function(elem) {
            return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1
        }}}});
        boolHook = {set: function(elem, value, name) {
            if (value === false) {
                jQuery.removeAttr(elem, name)
            } else {
                elem.setAttribute(name, name)
            }
            return name
        }};
        jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
            var getter = jQuery.expr.attrHandle[name] || jQuery.find.attr;
            jQuery.expr.attrHandle[name] = function(elem, name, isXML) {
                var fn = jQuery.expr.attrHandle[name], ret = isXML ? undefined : (jQuery.expr.attrHandle[name] = undefined) != getter(elem, name, isXML) ? name.toLowerCase() : null;
                jQuery.expr.attrHandle[name] = fn;
                return ret
            }
        });
        if (!jQuery.support.optSelected) {
            jQuery.propHooks.selected = {get: function(elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex
                }
                return null
            }}
        }
        jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
            jQuery.propFix[this.toLowerCase()] = this
        });
        jQuery.each(["radio", "checkbox"], function() {
            jQuery.valHooks[this] = {set: function(elem, value) {
                if (jQuery.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0
                }
            }};
            if (!jQuery.support.checkOn) {
                jQuery.valHooks[this].get = function(elem) {
                    return elem.getAttribute("value") === null ? "on" : elem.value
                }
            }
        });
        var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
        function returnTrue() {
            return true
        }
        function returnFalse() {
            return false
        }
        function safeActiveElement() {
            try {
                return document.activeElement
            } catch (err) {
            }
        }
        jQuery.event = {global: {},add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
            if (!elemData) {
                return
            }
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++
            }
            if (!(events = elemData.events)) {
                events = elemData.events = {}
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function(e) {
                    return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined
                };
                eventHandle.elem = elem
            }
            types = (types || "").match(core_rnotwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                    continue
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({type: type,origType: origType,data: data,handler: handler,guid: handler.guid,selector: selector,needsContext: selector && jQuery.expr.match.needsContext.test(selector),namespace: namespaces.join(".")}, handleObjIn);
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false)
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj)
                } else {
                    handlers.push(handleObj)
                }
                jQuery.event.global[type] = true
            }
            elem = null
        },remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
            if (!elemData || !(events = elemData.events)) {
                return
            }
            types = (types || "").match(core_rnotwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true)
                    }
                    continue
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj)
                        }
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle)
                    }
                    delete events[type]
                }
            }
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle;
                data_priv.remove(elem, "events")
            }
        },trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = core_hasOwn.call(event, "type") ? event.type : event, namespaces = core_hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = tmp = elem = elem || document;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return
            }
            if (type.indexOf(".") >= 0) {
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort()
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = undefined;
            if (!event.target) {
                event.target = elem
            }
            data = data == null ? [event] : jQuery.makeArray(data, [event]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return
            }
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur
                }
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window)
                }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
                if (handle) {
                    handle.apply(cur, data)
                }
                handle = ontype && cur[ontype];
                if (handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {
                    event.preventDefault()
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null
                        }
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp
                        }
                    }
                }
            }
            return event.result
        },dispatch: function(event) {
            event = jQuery.event.fix(event);
            var i, j, ret, matched, handleObj, handlerQueue = [], args = core_slice.call(arguments), handlers = (data_priv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation()
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event)
            }
            return event.result
        },handlers: function(event, handlers) {
            var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {
                for (; cur !== this; cur = cur.parentNode || this) {
                    if (cur.disabled !== true || event.type !== "click") {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector + " ";
                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length
                            }
                            if (matches[sel]) {
                                matches.push(handleObj)
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({elem: cur,handlers: matches})
                        }
                    }
                }
            }
            if (delegateCount < handlers.length) {
                handlerQueue.push({elem: this,handlers: handlers.slice(delegateCount)})
            }
            return handlerQueue
        },props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks: {},keyHooks: {props: "char charCode key keyCode".split(" "),filter: function(event, original) {
            if (event.which == null) {
                event.which = original.charCode != null ? original.charCode : original.keyCode
            }
            return event
        }},mouseHooks: {props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter: function(event, original) {
            var eventDoc, doc, body, button = original.button;
            if (event.pageX == null && original.clientX != null) {
                eventDoc = event.target.ownerDocument || document;
                doc = eventDoc.documentElement;
                body = eventDoc.body;
                event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0)
            }
            if (!event.which && button !== undefined) {
                event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0
            }
            return event
        }},fix: function(event) {
            if (event[jQuery.expando]) {
                return event
            }
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {}
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = new jQuery.Event(originalEvent);
            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop]
            }
            if (!event.target) {
                event.target = document
            }
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode
            }
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event
        },special: {load: {noBubble: true},focus: {trigger: function() {
            if (this !== safeActiveElement() && this.focus) {
                this.focus();
                return false
            }
        },delegateType: "focusin"},blur: {trigger: function() {
            if (this === safeActiveElement() && this.blur) {
                this.blur();
                return false
            }
        },delegateType: "focusout"},click: {trigger: function() {
            if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                this.click();
                return false
            }
        },_default: function(event) {
            return jQuery.nodeName(event.target, "a")
        }},beforeunload: {postDispatch: function(event) {
            if (event.result !== undefined) {
                event.originalEvent.returnValue = event.result
            }
        }}},simulate: function(type, elem, event, bubble) {
            var e = jQuery.extend(new jQuery.Event, event, {type: type,isSimulated: true,originalEvent: {}});
            if (bubble) {
                jQuery.event.trigger(e, null, elem)
            } else {
                jQuery.event.dispatch.call(elem, e)
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault()
            }
        }};
        jQuery.removeEvent = function(elem, type, handle) {
            if (elem.removeEventListener) {
                elem.removeEventListener(type, handle, false)
            }
        };
        jQuery.Event = function(src, props) {
            if (!(this instanceof jQuery.Event)) {
                return new jQuery.Event(src, props)
            }
            if (src && src.type) {
                this.originalEvent = src;
                this.type = src.type;
                this.isDefaultPrevented = src.defaultPrevented || src.getPreventDefault && src.getPreventDefault() ? returnTrue : returnFalse
            } else {
                this.type = src
            }
            if (props) {
                jQuery.extend(this, props)
            }
            this.timeStamp = src && src.timeStamp || jQuery.now();
            this[jQuery.expando] = true
        };
        jQuery.Event.prototype = {isDefaultPrevented: returnFalse,isPropagationStopped: returnFalse,isImmediatePropagationStopped: returnFalse,preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && e.preventDefault) {
                e.preventDefault()
            }
        },stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && e.stopPropagation) {
                e.stopPropagation()
            }
        },stopImmediatePropagation: function() {
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation()
        }};
        jQuery.each({mouseenter: "mouseover",mouseleave: "mouseout"}, function(orig, fix) {
            jQuery.event.special[orig] = {delegateType: fix,bindType: fix,handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix
                }
                return ret
            }}
        });
        if (!jQuery.support.focusinBubbles) {
            jQuery.each({focus: "focusin",blur: "focusout"}, function(orig, fix) {
                var attaches = 0, handler = function(event) {
                    jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true)
                };
                jQuery.event.special[fix] = {setup: function() {
                    if (attaches++ === 0) {
                        document.addEventListener(orig, handler, true)
                    }
                },teardown: function() {
                    if (--attaches === 0) {
                        document.removeEventListener(orig, handler, true)
                    }
                }}
            })
        }
        jQuery.fn.extend({on: function(types, selector, data, fn, one) {
            var origFn, type;
            if (typeof types === "object") {
                if (typeof selector !== "string") {
                    data = data || selector;
                    selector = undefined
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one)
                }
                return this
            }
            if (data == null && fn == null) {
                fn = selector;
                data = selector = undefined
            } else if (fn == null) {
                if (typeof selector === "string") {
                    fn = data;
                    data = undefined
                } else {
                    fn = data;
                    data = selector;
                    selector = undefined
                }
            }
            if (fn === false) {
                fn = returnFalse
            } else if (!fn) {
                return this
            }
            if (one === 1) {
                origFn = fn;
                fn = function(event) {
                    jQuery().off(event);
                    return origFn.apply(this, arguments)
                };
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)
            }
            return this.each(function() {
                jQuery.event.add(this, types, fn, data, selector)
            })
        },one: function(types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1)
        },off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this
            }
            if (typeof types === "object") {
                for (type in types) {
                    this.off(type, selector, types[type])
                }
                return this
            }
            if (selector === false || typeof selector === "function") {
                fn = selector;
                selector = undefined
            }
            if (fn === false) {
                fn = returnFalse
            }
            return this.each(function() {
                jQuery.event.remove(this, types, fn, selector)
            })
        },trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this)
            })
        },triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true)
            }
        }});
        var isSimple = /^.[^:#\[\.,]*$/, rparentsprev = /^(?:parents|prev(?:Until|All))/, rneedsContext = jQuery.expr.match.needsContext, guaranteedUnique = {children: true,contents: true,next: true,prev: true};
        jQuery.fn.extend({find: function(selector) {
            var i, ret = [], self = this, len = self.length;
            if (typeof selector !== "string") {
                return this.pushStack(jQuery(selector).filter(function() {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true
                        }
                    }
                }))
            }
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret)
            }
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + " " + selector : selector;
            return ret
        },has: function(target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function() {
                var i = 0;
                for (; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true
                    }
                }
            })
        },not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true))
        },filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false))
        },is: function(selector) {
            return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length
        },closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
            for (; i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                        cur = matched.push(cur);
                        break
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched)
        },index: function(elem) {
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1
            }
            if (typeof elem === "string") {
                return core_indexOf.call(jQuery(elem), this[0])
            }
            return core_indexOf.call(this, elem.jquery ? elem[0] : elem)
        },add: function(selector, context) {
            var set = typeof selector === "string" ? jQuery(selector, context) : jQuery.makeArray(selector && selector.nodeType ? [selector] : selector), all = jQuery.merge(this.get(), set);
            return this.pushStack(jQuery.unique(all))
        },addBack: function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector))
        }});
        function sibling(cur, dir) {
            while ((cur = cur[dir]) && cur.nodeType !== 1) {
            }
            return cur
        }
        jQuery.each({parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null
        },parents: function(elem) {
            return jQuery.dir(elem, "parentNode")
        },parentsUntil: function(elem, i, until) {
            return jQuery.dir(elem, "parentNode", until)
        },next: function(elem) {
            return sibling(elem, "nextSibling")
        },prev: function(elem) {
            return sibling(elem, "previousSibling")
        },nextAll: function(elem) {
            return jQuery.dir(elem, "nextSibling")
        },prevAll: function(elem) {
            return jQuery.dir(elem, "previousSibling")
        },nextUntil: function(elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until)
        },prevUntil: function(elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until)
        },siblings: function(elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem)
        },children: function(elem) {
            return jQuery.sibling(elem.firstChild)
        },contents: function(elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes)
        }}, function(name, fn) {
            jQuery.fn[name] = function(until, selector) {
                var matched = jQuery.map(this, fn, until);
                if (name.slice(-5) !== "Until") {
                    selector = until
                }
                if (selector && typeof selector === "string") {
                    matched = jQuery.filter(selector, matched)
                }
                if (this.length > 1) {
                    if (!guaranteedUnique[name]) {
                        jQuery.unique(matched)
                    }
                    if (rparentsprev.test(name)) {
                        matched.reverse()
                    }
                }
                return this.pushStack(matched)
            }
        });
        jQuery.extend({filter: function(expr, elems, not) {
            var elem = elems[0];
            if (not) {
                expr = ":not(" + expr + ")"
            }
            return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
                return elem.nodeType === 1
            }))
        },dir: function(elem, dir, until) {
            var matched = [], truncate = until !== undefined;
            while ((elem = elem[dir]) && elem.nodeType !== 9) {
                if (elem.nodeType === 1) {
                    if (truncate && jQuery(elem).is(until)) {
                        break
                    }
                    matched.push(elem)
                }
            }
            return matched
        },sibling: function(n, elem) {
            var matched = [];
            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    matched.push(n)
                }
            }
            return matched
        }});
        function winnow(elements, qualifier, not) {
            if (jQuery.isFunction(qualifier)) {
                return jQuery.grep(elements, function(elem, i) {
                    return !!qualifier.call(elem, i, elem) !== not
                })
            }
            if (qualifier.nodeType) {
                return jQuery.grep(elements, function(elem) {
                    return elem === qualifier !== not
                })
            }
            if (typeof qualifier === "string") {
                if (isSimple.test(qualifier)) {
                    return jQuery.filter(qualifier, elements, not)
                }
                qualifier = jQuery.filter(qualifier, elements)
            }
            return jQuery.grep(elements, function(elem) {
                return core_indexOf.call(qualifier, elem) >= 0 !== not
            })
        }
        var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, manipulation_rcheckableType = /^(?:checkbox|radio)$/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {option: [1, "<select multiple='multiple'>", "</select>"],thead: [1, "<table>", "</table>"],col: [2, "<table><colgroup>", "</colgroup></table>"],tr: [2, "<table><tbody>", "</tbody></table>"],td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],_default: [0, "", ""]};
        wrapMap.optgroup = wrapMap.option;
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        jQuery.fn.extend({text: function(value) {
            return jQuery.access(this, function(value) {
                return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value))
            }, null, value, arguments.length)
        },append: function() {
            return this.domManip(arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem)
                }
            })
        },prepend: function() {
            return this.domManip(arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild)
                }
            })
        },before: function() {
            return this.domManip(arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this)
                }
            })
        },after: function() {
            return this.domManip(arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling)
                }
            })
        },remove: function(selector, keepData) {
            var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
            for (; (elem = elems[i]) != null; i++) {
                if (!keepData && elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem))
                }
                if (elem.parentNode) {
                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                        setGlobalEval(getAll(elem, "script"))
                    }
                    elem.parentNode.removeChild(elem)
                }
            }
            return this
        },empty: function() {
            var elem, i = 0;
            for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.textContent = ""
                }
            }
            return this
        },clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents)
            })
        },html: function(value) {
            return jQuery.access(this, function(value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML
                }
                if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
                    value = value.replace(rxhtmlTag, "<$1></$2>");
                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value
                            }
                        }
                        elem = 0
                    } catch (e) {
                    }
                }
                if (elem) {
                    this.empty().append(value)
                }
            }, null, value, arguments.length)
        },replaceWith: function() {
            var args = jQuery.map(this, function(elem) {
                return [elem.nextSibling, elem.parentNode]
            }), i = 0;
            this.domManip(arguments, function(elem) {
                var next = args[i++], parent = args[i++];
                if (parent) {
                    if (next && next.parentNode !== parent) {
                        next = this.nextSibling
                    }
                    jQuery(this).remove();
                    parent.insertBefore(elem, next)
                }
            }, true);
            return i ? this : this.remove()
        },detach: function(selector) {
            return this.remove(selector, true)
        },domManip: function(args, callback, allowIntersection) {
            args = core_concat.apply([], args);
            var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
            if (isFunction || !(l <= 1 || typeof value !== "string" || jQuery.support.checkClone || !rchecked.test(value))) {
                return this.each(function(index) {
                    var self = set.eq(index);
                    if (isFunction) {
                        args[0] = value.call(this, index, self.html())
                    }
                    self.domManip(args, callback, allowIntersection)
                })
            }
            if (l) {
                fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, !allowIntersection && this);
                first = fragment.firstChild;
                if (fragment.childNodes.length === 1) {
                    fragment = first
                }
                if (first) {
                    scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                    hasScripts = scripts.length;
                    for (; i < l; i++) {
                        node = fragment;
                        if (i !== iNoClone) {
                            node = jQuery.clone(node, true, true);
                            if (hasScripts) {
                                jQuery.merge(scripts, getAll(node, "script"))
                            }
                        }
                        callback.call(this[i], node, i)
                    }
                    if (hasScripts) {
                        doc = scripts[scripts.length - 1].ownerDocument;
                        jQuery.map(scripts, restoreScript);
                        for (i = 0; i < hasScripts; i++) {
                            node = scripts[i];
                            if (rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                                if (node.src) {
                                    jQuery._evalUrl(node.src)
                                } else {
                                    jQuery.globalEval(node.textContent.replace(rcleanScript, ""))
                                }
                            }
                        }
                    }
                }
            }
            return this
        }});
        jQuery.each({appendTo: "append",prependTo: "prepend",insertBefore: "before",insertAfter: "after",replaceAll: "replaceWith"}, function(name, original) {
            jQuery.fn[name] = function(selector) {
                var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
                for (; i <= last; i++) {
                    elems = i === last ? this : this.clone(true);
                    jQuery(insert[i])[original](elems);
                    core_push.apply(ret, elems.get())
                }
                return this.pushStack(ret)
            }
        });
        jQuery.extend({clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!jQuery.support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i])
                }
            }
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i])
                    }
                } else {
                    cloneCopyEvent(elem, clone)
                }
            }
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"))
            }
            return clone
        },buildFragment: function(elems, context, scripts, selection) {
            var elem, tmp, tag, wrap, contains, j, i = 0, l = elems.length, fragment = context.createDocumentFragment(), nodes = [];
            for (; i < l; i++) {
                elem = elems[i];
                if (elem || elem === 0) {
                    if (jQuery.type(elem) === "object") {
                        jQuery.merge(nodes, elem.nodeType ? [elem] : elem)
                    } else if (!rhtml.test(elem)) {
                        nodes.push(context.createTextNode(elem))
                    } else {
                        tmp = tmp || fragment.appendChild(context.createElement("div"));
                        tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
                        j = wrap[0];
                        while (j--) {
                            tmp = tmp.lastChild
                        }
                        jQuery.merge(nodes, tmp.childNodes);
                        tmp = fragment.firstChild;
                        tmp.textContent = ""
                    }
                }
            }
            fragment.textContent = "";
            i = 0;
            while (elem = nodes[i++]) {
                if (selection && jQuery.inArray(elem, selection) !== -1) {
                    continue
                }
                contains = jQuery.contains(elem.ownerDocument, elem);
                tmp = getAll(fragment.appendChild(elem), "script");
                if (contains) {
                    setGlobalEval(tmp)
                }
                if (scripts) {
                    j = 0;
                    while (elem = tmp[j++]) {
                        if (rscriptType.test(elem.type || "")) {
                            scripts.push(elem)
                        }
                    }
                }
            }
            return fragment
        },cleanData: function(elems) {
            var data, elem, events, type, key, j, special = jQuery.event.special, i = 0;
            for (; (elem = elems[i]) !== undefined; i++) {
                if (Data.accepts(elem)) {
                    key = elem[data_priv.expando];
                    if (key && (data = data_priv.cache[key])) {
                        events = Object.keys(data.events || {});
                        if (events.length) {
                            for (j = 0; (type = events[j]) !== undefined; j++) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type)
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle)
                                }
                            }
                        }
                        if (data_priv.cache[key]) {
                            delete data_priv.cache[key]
                        }
                    }
                }
                delete data_user.cache[elem[data_user.expando]]
            }
        },_evalUrl: function(url) {
            return jQuery.ajax({url: url,type: "GET",dataType: "script",async: false,global: false,"throws": true})
        }});
        function manipulationTarget(elem, content) {
            return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType === 1 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem
        }
        function disableScript(elem) {
            elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
            return elem
        }
        function restoreScript(elem) {
            var match = rscriptTypeMasked.exec(elem.type);
            if (match) {
                elem.type = match[1]
            } else {
                elem.removeAttribute("type")
            }
            return elem
        }
        function setGlobalEval(elems, refElements) {
            var l = elems.length, i = 0;
            for (; i < l; i++) {
                data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"))
            }
        }
        function cloneCopyEvent(src, dest) {
            var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
            if (dest.nodeType !== 1) {
                return
            }
            if (data_priv.hasData(src)) {
                pdataOld = data_priv.access(src);
                pdataCur = data_priv.set(dest, pdataOld);
                events = pdataOld.events;
                if (events) {
                    delete pdataCur.handle;
                    pdataCur.events = {};
                    for (type in events) {
                        for (i = 0, l = events[type].length; i < l; i++) {
                            jQuery.event.add(dest, type, events[type][i])
                        }
                    }
                }
            }
            if (data_user.hasData(src)) {
                udataOld = data_user.access(src);
                udataCur = jQuery.extend({}, udataOld);
                data_user.set(dest, udataCur)
            }
        }
        function getAll(context, tag) {
            var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
            return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret
        }
        function fixInput(src, dest) {
            var nodeName = dest.nodeName.toLowerCase();
            if (nodeName === "input" && manipulation_rcheckableType.test(src.type)) {
                dest.checked = src.checked
            } else if (nodeName === "input" || nodeName === "textarea") {
                dest.defaultValue = src.defaultValue
            }
        }
        jQuery.fn.extend({wrapAll: function(html) {
            var wrap;
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapAll(html.call(this, i))
                })
            }
            if (this[0]) {
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0])
                }
                wrap.map(function() {
                    var elem = this;
                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild
                    }
                    return elem
                }).append(this)
            }
            return this
        },wrapInner: function(html) {
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapInner(html.call(this, i))
                })
            }
            return this.each(function() {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html)
                } else {
                    self.append(html)
                }
            })
        },wrap: function(html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html)
            })
        },unwrap: function() {
            return this.parent().each(function() {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes)
                }
            }).end()
        }});
        var curCSS, iframe, rdisplayswap = /^(none|table(?!-c[ea]).+)/, rmargin = /^margin/, rnumsplit = new RegExp("^(" + core_pnum + ")(.*)$", "i"), rnumnonpx = new RegExp("^(" + core_pnum + ")(?!px)[a-z%]+$", "i"), rrelNum = new RegExp("^([+-])=(" + core_pnum + ")", "i"), elemdisplay = {BODY: "block"}, cssShow = {position: "absolute",visibility: "hidden",display: "block"}, cssNormalTransform = {letterSpacing: 0,fontWeight: 400}, cssExpand = ["Top", "Right", "Bottom", "Left"], cssPrefixes = ["Webkit", "O", "Moz", "ms"];
        function vendorPropName(style, name) {
            if (name in style) {
                return name
            }
            var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
            while (i--) {
                name = cssPrefixes[i] + capName;
                if (name in style) {
                    return name
                }
            }
            return origName
        }
        function isHidden(elem, el) {
            elem = el || elem;
            return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem)
        }
        function getStyles(elem) {
            return window.getComputedStyle(elem, null)
        }
        function showHide(elements, show) {
            var display, elem, hidden, values = [], index = 0, length = elements.length;
            for (; index < length; index++) {
                elem = elements[index];
                if (!elem.style) {
                    continue
                }
                values[index] = data_priv.get(elem, "olddisplay");
                display = elem.style.display;
                if (show) {
                    if (!values[index] && display === "none") {
                        elem.style.display = ""
                    }
                    if (elem.style.display === "" && isHidden(elem)) {
                        values[index] = data_priv.access(elem, "olddisplay", css_defaultDisplay(elem.nodeName))
                    }
                } else {
                    if (!values[index]) {
                        hidden = isHidden(elem);
                        if (display && display !== "none" || !hidden) {
                            data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"))
                        }
                    }
                }
            }
            for (index = 0; index < length; index++) {
                elem = elements[index];
                if (!elem.style) {
                    continue
                }
                if (!show || elem.style.display === "none" || elem.style.display === "") {
                    elem.style.display = show ? values[index] || "" : "none"
                }
            }
            return elements
        }
        jQuery.fn.extend({css: function(name, value) {
            return jQuery.access(this, function(elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles)
                    }
                    return map
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name)
            }, name, value, arguments.length > 1)
        },show: function() {
            return showHide(this, true)
        },hide: function() {
            return showHide(this)
        },toggle: function(state) {
            if (typeof state === "boolean") {
                return state ? this.show() : this.hide()
            }
            return this.each(function() {
                if (isHidden(this)) {
                    jQuery(this).show()
                } else {
                    jQuery(this).hide()
                }
            })
        }});
        jQuery.extend({cssHooks: {opacity: {get: function(elem, computed) {
            if (computed) {
                var ret = curCSS(elem, "opacity");
                return ret === "" ? "1" : ret
            }
        }}},cssNumber: {columnCount: true,fillOpacity: true,fontWeight: true,lineHeight: true,opacity: true,order: true,orphans: true,widows: true,zIndex: true,zoom: true},cssProps: {"float": "cssFloat"},style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return
            }
            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === "string" && (ret = rrelNum.exec(value))) {
                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                    type = "number"
                }
                if (value == null || type === "number" && isNaN(value)) {
                    return
                }
                if (type === "number" && !jQuery.cssNumber[origName]) {
                    value += "px"
                }
                if (!jQuery.support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                    style[name] = "inherit"
                }
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    style[name] = value
                }
            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret
                }
                return style[name]
            }
        },css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra)
            }
            if (val === undefined) {
                val = curCSS(elem, name, styles)
            }
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name]
            }
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || jQuery.isNumeric(num) ? num || 0 : val
            }
            return val
        }});
        curCSS = function(elem, name, _computed) {
            var width, minWidth, maxWidth, computed = _computed || getStyles(elem), ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined, style = elem.style;
            if (computed) {
                if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                    ret = jQuery.style(elem, name)
                }
                if (rnumnonpx.test(ret) && rmargin.test(name)) {
                    width = style.width;
                    minWidth = style.minWidth;
                    maxWidth = style.maxWidth;
                    style.minWidth = style.maxWidth = style.width = ret;
                    ret = computed.width;
                    style.width = width;
                    style.minWidth = minWidth;
                    style.maxWidth = maxWidth
                }
            }
            return ret
        };
        function setPositiveNumber(elem, value, subtract) {
            var matches = rnumsplit.exec(value);
            return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value
        }
        function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
            var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0, val = 0;
            for (; i < 4; i += 2) {
                if (extra === "margin") {
                    val += jQuery.css(elem, extra + cssExpand[i], true, styles)
                }
                if (isBorderBox) {
                    if (extra === "content") {
                        val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles)
                    }
                    if (extra !== "margin") {
                        val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles)
                    }
                } else {
                    val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                    if (extra !== "padding") {
                        val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles)
                    }
                }
            }
            return val
        }
        function getWidthOrHeight(elem, name, extra) {
            var valueIsBorderBox = true, val = name === "width" ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.support.boxSizing && jQuery.css(elem, "boxSizing", false, styles) === "border-box";
            if (val <= 0 || val == null) {
                val = curCSS(elem, name, styles);
                if (val < 0 || val == null) {
                    val = elem.style[name]
                }
                if (rnumnonpx.test(val)) {
                    return val
                }
                valueIsBorderBox = isBorderBox && (jQuery.support.boxSizingReliable || val === elem.style[name]);
                val = parseFloat(val) || 0
            }
            return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px"
        }
        function css_defaultDisplay(nodeName) {
            var doc = document, display = elemdisplay[nodeName];
            if (!display) {
                display = actualDisplay(nodeName, doc);
                if (display === "none" || !display) {
                    iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>").css("cssText", "display:block !important")).appendTo(doc.documentElement);
                    doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;
                    doc.write("<!doctype html><html><body>");
                    doc.close();
                    display = actualDisplay(nodeName, doc);
                    iframe.detach()
                }
                elemdisplay[nodeName] = display
            }
            return display
        }
        function actualDisplay(name, doc) {
            var elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = jQuery.css(elem[0], "display");
            elem.remove();
            return display
        }
        jQuery.each(["height", "width"], function(i, name) {
            jQuery.cssHooks[name] = {get: function(elem, computed, extra) {
                if (computed) {
                    return elem.offsetWidth === 0 && rdisplayswap.test(jQuery.css(elem, "display")) ? jQuery.swap(elem, cssShow, function() {
                        return getWidthOrHeight(elem, name, extra)
                    }) : getWidthOrHeight(elem, name, extra)
                }
            },set: function(elem, value, extra) {
                var styles = extra && getStyles(elem);
                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.support.boxSizing && jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0)
            }}
        });
        jQuery(function() {
            if (!jQuery.support.reliableMarginRight) {
                jQuery.cssHooks.marginRight = {get: function(elem, computed) {
                    if (computed) {
                        return jQuery.swap(elem, {display: "inline-block"}, curCSS, [elem, "marginRight"])
                    }
                }}
            }
            if (!jQuery.support.pixelPosition && jQuery.fn.position) {
                jQuery.each(["top", "left"], function(i, prop) {
                    jQuery.cssHooks[prop] = {get: function(elem, computed) {
                        if (computed) {
                            computed = curCSS(elem, prop);
                            return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed
                        }
                    }}
                })
            }
        });
        if (jQuery.expr && jQuery.expr.filters) {
            jQuery.expr.filters.hidden = function(elem) {
                return elem.offsetWidth <= 0 && elem.offsetHeight <= 0
            };
            jQuery.expr.filters.visible = function(elem) {
                return !jQuery.expr.filters.hidden(elem)
            }
        }
        jQuery.each({margin: "",padding: "",border: "Width"}, function(prefix, suffix) {
            jQuery.cssHooks[prefix + suffix] = {expand: function(value) {
                var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0]
                }
                return expanded
            }};
            if (!rmargin.test(prefix)) {
                jQuery.cssHooks[prefix + suffix].set = setPositiveNumber
            }
        });
        var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
        jQuery.fn.extend({serialize: function() {
            return jQuery.param(this.serializeArray())
        },serializeArray: function() {
            return this.map(function() {
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this
            }).filter(function() {
                var type = this.type;
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !manipulation_rcheckableType.test(type))
            }).map(function(i, elem) {
                var val = jQuery(this).val();
                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
                    return {name: elem.name,value: val.replace(rCRLF, "\r\n")}
                }) : {name: elem.name,value: val.replace(rCRLF, "\r\n")}
            }).get()
        }});
        jQuery.param = function(a, traditional) {
            var prefix, s = [], add = function(key, value) {
                value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
                s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value)
            };
            if (traditional === undefined) {
                traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional
            }
            if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
                jQuery.each(a, function() {
                    add(this.name, this.value)
                })
            } else {
                for (prefix in a) {
                    buildParams(prefix, a[prefix], traditional, add)
                }
            }
            return s.join("&").replace(r20, "+")
        };
        function buildParams(prefix, obj, traditional, add) {
            var name;
            if (jQuery.isArray(obj)) {
                jQuery.each(obj, function(i, v) {
                    if (traditional || rbracket.test(prefix)) {
                        add(prefix, v)
                    } else {
                        buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add)
                    }
                })
            } else if (!traditional && jQuery.type(obj) === "object") {
                for (name in obj) {
                    buildParams(prefix + "[" + name + "]", obj[name], traditional, add)
                }
            } else {
                add(prefix, obj)
            }
        }
        jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
            jQuery.fn[name] = function(data, fn) {
                return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name)
            }
        });
        jQuery.fn.extend({hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver)
        },bind: function(types, data, fn) {
            return this.on(types, null, data, fn)
        },unbind: function(types, fn) {
            return this.off(types, null, fn)
        },delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn)
        },undelegate: function(selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn)
        }});
        var ajaxLocParts, ajaxLocation, ajax_nonce = jQuery.now(), ajax_rquery = /\?/, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/, _load = jQuery.fn.load, prefilters = {}, transports = {}, allTypes = "*/".concat("*");
        try {
            ajaxLocation = location.href
        } catch (e) {
            ajaxLocation = document.createElement("a");
            ajaxLocation.href = "";
            ajaxLocation = ajaxLocation.href
        }
        ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
        function addToPrefiltersOrTransports(structure) {
            return function(dataTypeExpression, func) {
                if (typeof dataTypeExpression !== "string") {
                    func = dataTypeExpression;
                    dataTypeExpression = "*"
                }
                var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(core_rnotwhite) || [];
                if (jQuery.isFunction(func)) {
                    while (dataType = dataTypes[i++]) {
                        if (dataType[0] === "+") {
                            dataType = dataType.slice(1) || "*";
                            (structure[dataType] = structure[dataType] || []).unshift(func)
                        } else {
                            (structure[dataType] = structure[dataType] || []).push(func)
                        }
                    }
                }
            }
        }
        function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
            var inspected = {}, seekingTransport = structure === transports;
            function inspect(dataType) {
                var selected;
                inspected[dataType] = true;
                jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                    var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                    if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                        options.dataTypes.unshift(dataTypeOrTransport);
                        inspect(dataTypeOrTransport);
                        return false
                    } else if (seekingTransport) {
                        return !(selected = dataTypeOrTransport)
                    }
                });
                return selected
            }
            return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*")
        }
        function ajaxExtend(target, src) {
            var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
            for (key in src) {
                if (src[key] !== undefined) {
                    (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]
                }
            }
            if (deep) {
                jQuery.extend(true, target, deep)
            }
            return target
        }
        jQuery.fn.load = function(url, params, callback) {
            if (typeof url !== "string" && _load) {
                return _load.apply(this, arguments)
            }
            var selector, type, response, self = this, off = url.indexOf(" ");
            if (off >= 0) {
                selector = url.slice(off);
                url = url.slice(0, off)
            }
            if (jQuery.isFunction(params)) {
                callback = params;
                params = undefined
            } else if (params && typeof params === "object") {
                type = "POST"
            }
            if (self.length > 0) {
                jQuery.ajax({url: url,type: type,dataType: "html",data: params}).done(function(responseText) {
                    response = arguments;
                    self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText)
                }).complete(callback && function(jqXHR, status) {
                        self.each(callback, response || [jqXHR.responseText, status, jqXHR])
                    })
            }
            return this
        };
        jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
            jQuery.fn[type] = function(fn) {
                return this.on(type, fn)
            }
        });
        jQuery.extend({active: 0,lastModified: {},etag: {},ajaxSettings: {url: ajaxLocation,type: "GET",isLocal: rlocalProtocol.test(ajaxLocParts[1]),global: true,processData: true,async: true,contentType: "application/x-www-form-urlencoded; charset=UTF-8",accepts: {"*": allTypes,text: "text/plain",html: "text/html",xml: "application/xml, text/xml",json: "application/json, text/javascript"},contents: {xml: /xml/,html: /html/,json: /json/},responseFields: {xml: "responseXML",text: "responseText",json: "responseJSON"},converters: {"* text": String,"text html": true,"text json": jQuery.parseJSON,"text xml": jQuery.parseXML},flatOptions: {url: true,context: true}},ajaxSetup: function(target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target)
        },ajaxPrefilter: addToPrefiltersOrTransports(prefilters),ajaxTransport: addToPrefiltersOrTransports(transports),ajax: function(url, options) {
            if (typeof url === "object") {
                options = url;
                url = undefined
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = "canceled", jqXHR = {readyState: 0,getResponseHeader: function(key) {
                var match;
                if (state === 2) {
                    if (!responseHeaders) {
                        responseHeaders = {};
                        while (match = rheaders.exec(responseHeadersString)) {
                            responseHeaders[match[1].toLowerCase()] = match[2]
                        }
                    }
                    match = responseHeaders[key.toLowerCase()]
                }
                return match == null ? null : match
            },getAllResponseHeaders: function() {
                return state === 2 ? responseHeadersString : null
            },setRequestHeader: function(name, value) {
                var lname = name.toLowerCase();
                if (!state) {
                    name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                    requestHeaders[name] = value
                }
                return this
            },overrideMimeType: function(type) {
                if (!state) {
                    s.mimeType = type
                }
                return this
            },statusCode: function(map) {
                var code;
                if (map) {
                    if (state < 2) {
                        for (code in map) {
                            statusCode[code] = [statusCode[code], map[code]]
                        }
                    } else {
                        jqXHR.always(map[jqXHR.status])
                    }
                }
                return this
            },abort: function(statusText) {
                var finalText = statusText || strAbort;
                if (transport) {
                    transport.abort(finalText)
                }
                done(0, finalText);
                return this
            }};
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(core_rnotwhite) || [""];
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))))
            }
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional)
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (state === 2) {
                return jqXHR
            }
            fireGlobals = s.global;
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart")
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url;
            if (!s.hasContent) {
                if (s.data) {
                    cacheURL = s.url += (ajax_rquery.test(cacheURL) ? "&" : "?") + s.data;
                    delete s.data
                }
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + ajax_nonce++) : cacheURL + (ajax_rquery.test(cacheURL) ? "&" : "?") + "_=" + ajax_nonce++
                }
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL])
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType)
            }
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i])
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                return jqXHR.abort()
            }
            strAbort = "abort";
            for (i in {success: 1,error: 1,complete: 1}) {
                jqXHR[i](s[i])
            }
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
                done(-1, "No Transport")
            } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [jqXHR, s])
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function() {
                        jqXHR.abort("timeout")
                    }, s.timeout)
                }
                try {
                    state = 1;
                    transport.send(requestHeaders, done)
                } catch (e) {
                    if (state < 2) {
                        done(-1, e)
                    } else {
                        throw e
                    }
                }
            }
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (state === 2) {
                    return
                }
                state = 2;
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer)
                }
                transport = undefined;
                responseHeadersString = headers || "";
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses)
                }
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified
                        }
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) {
                            jQuery.etag[cacheURL] = modified
                        }
                    }
                    if (status === 204 || s.type === "HEAD") {
                        statusText = "nocontent"
                    } else if (status === 304) {
                        statusText = "notmodified"
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error
                    }
                } else {
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0
                        }
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR])
                } else {
                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error])
                }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error])
                }
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                    if (!--jQuery.active) {
                        jQuery.event.trigger("ajaxStop")
                    }
                }
            }
            return jqXHR
        },getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json")
        },getScript: function(url, callback) {
            return jQuery.get(url, undefined, callback, "script")
        }});
        jQuery.each(["get", "post"], function(i, method) {
            jQuery[method] = function(url, data, callback, type) {
                if (jQuery.isFunction(data)) {
                    type = type || callback;
                    callback = data;
                    data = undefined
                }
                return jQuery.ajax({url: url,type: method,dataType: type,data: data,success: callback})
            }
        });
        function ajaxHandleResponses(s, jqXHR, responses) {
            var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
            while (dataTypes[0] === "*") {
                dataTypes.shift();
                if (ct === undefined) {
                    ct = s.mimeType || jqXHR.getResponseHeader("Content-Type")
                }
            }
            if (ct) {
                for (type in contents) {
                    if (contents[type] && contents[type].test(ct)) {
                        dataTypes.unshift(type);
                        break
                    }
                }
            }
            if (dataTypes[0] in responses) {
                finalDataType = dataTypes[0]
            } else {
                for (type in responses) {
                    if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                        finalDataType = type;
                        break
                    }
                    if (!firstDataType) {
                        firstDataType = type
                    }
                }
                finalDataType = finalDataType || firstDataType
            }
            if (finalDataType) {
                if (finalDataType !== dataTypes[0]) {
                    dataTypes.unshift(finalDataType)
                }
                return responses[finalDataType]
            }
        }
        function ajaxConvert(s, response, jqXHR, isSuccess) {
            var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
            if (dataTypes[1]) {
                for (conv in s.converters) {
                    converters[conv.toLowerCase()] = s.converters[conv]
                }
            }
            current = dataTypes.shift();
            while (current) {
                if (s.responseFields[current]) {
                    jqXHR[s.responseFields[current]] = response
                }
                if (!prev && isSuccess && s.dataFilter) {
                    response = s.dataFilter(response, s.dataType)
                }
                prev = current;
                current = dataTypes.shift();
                if (current) {
                    if (current === "*") {
                        current = prev
                    } else if (prev !== "*" && prev !== current) {
                        conv = converters[prev + " " + current] || converters["* " + current];
                        if (!conv) {
                            for (conv2 in converters) {
                                tmp = conv2.split(" ");
                                if (tmp[1] === current) {
                                    conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                                    if (conv) {
                                        if (conv === true) {
                                            conv = converters[conv2]
                                        } else if (converters[conv2] !== true) {
                                            current = tmp[0];
                                            dataTypes.unshift(tmp[1])
                                        }
                                        break
                                    }
                                }
                            }
                        }
                        if (conv !== true) {
                            if (conv && s["throws"]) {
                                response = conv(response)
                            } else {
                                try {
                                    response = conv(response)
                                } catch (e) {
                                    return {state: "parsererror",error: conv ? e : "No conversion from " + prev + " to " + current}
                                }
                            }
                        }
                    }
                }
            }
            return {state: "success",data: response}
        }
        jQuery.ajaxSetup({accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents: {script: /(?:java|ecma)script/},converters: {"text script": function(text) {
            jQuery.globalEval(text);
            return text
        }}});
        jQuery.ajaxPrefilter("script", function(s) {
            if (s.cache === undefined) {
                s.cache = false
            }
            if (s.crossDomain) {
                s.type = "GET"
            }
        });
        jQuery.ajaxTransport("script", function(s) {
            if (s.crossDomain) {
                var script, callback;
                return {send: function(_, complete) {
                    script = jQuery("<script>").prop({async: true,charset: s.scriptCharset,src: s.url}).on("load error", callback = function(evt) {
                        script.remove();
                        callback = null;
                        if (evt) {
                            complete(evt.type === "error" ? 404 : 200, evt.type)
                        }
                    });
                    document.head.appendChild(script[0])
                },abort: function() {
                    if (callback) {
                        callback()
                    }
                }}
            }
        });
        var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery.ajaxSetup({jsonp: "callback",jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + ajax_nonce++;
            this[callback] = true;
            return callback
        }});
        jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
            var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
            if (jsonProp || s.dataTypes[0] === "jsonp") {
                callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
                if (jsonProp) {
                    s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName)
                } else if (s.jsonp !== false) {
                    s.url += (ajax_rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName
                }
                s.converters["script json"] = function() {
                    if (!responseContainer) {
                        jQuery.error(callbackName + " was not called")
                    }
                    return responseContainer[0]
                };
                s.dataTypes[0] = "json";
                overwritten = window[callbackName];
                window[callbackName] = function() {
                    responseContainer = arguments
                };
                jqXHR.always(function() {
                    window[callbackName] = overwritten;
                    if (s[callbackName]) {
                        s.jsonpCallback = originalSettings.jsonpCallback;
                        oldCallbacks.push(callbackName)
                    }
                    if (responseContainer && jQuery.isFunction(overwritten)) {
                        overwritten(responseContainer[0])
                    }
                    responseContainer = overwritten = undefined
                });
                return "script"
            }
        });
        jQuery.ajaxSettings.xhr = function() {
            try {
                return new XMLHttpRequest
            } catch (e) {
            }
        };
        var xhrSupported = jQuery.ajaxSettings.xhr(), xhrSuccessStatus = {0: 200,1223: 204}, xhrId = 0, xhrCallbacks = {};
        if (window.ActiveXObject) {
            jQuery(window).on("unload", function() {
                for (var key in xhrCallbacks) {
                    xhrCallbacks[key]()
                }
                xhrCallbacks = undefined
            })
        }
        jQuery.support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
        jQuery.support.ajax = xhrSupported = !!xhrSupported;
        jQuery.ajaxTransport(function(options) {
            var callback;
            if (jQuery.support.cors || xhrSupported && !options.crossDomain) {
                return {send: function(headers, complete) {
                    var i, id, xhr = options.xhr();
                    xhr.open(options.type, options.url, options.async, options.username, options.password);
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i]
                        }
                    }
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType)
                    }
                    if (!options.crossDomain && !headers["X-Requested-With"]) {
                        headers["X-Requested-With"] = "XMLHttpRequest"
                    }
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i])
                    }
                    callback = function(type) {
                        return function() {
                            if (callback) {
                                delete xhrCallbacks[id];
                                callback = xhr.onload = xhr.onerror = null;
                                if (type === "abort") {
                                    xhr.abort()
                                } else if (type === "error") {
                                    complete(xhr.status || 404, xhr.statusText)
                                } else {
                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === "string" ? {text: xhr.responseText} : undefined, xhr.getAllResponseHeaders())
                                }
                            }
                        }
                    };
                    xhr.onload = callback();
                    xhr.onerror = callback("error");
                    callback = xhrCallbacks[id = xhrId++] = callback("abort");
                    xhr.send(options.hasContent && options.data || null)
                },abort: function() {
                    if (callback) {
                        callback()
                    }
                }}
            }
        });
        var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp("^(?:([+-])=|)(" + core_pnum + ")([a-z%]*)$", "i"), rrun = /queueHooks$/, animationPrefilters = [defaultPrefilter], tweeners = {"*": [function(prop, value) {
            var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"), start = (jQuery.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
            if (start && start[3] !== unit) {
                unit = unit || start[3];
                parts = parts || [];
                start = +target || 1;
                do {
                    scale = scale || ".5";
                    start = start / scale;
                    jQuery.style(tween.elem, prop, start + unit)
                } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations)
            }
            if (parts) {
                start = tween.start = +start || +target || 0;
                tween.unit = unit;
                tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2]
            }
            return tween
        }]};
        function createFxNow() {
            setTimeout(function() {
                fxNow = undefined
            });
            return fxNow = jQuery.now()
        }
        function createTween(value, prop, animation) {
            var tween, collection = (tweeners[prop] || []).concat(tweeners["*"]), index = 0, length = collection.length;
            for (; index < length; index++) {
                if (tween = collection[index].call(animation, prop, value)) {
                    return tween
                }
            }
        }
        function Animation(elem, properties, options) {
            var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function() {
                delete tick.elem
            }), tick = function() {
                if (stopped) {
                    return false
                }
                var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
                for (; index < length; index++) {
                    animation.tweens[index].run(percent)
                }
                deferred.notifyWith(elem, [animation, percent, remaining]);
                if (percent < 1 && length) {
                    return remaining
                } else {
                    deferred.resolveWith(elem, [animation]);
                    return false
                }
            }, animation = deferred.promise({elem: elem,props: jQuery.extend({}, properties),opts: jQuery.extend(true, {specialEasing: {}}, options),originalProperties: properties,originalOptions: options,startTime: fxNow || createFxNow(),duration: options.duration,tweens: [],createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                animation.tweens.push(tween);
                return tween
            },stop: function(gotoEnd) {
                var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) {
                    return this
                }
                stopped = true;
                for (; index < length; index++) {
                    animation.tweens[index].run(1)
                }
                if (gotoEnd) {
                    deferred.resolveWith(elem, [animation, gotoEnd])
                } else {
                    deferred.rejectWith(elem, [animation, gotoEnd])
                }
                return this
            }}), props = animation.props;
            propFilter(props, animation.opts.specialEasing);
            for (; index < length; index++) {
                result = animationPrefilters[index].call(animation, elem, props, animation.opts);
                if (result) {
                    return result
                }
            }
            jQuery.map(props, createTween, animation);
            if (jQuery.isFunction(animation.opts.start)) {
                animation.opts.start.call(elem, animation)
            }
            jQuery.fx.timer(jQuery.extend(tick, {elem: elem,anim: animation,queue: animation.opts.queue}));
            return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always)
        }
        function propFilter(props, specialEasing) {
            var index, name, easing, value, hooks;
            for (index in props) {
                name = jQuery.camelCase(index);
                easing = specialEasing[name];
                value = props[index];
                if (jQuery.isArray(value)) {
                    easing = value[1];
                    value = props[index] = value[0]
                }
                if (index !== name) {
                    props[name] = value;
                    delete props[index]
                }
                hooks = jQuery.cssHooks[name];
                if (hooks && "expand" in hooks) {
                    value = hooks.expand(value);
                    delete props[name];
                    for (index in value) {
                        if (!(index in props)) {
                            props[index] = value[index];
                            specialEasing[index] = easing
                        }
                    }
                } else {
                    specialEasing[name] = easing
                }
            }
        }
        jQuery.Animation = jQuery.extend(Animation, {tweener: function(props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = ["*"]
            } else {
                props = props.split(" ")
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
                prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback)
            }
        },prefilter: function(callback, prepend) {
            if (prepend) {
                animationPrefilters.unshift(callback)
            } else {
                animationPrefilters.push(callback)
            }
        }});
        function defaultPrefilter(elem, props, opts) {
            var prop, value, toggle, tween, hooks, oldfire, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, "fxshow");
            if (!opts.queue) {
                hooks = jQuery._queueHooks(elem, "fx");
                if (hooks.unqueued == null) {
                    hooks.unqueued = 0;
                    oldfire = hooks.empty.fire;
                    hooks.empty.fire = function() {
                        if (!hooks.unqueued) {
                            oldfire()
                        }
                    }
                }
                hooks.unqueued++;
                anim.always(function() {
                    anim.always(function() {
                        hooks.unqueued--;
                        if (!jQuery.queue(elem, "fx").length) {
                            hooks.empty.fire()
                        }
                    })
                })
            }
            if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
                opts.overflow = [style.overflow, style.overflowX, style.overflowY];
                if (jQuery.css(elem, "display") === "inline" && jQuery.css(elem, "float") === "none") {
                    style.display = "inline-block"
                }
            }
            if (opts.overflow) {
                style.overflow = "hidden";
                anim.always(function() {
                    style.overflow = opts.overflow[0];
                    style.overflowX = opts.overflow[1];
                    style.overflowY = opts.overflow[2]
                })
            }
            for (prop in props) {
                value = props[prop];
                if (rfxtypes.exec(value)) {
                    delete props[prop];
                    toggle = toggle || value === "toggle";
                    if (value === (hidden ? "hide" : "show")) {
                        if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                            hidden = true
                        } else {
                            continue
                        }
                    }
                    orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop)
                }
            }
            if (!jQuery.isEmptyObject(orig)) {
                if (dataShow) {
                    if ("hidden" in dataShow) {
                        hidden = dataShow.hidden
                    }
                } else {
                    dataShow = data_priv.access(elem, "fxshow", {})
                }
                if (toggle) {
                    dataShow.hidden = !hidden
                }
                if (hidden) {
                    jQuery(elem).show()
                } else {
                    anim.done(function() {
                        jQuery(elem).hide()
                    })
                }
                anim.done(function() {
                    var prop;
                    data_priv.remove(elem, "fxshow");
                    for (prop in orig) {
                        jQuery.style(elem, prop, orig[prop])
                    }
                });
                for (prop in orig) {
                    tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                    if (!(prop in dataShow)) {
                        dataShow[prop] = tween.start;
                        if (hidden) {
                            tween.end = tween.start;
                            tween.start = prop === "width" || prop === "height" ? 1 : 0
                        }
                    }
                }
            }
        }
        function Tween(elem, options, prop, end, easing) {
            return new Tween.prototype.init(elem, options, prop, end, easing)
        }
        jQuery.Tween = Tween;
        Tween.prototype = {constructor: Tween,init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || "swing";
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px")
        },cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this)
        },run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration)
            } else {
                this.pos = eased = percent
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this)
            }
            if (hooks && hooks.set) {
                hooks.set(this)
            } else {
                Tween.propHooks._default.set(this)
            }
            return this
        }};
        Tween.prototype.init.prototype = Tween.prototype;
        Tween.propHooks = {_default: {get: function(tween) {
            var result;
            if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                return tween.elem[tween.prop]
            }
            result = jQuery.css(tween.elem, tween.prop, "");
            return !result || result === "auto" ? 0 : result
        },set: function(tween) {
            if (jQuery.fx.step[tween.prop]) {
                jQuery.fx.step[tween.prop](tween)
            } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                jQuery.style(tween.elem, tween.prop, tween.now + tween.unit)
            } else {
                tween.elem[tween.prop] = tween.now
            }
        }}};
        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now
            }
        }};
        jQuery.each(["toggle", "show", "hide"], function(i, name) {
            var cssFn = jQuery.fn[name];
            jQuery.fn[name] = function(speed, easing, callback) {
                return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback)
            }
        });
        jQuery.fn.extend({fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHidden).css("opacity", 0).show().end().animate({opacity: to}, speed, easing, callback)
        },animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                if (empty || data_priv.get(this, "finish")) {
                    anim.stop(true)
                }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation)
        },stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd)
            };
            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", [])
            }
            return this.each(function() {
                var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = data_priv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index])
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index])
                        }
                    }
                }
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1)
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type)
                }
            })
        },finish: function(type) {
            if (type !== false) {
                type = type || "fx"
            }
            return this.each(function() {
                var index, data = data_priv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true)
                }
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1)
                    }
                }
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this)
                    }
                }
                delete data.finish
            })
        }});
        function genFx(type, includeWidth) {
            var which, attrs = {height: type}, i = 0;
            includeWidth = includeWidth ? 1 : 0;
            for (; i < 4; i += 2 - includeWidth) {
                which = cssExpand[i];
                attrs["margin" + which] = attrs["padding" + which] = type
            }
            if (includeWidth) {
                attrs.opacity = attrs.width = type
            }
            return attrs
        }
        jQuery.each({slideDown: genFx("show"),slideUp: genFx("hide"),slideToggle: genFx("toggle"),fadeIn: {opacity: "show"},fadeOut: {opacity: "hide"},fadeToggle: {opacity: "toggle"}}, function(name, props) {
            jQuery.fn[name] = function(speed, easing, callback) {
                return this.animate(props, speed, easing, callback)
            }
        });
        jQuery.speed = function(speed, easing, fn) {
            var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,duration: speed,easing: fn && easing || easing && !jQuery.isFunction(easing) && easing};
            opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
            if (opt.queue == null || opt.queue === true) {
                opt.queue = "fx"
            }
            opt.old = opt.complete;
            opt.complete = function() {
                if (jQuery.isFunction(opt.old)) {
                    opt.old.call(this)
                }
                if (opt.queue) {
                    jQuery.dequeue(this, opt.queue)
                }
            };
            return opt
        };
        jQuery.easing = {linear: function(p) {
            return p
        },swing: function(p) {
            return .5 - Math.cos(p * Math.PI) / 2
        }};
        jQuery.timers = [];
        jQuery.fx = Tween.prototype.init;
        jQuery.fx.tick = function() {
            var timer, timers = jQuery.timers, i = 0;
            fxNow = jQuery.now();
            for (; i < timers.length; i++) {
                timer = timers[i];
                if (!timer() && timers[i] === timer) {
                    timers.splice(i--, 1)
                }
            }
            if (!timers.length) {
                jQuery.fx.stop()
            }
            fxNow = undefined
        };
        jQuery.fx.timer = function(timer) {
            if (timer() && jQuery.timers.push(timer)) {
                jQuery.fx.start()
            }
        };
        jQuery.fx.interval = 13;
        jQuery.fx.start = function() {
            if (!timerId) {
                timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval)
            }
        };
        jQuery.fx.stop = function() {
            clearInterval(timerId);
            timerId = null
        };
        jQuery.fx.speeds = {slow: 600,fast: 200,_default: 400};
        jQuery.fx.step = {};
        if (jQuery.expr && jQuery.expr.filters) {
            jQuery.expr.filters.animated = function(elem) {
                return jQuery.grep(jQuery.timers, function(fn) {
                    return elem === fn.elem
                }).length
            }
        }
        jQuery.fn.offset = function(options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function(i) {
                    jQuery.offset.setOffset(this, options, i)
                })
            }
            var docElem, win, elem = this[0], box = {top: 0,left: 0}, doc = elem && elem.ownerDocument;
            if (!doc) {
                return
            }
            docElem = doc.documentElement;
            if (!jQuery.contains(docElem, elem)) {
                return box
            }
            if (typeof elem.getBoundingClientRect !== core_strundefined) {
                box = elem.getBoundingClientRect()
            }
            win = getWindow(doc);
            return {top: box.top + win.pageYOffset - docElem.clientTop,left: box.left + win.pageXOffset - docElem.clientLeft}
        };
        jQuery.offset = {setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            if (position === "static") {
                elem.style.position = "relative"
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset)
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft
            }
            if ("using" in options) {
                options.using.call(elem, props)
            } else {
                curElem.css(props)
            }
        }};
        jQuery.fn.extend({position: function() {
            if (!this[0]) {
                return
            }
            var offsetParent, offset, elem = this[0], parentOffset = {top: 0,left: 0};
            if (jQuery.css(elem, "position") === "fixed") {
                offset = elem.getBoundingClientRect()
            } else {
                offsetParent = this.offsetParent();
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], "html")) {
                    parentOffset = offsetParent.offset()
                }
                parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
                parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true)
            }
            return {top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)}
        },offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent || docElem;
                while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
                    offsetParent = offsetParent.offsetParent
                }
                return offsetParent || docElem
            })
        }});
        jQuery.each({scrollLeft: "pageXOffset",scrollTop: "pageYOffset"}, function(method, prop) {
            var top = "pageYOffset" === prop;
            jQuery.fn[method] = function(val) {
                return jQuery.access(this, function(elem, method, val) {
                    var win = getWindow(elem);
                    if (val === undefined) {
                        return win ? win[prop] : elem[method]
                    }
                    if (win) {
                        win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset)
                    } else {
                        elem[method] = val
                    }
                }, method, val, arguments.length, null)
            }
        });
        function getWindow(elem) {
            return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView
        }
        jQuery.each({Height: "height",Width: "width"}, function(name, type) {
            jQuery.each({padding: "inner" + name,content: type,"": "outer" + name}, function(defaultExtra, funcName) {
                jQuery.fn[funcName] = function(margin, value) {
                    var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                    return jQuery.access(this, function(elem, type, value) {
                        var doc;
                        if (jQuery.isWindow(elem)) {
                            return elem.document.documentElement["client" + name]
                        }
                        if (elem.nodeType === 9) {
                            doc = elem.documentElement;
                            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])
                        }
                        return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra)
                    }, type, chainable ? margin : undefined, chainable, null)
                }
            })
        });
        jQuery.fn.size = function() {
            return this.length
        };
        jQuery.fn.andSelf = jQuery.fn.addBack;
        if (typeof module === "object" && module && typeof module.exports === "object") {
            module.exports = jQuery
        } else {
            if (typeof define === "function" && define.amd) {
                define("jquery", [], function() {
                    return jQuery
                })
            }
        }
        if (typeof window === "object" && typeof window.document === "object") {
            window.jQuery = window.$ = jQuery
        }
    })(window);
(function() {
    var undefined;
    var arrayPool = [], objectPool = [];
    var idCounter = 0;
    var keyPrefix = +new Date + "";
    var largeArraySize = 75;
    var maxPoolSize = 40;
    var whitespace = " 	\f?" + "\n\r\u2028\u2029" + "????????????????";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reFuncName = /^function[ \n\r\t]+\w/;
    var reInterpolate = /<%=([\s\S]+?)%>/g;
    var reLeadingSpacesAndZeros = RegExp("^[" + whitespace + "]*0+(?=.$)");
    var reNoMatch = /($^)/;
    var reThis = /\bthis\b/;
    var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
    var contextProps = ["Array", "Boolean", "Date", "Function", "Math", "Number", "Object", "RegExp", "String", "_", "attachEvent", "clearTimeout", "isFinite", "isNaN", "parseInt", "setImmediate", "setTimeout"];
    var templateCounter = 0;
    var argsClass = "[object Arguments]", arrayClass = "[object Array]", boolClass = "[object Boolean]", dateClass = "[object Date]", funcClass = "[object Function]", numberClass = "[object Number]", objectClass = "[object Object]", regexpClass = "[object RegExp]", stringClass = "[object String]";
    var cloneableClasses = {};
    cloneableClasses[funcClass] = false;
    cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
    var debounceOptions = {leading: false,maxWait: 0,trailing: false};
    var descriptor = {configurable: false,enumerable: false,value: null,writable: false};
    var objectTypes = {"boolean": false,"function": true,object: true,number: false,string: false,undefined: false};
    var stringEscapes = {"\\": "\\","'": "'","\n": "n","\r": "r","	": "t","\u2028": "u2028","\u2029": "u2029"};
    var root = objectTypes[typeof window] && window || this;
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
    var freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
        root = freeGlobal
    }
    function baseIndexOf(array, value, fromIndex) {
        var index = (fromIndex || 0) - 1, length = array ? array.length : 0;
        while (++index < length) {
            if (array[index] === value) {
                return index
            }
        }
        return -1
    }
    function cacheIndexOf(cache, value) {
        var type = typeof value;
        cache = cache.cache;
        if (type == "boolean" || value == null) {
            return cache[value] ? 0 : -1
        }
        if (type != "number" && type != "string") {
            type = "object"
        }
        var key = type == "number" ? value : keyPrefix + value;
        cache = (cache = cache[type]) && cache[key];
        return type == "object" ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1
    }
    function cachePush(value) {
        var cache = this.cache, type = typeof value;
        if (type == "boolean" || value == null) {
            cache[value] = true
        } else {
            if (type != "number" && type != "string") {
                type = "object"
            }
            var key = type == "number" ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
            if (type == "object") {
                (typeCache[key] || (typeCache[key] = [])).push(value)
            } else {
                typeCache[key] = true
            }
        }
    }
    function charAtCallback(value) {
        return value.charCodeAt(0)
    }
    function compareAscending(a, b) {
        var ac = a.criteria, bc = b.criteria;
        if (ac !== bc) {
            if (ac > bc || typeof ac == "undefined") {
                return 1
            }
            if (ac < bc || typeof bc == "undefined") {
                return -1
            }
        }
        return a.index - b.index
    }
    function createCache(array) {
        var index = -1, length = array.length, first = array[0], mid = array[length / 2 | 0], last = array[length - 1];
        if (first && typeof first == "object" && mid && typeof mid == "object" && last && typeof last == "object") {
            return false
        }
        var cache = getObject();
        cache["false"] = cache["null"] = cache["true"] = cache["undefined"] = false;
        var result = getObject();
        result.array = array;
        result.cache = cache;
        result.push = cachePush;
        while (++index < length) {
            result.push(array[index])
        }
        return result
    }
    function escapeStringChar(match) {
        return "\\" + stringEscapes[match]
    }
    function getArray() {
        return arrayPool.pop() || []
    }
    function getObject() {
        return objectPool.pop() || {array: null,cache: null,criteria: null,"false": false,index: 0,"null": false,number: null,object: null,push: null,string: null,"true": false,undefined: false,value: null}
    }
    function noop() {
    }
    function releaseArray(array) {
        array.length = 0;
        if (arrayPool.length < maxPoolSize) {
            arrayPool.push(array)
        }
    }
    function releaseObject(object) {
        var cache = object.cache;
        if (cache) {
            releaseObject(cache)
        }
        object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
        if (objectPool.length < maxPoolSize) {
            objectPool.push(object)
        }
    }
    function slice(array, start, end) {
        start || (start = 0);
        if (typeof end == "undefined") {
            end = array ? array.length : 0
        }
        var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
        while (++index < length) {
            result[index] = array[start + index]
        }
        return result
    }
    function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
        var arrayRef = [];
        var objectProto = Object.prototype;
        var oldDash = context._;
        var reNative = RegExp("^" + String(objectProto.valueOf).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/valueOf|for [^\]]+/g, ".+?") + "$");
        var ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = reNative.test(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, now = reNative.test(now = Date.now) && now || function() {
                return +new Date
            }, push = arrayRef.push, setImmediate = context.setImmediate, setTimeout = context.setTimeout, splice = arrayRef.splice, toString = objectProto.toString, unshift = arrayRef.unshift;
        var defineProperty = function() {
            try {
                var o = {}, func = reNative.test(func = Object.defineProperty) && func, result = func(o, o, o) && func
            } catch (e) {
            }
            return result
        }();
        var nativeBind = reNative.test(nativeBind = toString.bind) && nativeBind, nativeCreate = reNative.test(nativeCreate = Object.create) && nativeCreate, nativeIsArray = reNative.test(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = reNative.test(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeSlice = arrayRef.slice;
        var isIeOpera = reNative.test(context.attachEvent), isV8 = nativeBind && !/\n|true/.test(nativeBind + isIeOpera);
        var ctorByClass = {};
        ctorByClass[arrayClass] = Array;
        ctorByClass[boolClass] = Boolean;
        ctorByClass[dateClass] = Date;
        ctorByClass[funcClass] = Function;
        ctorByClass[objectClass] = Object;
        ctorByClass[numberClass] = Number;
        ctorByClass[regexpClass] = RegExp;
        ctorByClass[stringClass] = String;
        function lodash(value) {
            return value && typeof value == "object" && !isArray(value) && hasOwnProperty.call(value, "__wrapped__") ? value : new lodashWrapper(value)
        }
        function lodashWrapper(value, chainAll) {
            this.__chain__ = !!chainAll;
            this.__wrapped__ = value
        }
        lodashWrapper.prototype = lodash.prototype;
        var support = lodash.support = {};
        support.fastBind = nativeBind && !isV8;
        support.funcDecomp = !reNative.test(context.WinRTError) && reThis.test(runInContext);
        support.funcNames = typeof Function.name == "string";
        lodash.templateSettings = {escape: /<%-([\s\S]+?)%>/g,evaluate: /<%([\s\S]+?)%>/g,interpolate: reInterpolate,variable: "",imports: {_: lodash}};
        function baseClone(value, deep, callback, stackA, stackB) {
            if (callback) {
                var result = callback(value);
                if (typeof result != "undefined") {
                    return result
                }
            }
            var isObj = isObject(value);
            if (isObj) {
                var className = toString.call(value);
                if (!cloneableClasses[className]) {
                    return value
                }
                var ctor = ctorByClass[className];
                switch (className) {
                    case boolClass:
                    case dateClass:
                        return new ctor(+value);
                    case numberClass:
                    case stringClass:
                        return new ctor(value);
                    case regexpClass:
                        result = ctor(value.source, reFlags.exec(value));
                        result.lastIndex = value.lastIndex;
                        return result
                }
            } else {
                return value
            }
            var isArr = isArray(value);
            if (deep) {
                var initedStack = !stackA;
                stackA || (stackA = getArray());
                stackB || (stackB = getArray());
                var length = stackA.length;
                while (length--) {
                    if (stackA[length] == value) {
                        return stackB[length]
                    }
                }
                result = isArr ? ctor(value.length) : {}
            } else {
                result = isArr ? slice(value) : assign({}, value)
            }
            if (isArr) {
                if (hasOwnProperty.call(value, "index")) {
                    result.index = value.index
                }
                if (hasOwnProperty.call(value, "input")) {
                    result.input = value.input
                }
            }
            if (!deep) {
                return result
            }
            stackA.push(value);
            stackB.push(result);
            (isArr ? forEach : forOwn)(value, function(objValue, key) {
                result[key] = baseClone(objValue, deep, callback, stackA, stackB)
            });
            if (initedStack) {
                releaseArray(stackA);
                releaseArray(stackB)
            }
            return result
        }
        function baseCreateCallback(func, thisArg, argCount) {
            if (typeof func != "function") {
                return identity
            }
            if (typeof thisArg == "undefined") {
                return func
            }
            var bindData = func.__bindData__ || support.funcNames && !func.name;
            if (typeof bindData == "undefined") {
                var source = reThis && fnToString.call(func);
                if (!support.funcNames && source && !reFuncName.test(source)) {
                    bindData = true
                }
                if (support.funcNames || !bindData) {
                    bindData = !support.funcDecomp || reThis.test(source);
                    setBindData(func, bindData)
                }
            }
            if (bindData !== true && (bindData && bindData[1] & 1)) {
                return func
            }
            switch (argCount) {
                case 1:
                    return function(value) {
                        return func.call(thisArg, value)
                    };
                case 2:
                    return function(a, b) {
                        return func.call(thisArg, a, b)
                    };
                case 3:
                    return function(value, index, collection) {
                        return func.call(thisArg, value, index, collection)
                    };
                case 4:
                    return function(accumulator, value, index, collection) {
                        return func.call(thisArg, accumulator, value, index, collection)
                    }
            }
            return bind(func, thisArg)
        }
        function baseFlatten(array, isShallow, isArgArrays, fromIndex) {
            var index = (fromIndex || 0) - 1, length = array ? array.length : 0, result = [];
            while (++index < length) {
                var value = array[index];
                if (value && typeof value == "object" && typeof value.length == "number" && (isArray(value) || isArguments(value))) {
                    if (!isShallow) {
                        value = baseFlatten(value, isShallow, isArgArrays)
                    }
                    var valIndex = -1, valLength = value.length, resIndex = result.length;
                    result.length += valLength;
                    while (++valIndex < valLength) {
                        result[resIndex++] = value[valIndex]
                    }
                } else if (!isArgArrays) {
                    result.push(value)
                }
            }
            return result
        }
        function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
            if (callback) {
                var result = callback(a, b);
                if (typeof result != "undefined") {
                    return !!result
                }
            }
            if (a === b) {
                return a !== 0 || 1 / a == 1 / b
            }
            var type = typeof a, otherType = typeof b;
            if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
                return false
            }
            if (a == null || b == null) {
                return a === b
            }
            var className = toString.call(a), otherClass = toString.call(b);
            if (className == argsClass) {
                className = objectClass
            }
            if (otherClass == argsClass) {
                otherClass = objectClass
            }
            if (className != otherClass) {
                return false
            }
            switch (className) {
                case boolClass:
                case dateClass:
                    return +a == +b;
                case numberClass:
                    return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
                case regexpClass:
                case stringClass:
                    return a == String(b)
            }
            var isArr = className == arrayClass;
            if (!isArr) {
                if (hasOwnProperty.call(a, "__wrapped__ ") || hasOwnProperty.call(b, "__wrapped__")) {
                    return baseIsEqual(a.__wrapped__ || a, b.__wrapped__ || b, callback, isWhere, stackA, stackB)
                }
                if (className != objectClass) {
                    return false
                }
                var ctorA = a.constructor, ctorB = b.constructor;
                if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB)) {
                    return false
                }
            }
            var initedStack = !stackA;
            stackA || (stackA = getArray());
            stackB || (stackB = getArray());
            var length = stackA.length;
            while (length--) {
                if (stackA[length] == a) {
                    return stackB[length] == b
                }
            }
            var size = 0;
            result = true;
            stackA.push(a);
            stackB.push(b);
            if (isArr) {
                length = a.length;
                size = b.length;
                result = size == a.length;
                if (!result && !isWhere) {
                    return result
                }
                while (size--) {
                    var index = length, value = b[size];
                    if (isWhere) {
                        while (index--) {
                            if (result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)) {
                                break
                            }
                        }
                    } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                        break
                    }
                }
                return result
            }
            forIn(b, function(value, key, b) {
                if (hasOwnProperty.call(b, key)) {
                    size++;
                    return result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB)
                }
            });
            if (result && !isWhere) {
                forIn(a, function(value, key, a) {
                    if (hasOwnProperty.call(a, key)) {
                        return result = --size > -1
                    }
                })
            }
            if (initedStack) {
                releaseArray(stackA);
                releaseArray(stackB)
            }
            return result
        }
        function baseMerge(object, source, callback, stackA, stackB) {
            (isArray(source) ? forEach : forOwn)(source, function(source, key) {
                var found, isArr, result = source, value = object[key];
                if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                    var stackLength = stackA.length;
                    while (stackLength--) {
                        if (found = stackA[stackLength] == source) {
                            value = stackB[stackLength];
                            break
                        }
                    }
                    if (!found) {
                        var isShallow;
                        if (callback) {
                            result = callback(value, source);
                            if (isShallow = typeof result != "undefined") {
                                value = result
                            }
                        }
                        if (!isShallow) {
                            value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {}
                        }
                        stackA.push(source);
                        stackB.push(value);
                        if (!isShallow) {
                            baseMerge(value, source, callback, stackA, stackB)
                        }
                    }
                } else {
                    if (callback) {
                        result = callback(value, source);
                        if (typeof result == "undefined") {
                            result = source
                        }
                    }
                    if (typeof result != "undefined") {
                        value = result
                    }
                }
                object[key] = value
            })
        }
        function baseUniq(array, isSorted, callback) {
            var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [];
            var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf, seen = callback || isLarge ? getArray() : result;
            if (isLarge) {
                var cache = createCache(seen);
                if (cache) {
                    indexOf = cacheIndexOf;
                    seen = cache
                } else {
                    isLarge = false;
                    seen = callback ? seen : (releaseArray(seen), result)
                }
            }
            while (++index < length) {
                var value = array[index], computed = callback ? callback(value, index, array) : value;
                if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
                    if (callback || isLarge) {
                        seen.push(computed)
                    }
                    result.push(value)
                }
            }
            if (isLarge) {
                releaseArray(seen.array);
                releaseObject(seen)
            } else if (callback) {
                releaseArray(seen)
            }
            return result
        }
        function createAggregator(setter) {
            return function(collection, callback, thisArg) {
                var result = {};
                callback = lodash.createCallback(callback, thisArg, 3);
                var index = -1, length = collection ? collection.length : 0;
                if (typeof length == "number") {
                    while (++index < length) {
                        var value = collection[index];
                        setter(result, value, callback(value, index, collection), collection)
                    }
                } else {
                    forOwn(collection, function(value, key, collection) {
                        setter(result, value, callback(value, key, collection), collection)
                    })
                }
                return result
            }
        }
        function createBound(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
            var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, isPartial = bitmask & 16, isPartialRight = bitmask & 32, key = func;
            if (!isBindKey && !isFunction(func)) {
                throw new TypeError
            }
            if (isPartial && !partialArgs.length) {
                bitmask &= ~16;
                isPartial = partialArgs = false
            }
            if (isPartialRight && !partialRightArgs.length) {
                bitmask &= ~32;
                isPartialRight = partialRightArgs = false
            }
            var bindData = func && func.__bindData__;
            if (bindData) {
                if (isBind && !(bindData[1] & 1)) {
                    bindData[4] = thisArg
                }
                if (!isBind && bindData[1] & 1) {
                    bitmask |= 8
                }
                if (isCurry && !(bindData[1] & 4)) {
                    bindData[5] = arity
                }
                if (isPartial) {
                    push.apply(bindData[2] || (bindData[2] = []), partialArgs)
                }
                if (isPartialRight) {
                    push.apply(bindData[3] || (bindData[3] = []), partialRightArgs)
                }
                bindData[1] |= bitmask;
                return createBound.apply(null, bindData)
            }
            if (isBind && !(isBindKey || isCurry || isPartialRight) && (support.fastBind || nativeBind && isPartial)) {
                if (isPartial) {
                    var args = [thisArg];
                    push.apply(args, partialArgs)
                }
                var bound = isPartial ? nativeBind.apply(func, args) : nativeBind.call(func, thisArg)
            } else {
                bound = function() {
                    var args = arguments, thisBinding = isBind ? thisArg : this;
                    if (isCurry || isPartial || isPartialRight) {
                        args = nativeSlice.call(args);
                        if (isPartial) {
                            unshift.apply(args, partialArgs)
                        }
                        if (isPartialRight) {
                            push.apply(args, partialRightArgs)
                        }
                        if (isCurry && args.length < arity) {
                            bitmask |= 16 & ~32;
                            return createBound(func, isCurryBound ? bitmask : bitmask & ~3, args, null, thisArg, arity)
                        }
                    }
                    if (isBindKey) {
                        func = thisBinding[key]
                    }
                    if (this instanceof bound) {
                        thisBinding = createObject(func.prototype);
                        var result = func.apply(thisBinding, args);
                        return isObject(result) ? result : thisBinding
                    }
                    return func.apply(thisBinding, args)
                }
            }
            setBindData(bound, nativeSlice.call(arguments));
            return bound
        }
        function createObject(prototype) {
            return isObject(prototype) ? nativeCreate(prototype) : {}
        }
        if (!nativeCreate) {
            createObject = function(prototype) {
                if (isObject(prototype)) {
                    noop.prototype = prototype;
                    var result = new noop;
                    noop.prototype = null
                }
                return result || {}
            }
        }
        function escapeHtmlChar(match) {
            return htmlEscapes[match]
        }
        function getIndexOf() {
            var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
            return result
        }
        var setBindData = !defineProperty ? noop : function(func, value) {
            descriptor.value = value;
            defineProperty(func, "__bindData__", descriptor)
        };
        function shimIsPlainObject(value) {
            var ctor, result;
            if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
                return false
            }
            forIn(value, function(value, key) {
                result = key
            });
            return typeof result == "undefined" || hasOwnProperty.call(value, result)
        }
        function unescapeHtmlChar(match) {
            return htmlUnescapes[match]
        }
        function isArguments(value) {
            return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == argsClass || false
        }
        var isArray = nativeIsArray || function(value) {
                return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == arrayClass || false
            };
        var shimKeys = function(object) {
            var index, iterable = object, result = [];
            if (!iterable)
                return result;
            if (!objectTypes[typeof object])
                return result;
            for (index in iterable) {
                if (hasOwnProperty.call(iterable, index)) {
                    result.push(index)
                }
            }
            return result
        };
        var keys = !nativeKeys ? shimKeys : function(object) {
            if (!isObject(object)) {
                return []
            }
            return nativeKeys(object)
        };
        var htmlEscapes = {"&": "&amp;","<": "&lt;",">": "&gt;",'"': "&quot;","'": "&#39;"};
        var htmlUnescapes = invert(htmlEscapes);
        var reEscapedHtml = RegExp("(" + keys(htmlUnescapes).join("|") + ")", "g"), reUnescapedHtml = RegExp("[" + keys(htmlEscapes).join("") + "]", "g");
        var assign = function(object, source, guard) {
            var index, iterable = object, result = iterable;
            if (!iterable)
                return result;
            var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
            if (argsLength > 3 && typeof args[argsLength - 2] == "function") {
                var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2)
            } else if (argsLength > 2 && typeof args[argsLength - 1] == "function") {
                callback = args[--argsLength]
            }
            while (++argsIndex < argsLength) {
                iterable = args[argsIndex];
                if (iterable && objectTypes[typeof iterable]) {
                    var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                    while (++ownIndex < length) {
                        index = ownProps[ownIndex];
                        result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]
                    }
                }
            }
            return result
        };
        function clone(value, deep, callback, thisArg) {
            if (typeof deep != "boolean" && deep != null) {
                thisArg = callback;
                callback = deep;
                deep = false
            }
            return baseClone(value, deep, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1))
        }
        function cloneDeep(value, callback, thisArg) {
            return baseClone(value, true, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1))
        }
        var defaults = function(object, source, guard) {
            var index, iterable = object, result = iterable;
            if (!iterable)
                return result;
            var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
            while (++argsIndex < argsLength) {
                iterable = args[argsIndex];
                if (iterable && objectTypes[typeof iterable]) {
                    var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                    while (++ownIndex < length) {
                        index = ownProps[ownIndex];
                        if (typeof result[index] == "undefined")
                            result[index] = iterable[index]
                    }
                }
            }
            return result
        };
        function findKey(object, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwn(object, function(value, key, object) {
                if (callback(value, key, object)) {
                    result = key;
                    return false
                }
            });
            return result
        }
        function findLastKey(object, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwnRight(object, function(value, key, object) {
                if (callback(value, key, object)) {
                    result = key;
                    return false
                }
            });
            return result
        }
        var forIn = function(collection, callback, thisArg) {
            var index, iterable = collection, result = iterable;
            if (!iterable)
                return result;
            if (!objectTypes[typeof iterable])
                return result;
            callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
            for (index in iterable) {
                if (callback(iterable[index], index, collection) === false)
                    return result
            }
            return result
        };
        function forInRight(object, callback, thisArg) {
            var pairs = [];
            forIn(object, function(value, key) {
                pairs.push(key, value)
            });
            var length = pairs.length;
            callback = baseCreateCallback(callback, thisArg, 3);
            while (length--) {
                if (callback(pairs[length--], pairs[length], object) === false) {
                    break
                }
            }
            return object
        }
        var forOwn = function(collection, callback, thisArg) {
            var index, iterable = collection, result = iterable;
            if (!iterable)
                return result;
            if (!objectTypes[typeof iterable])
                return result;
            callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
            var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
            while (++ownIndex < length) {
                index = ownProps[ownIndex];
                if (callback(iterable[index], index, collection) === false)
                    return result
            }
            return result
        };
        function forOwnRight(object, callback, thisArg) {
            var props = keys(object), length = props.length;
            callback = baseCreateCallback(callback, thisArg, 3);
            while (length--) {
                var key = props[length];
                if (callback(object[key], key, object) === false) {
                    break
                }
            }
            return object
        }
        function functions(object) {
            var result = [];
            forIn(object, function(value, key) {
                if (isFunction(value)) {
                    result.push(key)
                }
            });
            return result.sort()
        }
        function has(object, property) {
            return object ? hasOwnProperty.call(object, property) : false
        }
        function invert(object) {
            var index = -1, props = keys(object), length = props.length, result = {};
            while (++index < length) {
                var key = props[index];
                result[object[key]] = key
            }
            return result
        }
        function isBoolean(value) {
            return value === true || value === false || toString.call(value) == boolClass
        }
        function isDate(value) {
            return value ? typeof value == "object" && toString.call(value) == dateClass : false
        }
        function isElement(value) {
            return value ? value.nodeType === 1 : false
        }
        function isEmpty(value) {
            var result = true;
            if (!value) {
                return result
            }
            var className = toString.call(value), length = value.length;
            if (className == arrayClass || className == stringClass || className == argsClass || className == objectClass && typeof length == "number" && isFunction(value.splice)) {
                return !length
            }
            forOwn(value, function() {
                return result = false
            });
            return result
        }
        function isEqual(a, b, callback, thisArg) {
            return baseIsEqual(a, b, typeof callback == "function" && baseCreateCallback(callback, thisArg, 2))
        }
        function isFinite(value) {
            return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value))
        }
        function isFunction(value) {
            return typeof value == "function"
        }
        function isObject(value) {
            return !!(value && objectTypes[typeof value])
        }
        function isNaN(value) {
            return isNumber(value) && value != +value
        }
        function isNull(value) {
            return value === null
        }
        function isNumber(value) {
            return typeof value == "number" || toString.call(value) == numberClass
        }
        var isPlainObject = function(value) {
            if (!(value && toString.call(value) == objectClass)) {
                return false
            }
            var valueOf = value.valueOf, objProto = typeof valueOf == "function" && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
            return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value)
        };
        function isRegExp(value) {
            return value ? typeof value == "object" && toString.call(value) == regexpClass : false
        }
        function isString(value) {
            return typeof value == "string" || toString.call(value) == stringClass
        }
        function isUndefined(value) {
            return typeof value == "undefined"
        }
        function merge(object) {
            var args = arguments, length = 2;
            if (!isObject(object)) {
                return object
            }
            if (typeof args[2] != "number") {
                length = args.length
            }
            if (length > 3 && typeof args[length - 2] == "function") {
                var callback = baseCreateCallback(args[--length - 1], args[length--], 2)
            } else if (length > 2 && typeof args[length - 1] == "function") {
                callback = args[--length]
            }
            var sources = nativeSlice.call(arguments, 1, length), index = -1, stackA = getArray(), stackB = getArray();
            while (++index < length) {
                baseMerge(object, sources[index], callback, stackA, stackB)
            }
            releaseArray(stackA);
            releaseArray(stackB);
            return object
        }
        function omit(object, callback, thisArg) {
            var indexOf = getIndexOf(), isFunc = typeof callback == "function", result = {};
            if (isFunc) {
                callback = lodash.createCallback(callback, thisArg, 3)
            } else {
                var props = baseFlatten(arguments, true, false, 1)
            }
            forIn(object, function(value, key, object) {
                if (isFunc ? !callback(value, key, object) : indexOf(props, key) < 0) {
                    result[key] = value
                }
            });
            return result
        }
        function pairs(object) {
            var index = -1, props = keys(object), length = props.length, result = Array(length);
            while (++index < length) {
                var key = props[index];
                result[index] = [key, object[key]]
            }
            return result
        }
        function pick(object, callback, thisArg) {
            var result = {};
            if (typeof callback != "function") {
                var index = -1, props = baseFlatten(arguments, true, false, 1), length = isObject(object) ? props.length : 0;
                while (++index < length) {
                    var key = props[index];
                    if (key in object) {
                        result[key] = object[key]
                    }
                }
            } else {
                callback = lodash.createCallback(callback, thisArg, 3);
                forIn(object, function(value, key, object) {
                    if (callback(value, key, object)) {
                        result[key] = value
                    }
                })
            }
            return result
        }
        function transform(object, callback, accumulator, thisArg) {
            var isArr = isArray(object);
            callback = baseCreateCallback(callback, thisArg, 4);
            if (accumulator == null) {
                if (isArr) {
                    accumulator = []
                } else {
                    var ctor = object && object.constructor, proto = ctor && ctor.prototype;
                    accumulator = createObject(proto)
                }
            }
            (isArr ? forEach : forOwn)(object, function(value, index, object) {
                return callback(accumulator, value, index, object)
            });
            return accumulator
        }
        function values(object) {
            var index = -1, props = keys(object), length = props.length, result = Array(length);
            while (++index < length) {
                result[index] = object[props[index]]
            }
            return result
        }
        function at(collection) {
            var args = arguments, index = -1, props = baseFlatten(args, true, false, 1), length = args[2] && args[2][args[1]] === collection ? 1 : props.length, result = Array(length);
            while (++index < length) {
                result[index] = collection[props[index]]
            }
            return result
        }
        function contains(collection, target, fromIndex) {
            var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = false;
            fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
            if (isArray(collection)) {
                result = indexOf(collection, target, fromIndex) > -1
            } else if (typeof length == "number") {
                result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1
            } else {
                forOwn(collection, function(value) {
                    if (++index >= fromIndex) {
                        return !(result = value === target)
                    }
                })
            }
            return result
        }
        var countBy = createAggregator(function(result, value, key) {
            hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1
        });
        function every(collection, callback, thisArg) {
            var result = true;
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if (typeof length == "number") {
                while (++index < length) {
                    if (!(result = !!callback(collection[index], index, collection))) {
                        break
                    }
                }
            } else {
                forOwn(collection, function(value, index, collection) {
                    return result = !!callback(value, index, collection)
                })
            }
            return result
        }
        function filter(collection, callback, thisArg) {
            var result = [];
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if (typeof length == "number") {
                while (++index < length) {
                    var value = collection[index];
                    if (callback(value, index, collection)) {
                        result.push(value)
                    }
                }
            } else {
                forOwn(collection, function(value, index, collection) {
                    if (callback(value, index, collection)) {
                        result.push(value)
                    }
                })
            }
            return result
        }
        function find(collection, callback, thisArg) {
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if (typeof length == "number") {
                while (++index < length) {
                    var value = collection[index];
                    if (callback(value, index, collection)) {
                        return value
                    }
                }
            } else {
                var result;
                forOwn(collection, function(value, index, collection) {
                    if (callback(value, index, collection)) {
                        result = value;
                        return false
                    }
                });
                return result
            }
        }
        function findLast(collection, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forEachRight(collection, function(value, index, collection) {
                if (callback(value, index, collection)) {
                    result = value;
                    return false
                }
            });
            return result
        }
        function forEach(collection, callback, thisArg) {
            var index = -1, length = collection ? collection.length : 0;
            callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
            if (typeof length == "number") {
                while (++index < length) {
                    if (callback(collection[index], index, collection) === false) {
                        break
                    }
                }
            } else {
                forOwn(collection, callback)
            }
            return collection
        }
        function forEachRight(collection, callback, thisArg) {
            var length = collection ? collection.length : 0;
            callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
            if (typeof length == "number") {
                while (length--) {
                    if (callback(collection[length], length, collection) === false) {
                        break
                    }
                }
            } else {
                var props = keys(collection);
                length = props.length;
                forOwn(collection, function(value, key, collection) {
                    key = props ? props[--length] : --length;
                    return callback(collection[key], key, collection)
                })
            }
            return collection
        }
        var groupBy = createAggregator(function(result, value, key) {
            (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value)
        });
        var indexBy = createAggregator(function(result, value, key) {
            result[key] = value
        });
        function invoke(collection, methodName) {
            var args = nativeSlice.call(arguments, 2), index = -1, isFunc = typeof methodName == "function", length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
            forEach(collection, function(value) {
                result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args)
            });
            return result
        }
        function map(collection, callback, thisArg) {
            var index = -1, length = collection ? collection.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            if (typeof length == "number") {
                var result = Array(length);
                while (++index < length) {
                    result[index] = callback(collection[index], index, collection)
                }
            } else {
                result = [];
                forOwn(collection, function(value, key, collection) {
                    result[++index] = callback(value, key, collection)
                })
            }
            return result
        }
        function max(collection, callback, thisArg) {
            var computed = -Infinity, result = computed;
            if (!callback && isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    var value = collection[index];
                    if (value > result) {
                        result = value
                    }
                }
            } else {
                callback = !callback && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                forEach(collection, function(value, index, collection) {
                    var current = callback(value, index, collection);
                    if (current > computed) {
                        computed = current;
                        result = value
                    }
                })
            }
            return result
        }
        function min(collection, callback, thisArg) {
            var computed = Infinity, result = computed;
            if (!callback && isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    var value = collection[index];
                    if (value < result) {
                        result = value
                    }
                }
            } else {
                callback = !callback && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                forEach(collection, function(value, index, collection) {
                    var current = callback(value, index, collection);
                    if (current < computed) {
                        computed = current;
                        result = value
                    }
                })
            }
            return result
        }
        function pluck(collection, property) {
            var index = -1, length = collection ? collection.length : 0;
            if (typeof length == "number") {
                var result = Array(length);
                while (++index < length) {
                    result[index] = collection[index][property]
                }
            }
            return result || map(collection, property)
        }
        function reduce(collection, callback, accumulator, thisArg) {
            if (!collection)
                return accumulator;
            var noaccum = arguments.length < 3;
            callback = baseCreateCallback(callback, thisArg, 4);
            var index = -1, length = collection.length;
            if (typeof length == "number") {
                if (noaccum) {
                    accumulator = collection[++index]
                }
                while (++index < length) {
                    accumulator = callback(accumulator, collection[index], index, collection)
                }
            } else {
                forOwn(collection, function(value, index, collection) {
                    accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection)
                })
            }
            return accumulator
        }
        function reduceRight(collection, callback, accumulator, thisArg) {
            var noaccum = arguments.length < 3;
            callback = baseCreateCallback(callback, thisArg, 4);
            forEachRight(collection, function(value, index, collection) {
                accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection)
            });
            return accumulator
        }
        function reject(collection, callback, thisArg) {
            callback = lodash.createCallback(callback, thisArg, 3);
            return filter(collection, function(value, index, collection) {
                return !callback(value, index, collection)
            })
        }
        function sample(collection, n, guard) {
            var length = collection ? collection.length : 0;
            if (typeof length != "number") {
                collection = values(collection)
            }
            if (n == null || guard) {
                return collection ? collection[random(length - 1)] : undefined
            }
            var result = shuffle(collection);
            result.length = nativeMin(nativeMax(0, n), result.length);
            return result
        }
        function shuffle(collection) {
            var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
            forEach(collection, function(value) {
                var rand = random(++index);
                result[index] = result[rand];
                result[rand] = value
            });
            return result
        }
        function size(collection) {
            var length = collection ? collection.length : 0;
            return typeof length == "number" ? length : keys(collection).length
        }
        function some(collection, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if (typeof length == "number") {
                while (++index < length) {
                    if (result = callback(collection[index], index, collection)) {
                        break
                    }
                }
            } else {
                forOwn(collection, function(value, index, collection) {
                    return !(result = callback(value, index, collection))
                })
            }
            return !!result
        }
        function sortBy(collection, callback, thisArg) {
            var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
            callback = lodash.createCallback(callback, thisArg, 3);
            forEach(collection, function(value, key, collection) {
                var object = result[++index] = getObject();
                object.criteria = callback(value, key, collection);
                object.index = index;
                object.value = value
            });
            length = result.length;
            result.sort(compareAscending);
            while (length--) {
                var object = result[length];
                result[length] = object.value;
                releaseObject(object)
            }
            return result
        }
        function toArray(collection) {
            if (collection && typeof collection.length == "number") {
                return slice(collection)
            }
            return values(collection)
        }
        var where = filter;
        function compact(array) {
            var index = -1, length = array ? array.length : 0, result = [];
            while (++index < length) {
                var value = array[index];
                if (value) {
                    result.push(value)
                }
            }
            return result
        }
        function difference(array) {
            var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, seen = baseFlatten(arguments, true, true, 1), result = [];
            var isLarge = length >= largeArraySize && indexOf === baseIndexOf;
            if (isLarge) {
                var cache = createCache(seen);
                if (cache) {
                    indexOf = cacheIndexOf;
                    seen = cache
                } else {
                    isLarge = false
                }
            }
            while (++index < length) {
                var value = array[index];
                if (indexOf(seen, value) < 0) {
                    result.push(value)
                }
            }
            if (isLarge) {
                releaseObject(seen)
            }
            return result
        }
        function findIndex(array, callback, thisArg) {
            var index = -1, length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length) {
                if (callback(array[index], index, array)) {
                    return index
                }
            }
            return -1
        }
        function findLastIndex(array, callback, thisArg) {
            var length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (length--) {
                if (callback(array[length], length, array)) {
                    return length
                }
            }
            return -1
        }
        function first(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if (typeof callback != "number" && callback != null) {
                var index = -1;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (++index < length && callback(array[index], index, array)) {
                    n++
                }
            } else {
                n = callback;
                if (n == null || thisArg) {
                    return array ? array[0] : undefined
                }
            }
            return slice(array, 0, nativeMin(nativeMax(0, n), length))
        }
        function flatten(array, isShallow, callback, thisArg) {
            if (typeof isShallow != "boolean" && isShallow != null) {
                thisArg = callback;
                callback = !(thisArg && thisArg[isShallow] === array) ? isShallow : null;
                isShallow = false
            }
            if (callback != null) {
                array = map(array, callback, thisArg)
            }
            return baseFlatten(array, isShallow)
        }
        function indexOf(array, value, fromIndex) {
            if (typeof fromIndex == "number") {
                var length = array ? array.length : 0;
                fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0
            } else if (fromIndex) {
                var index = sortedIndex(array, value);
                return array[index] === value ? index : -1
            }
            return baseIndexOf(array, value, fromIndex)
        }
        function initial(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if (typeof callback != "number" && callback != null) {
                var index = length;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (index-- && callback(array[index], index, array)) {
                    n++
                }
            } else {
                n = callback == null || thisArg ? 1 : callback || n
            }
            return slice(array, 0, nativeMin(nativeMax(0, length - n), length))
        }
        function intersection(array) {
            var args = arguments, argsLength = args.length, argsIndex = -1, caches = getArray(), index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [], seen = getArray();
            while (++argsIndex < argsLength) {
                var value = args[argsIndex];
                caches[argsIndex] = indexOf === baseIndexOf && (value ? value.length : 0) >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen)
            }
            outer: while (++index < length) {
                var cache = caches[0];
                value = array[index];
                if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                    argsIndex = argsLength;
                    (cache || seen).push(value);
                    while (--argsIndex) {
                        cache = caches[argsIndex];
                        if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                            continue outer
                        }
                    }
                    result.push(value)
                }
            }
            while (argsLength--) {
                cache = caches[argsLength];
                if (cache) {
                    releaseObject(cache)
                }
            }
            releaseArray(caches);
            releaseArray(seen);
            return result
        }
        function last(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if (typeof callback != "number" && callback != null) {
                var index = length;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (index-- && callback(array[index], index, array)) {
                    n++
                }
            } else {
                n = callback;
                if (n == null || thisArg) {
                    return array ? array[length - 1] : undefined
                }
            }
            return slice(array, nativeMax(0, length - n))
        }
        function lastIndexOf(array, value, fromIndex) {
            var index = array ? array.length : 0;
            if (typeof fromIndex == "number") {
                index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1
            }
            while (index--) {
                if (array[index] === value) {
                    return index
                }
            }
            return -1
        }
        function pull(array) {
            var args = arguments, argsIndex = 0, argsLength = args.length, length = array ? array.length : 0;
            while (++argsIndex < argsLength) {
                var index = -1, value = args[argsIndex];
                while (++index < length) {
                    if (array[index] === value) {
                        splice.call(array, index--, 1);
                        length--
                    }
                }
            }
            return array
        }
        function range(start, end, step) {
            start = +start || 0;
            step = typeof step == "number" ? step : +step || 1;
            if (end == null) {
                end = start;
                start = 0
            }
            var index = -1, length = nativeMax(0, ceil((end - start) / (step || 1))), result = Array(length);
            while (++index < length) {
                result[index] = start;
                start += step
            }
            return result
        }
        function remove(array, callback, thisArg) {
            var index = -1, length = array ? array.length : 0, result = [];
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length) {
                var value = array[index];
                if (callback(value, index, array)) {
                    result.push(value);
                    splice.call(array, index--, 1);
                    length--
                }
            }
            return result
        }
        function rest(array, callback, thisArg) {
            if (typeof callback != "number" && callback != null) {
                var n = 0, index = -1, length = array ? array.length : 0;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (++index < length && callback(array[index], index, array)) {
                    n++
                }
            } else {
                n = callback == null || thisArg ? 1 : nativeMax(0, callback)
            }
            return slice(array, n)
        }
        function sortedIndex(array, value, callback, thisArg) {
            var low = 0, high = array ? array.length : low;
            callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
            value = callback(value);
            while (low < high) {
                var mid = low + high >>> 1;
                callback(array[mid]) < value ? low = mid + 1 : high = mid
            }
            return low
        }
        function union(array) {
            return baseUniq(baseFlatten(arguments, true, true))
        }
        function uniq(array, isSorted, callback, thisArg) {
            if (typeof isSorted != "boolean" && isSorted != null) {
                thisArg = callback;
                callback = !(thisArg && thisArg[isSorted] === array) ? isSorted : null;
                isSorted = false
            }
            if (callback != null) {
                callback = lodash.createCallback(callback, thisArg, 3)
            }
            return baseUniq(array, isSorted, callback)
        }
        function without(array) {
            return difference(array, nativeSlice.call(arguments, 1))
        }
        function zip() {
            var array = arguments.length > 1 ? arguments : arguments[0], index = -1, length = array ? max(pluck(array, "length")) : 0, result = Array(length < 0 ? 0 : length);
            while (++index < length) {
                result[index] = pluck(array, index)
            }
            return result
        }
        function zipObject(keys, values) {
            var index = -1, length = keys ? keys.length : 0, result = {};
            while (++index < length) {
                var key = keys[index];
                if (values) {
                    result[key] = values[index]
                } else if (key) {
                    result[key[0]] = key[1]
                }
            }
            return result
        }
        function after(n, func) {
            if (!isFunction(func)) {
                throw new TypeError
            }
            return function() {
                if (--n < 1) {
                    return func.apply(this, arguments)
                }
            }
        }
        function bind(func, thisArg) {
            return arguments.length > 2 ? createBound(func, 17, nativeSlice.call(arguments, 2), null, thisArg) : createBound(func, 1, null, null, thisArg)
        }
        function bindAll(object) {
            var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object), index = -1, length = funcs.length;
            while (++index < length) {
                var key = funcs[index];
                object[key] = createBound(object[key], 1, null, null, object)
            }
            return object
        }
        function bindKey(object, key) {
            return arguments.length > 2 ? createBound(key, 19, nativeSlice.call(arguments, 2), null, object) : createBound(key, 3, null, null, object)
        }
        function compose() {
            var funcs = arguments, length = funcs.length;
            while (length--) {
                if (!isFunction(funcs[length])) {
                    throw new TypeError
                }
            }
            return function() {
                var args = arguments, length = funcs.length;
                while (length--) {
                    args = [funcs[length].apply(this, args)]
                }
                return args[0]
            }
        }
        function createCallback(func, thisArg, argCount) {
            var type = typeof func;
            if (func == null || type == "function") {
                return baseCreateCallback(func, thisArg, argCount)
            }
            if (type != "object") {
                return function(object) {
                    return object[func]
                }
            }
            var props = keys(func), key = props[0], a = func[key];
            if (props.length == 1 && a === a && !isObject(a)) {
                return function(object) {
                    var b = object[key];
                    return a === b && (a !== 0 || 1 / a == 1 / b)
                }
            }
            return function(object) {
                var length = props.length, result = false;
                while (length--) {
                    if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                        break
                    }
                }
                return result
            }
        }
        function curry(func, arity) {
            arity = typeof arity == "number" ? arity : +arity || func.length;
            return createBound(func, 4, null, null, null, arity)
        }
        function debounce(func, wait, options) {
            var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
            if (!isFunction(func)) {
                throw new TypeError
            }
            wait = nativeMax(0, wait) || 0;
            if (options === true) {
                var leading = true;
                trailing = false
            } else if (isObject(options)) {
                leading = options.leading;
                maxWait = "maxWait" in options && (nativeMax(wait, options.maxWait) || 0);
                trailing = "trailing" in options ? options.trailing : trailing
            }
            var delayed = function() {
                var remaining = wait - (now() - stamp);
                if (remaining <= 0) {
                    if (maxTimeoutId) {
                        clearTimeout(maxTimeoutId)
                    }
                    var isCalled = trailingCall;
                    maxTimeoutId = timeoutId = trailingCall = undefined;
                    if (isCalled) {
                        lastCalled = now();
                        result = func.apply(thisArg, args)
                    }
                } else {
                    timeoutId = setTimeout(delayed, remaining)
                }
            };
            var maxDelayed = function() {
                if (timeoutId) {
                    clearTimeout(timeoutId)
                }
                maxTimeoutId = timeoutId = trailingCall = undefined;
                if (trailing || maxWait !== wait) {
                    lastCalled = now();
                    result = func.apply(thisArg, args)
                }
            };
            return function() {
                args = arguments;
                stamp = now();
                thisArg = this;
                trailingCall = trailing && (timeoutId || !leading);
                if (maxWait === false) {
                    var leadingCall = leading && !timeoutId
                } else {
                    if (!maxTimeoutId && !leading) {
                        lastCalled = stamp
                    }
                    var remaining = maxWait - (stamp - lastCalled);
                    if (remaining <= 0) {
                        if (maxTimeoutId) {
                            maxTimeoutId = clearTimeout(maxTimeoutId)
                        }
                        lastCalled = stamp;
                        result = func.apply(thisArg, args)
                    } else if (!maxTimeoutId) {
                        maxTimeoutId = setTimeout(maxDelayed, remaining)
                    }
                }
                if (!timeoutId && wait !== maxWait) {
                    timeoutId = setTimeout(delayed, wait)
                }
                if (leadingCall) {
                    result = func.apply(thisArg, args)
                }
                return result
            }
        }
        function defer(func) {
            if (!isFunction(func)) {
                throw new TypeError
            }
            var args = nativeSlice.call(arguments, 1);
            return setTimeout(function() {
                func.apply(undefined, args)
            }, 1)
        }
        if (isV8 && moduleExports && typeof setImmediate == "function") {
            defer = function(func) {
                if (!isFunction(func)) {
                    throw new TypeError
                }
                return setImmediate.apply(context, arguments)
            }
        }
        function delay(func, wait) {
            if (!isFunction(func)) {
                throw new TypeError
            }
            var args = nativeSlice.call(arguments, 2);
            return setTimeout(function() {
                func.apply(undefined, args)
            }, wait)
        }
        function memoize(func, resolver) {
            if (!isFunction(func)) {
                throw new TypeError
            }
            var memoized = function() {
                var cache = memoized.cache, key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
                return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments)
            };
            memoized.cache = {};
            return memoized
        }
        function once(func) {
            var ran, result;
            if (!isFunction(func)) {
                throw new TypeError
            }
            return function() {
                if (ran) {
                    return result
                }
                ran = true;
                result = func.apply(this, arguments);
                func = null;
                return result
            }
        }
        function partial(func) {
            return createBound(func, 16, nativeSlice.call(arguments, 1))
        }
        function partialRight(func) {
            return createBound(func, 32, null, nativeSlice.call(arguments, 1))
        }
        function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (!isFunction(func)) {
                throw new TypeError
            }
            if (options === false) {
                leading = false
            } else if (isObject(options)) {
                leading = "leading" in options ? options.leading : leading;
                trailing = "trailing" in options ? options.trailing : trailing
            }
            debounceOptions.leading = leading;
            debounceOptions.maxWait = wait;
            debounceOptions.trailing = trailing;
            var result = debounce(func, wait, debounceOptions);
            return result
        }
        function wrap(value, wrapper) {
            if (!isFunction(wrapper)) {
                throw new TypeError
            }
            return function() {
                var args = [value];
                push.apply(args, arguments);
                return wrapper.apply(this, args)
            }
        }
        function escape(string) {
            return string == null ? "" : String(string).replace(reUnescapedHtml, escapeHtmlChar)
        }
        function identity(value) {
            return value
        }
        function mixin(object, source) {
            var ctor = object, isFunc = !source || isFunction(ctor);
            if (!source) {
                ctor = lodashWrapper;
                source = object;
                object = lodash
            }
            forEach(functions(source), function(methodName) {
                var func = object[methodName] = source[methodName];
                if (isFunc) {
                    ctor.prototype[methodName] = function() {
                        var value = this.__wrapped__, args = [value];
                        push.apply(args, arguments);
                        var result = func.apply(object, args);
                        if (value && typeof value == "object" && value === result) {
                            return this
                        }
                        result = new ctor(result);
                        result.__chain__ = this.__chain__;
                        return result
                    }
                }
            })
        }
        function noConflict() {
            context._ = oldDash;
            return this
        }
        var parseInt = nativeParseInt(whitespace + "08") == 8 ? nativeParseInt : function(value, radix) {
            return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, "") : value, radix || 0)
        };
        function random(min, max, floating) {
            var noMin = min == null, noMax = max == null;
            if (floating == null) {
                if (typeof min == "boolean" && noMax) {
                    floating = min;
                    min = 1
                } else if (!noMax && typeof max == "boolean") {
                    floating = max;
                    noMax = true
                }
            }
            if (noMin && noMax) {
                max = 1
            }
            min = +min || 0;
            if (noMax) {
                max = min;
                min = 0
            } else {
                max = +max || 0
            }
            var rand = nativeRandom();
            return floating || min % 1 || max % 1 ? nativeMin(min + rand * (max - min + parseFloat("1e-" + ((rand + "").length - 1))), max) : min + floor(rand * (max - min + 1))
        }
        function result(object, property) {
            if (object) {
                var value = object[property];
                return isFunction(value) ? object[property]() : value
            }
        }
        function template(text, data, options) {
            var settings = lodash.templateSettings;
            text || (text = "");
            options = defaults({}, options, settings);
            var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
            var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
            text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                interpolateValue || (interpolateValue = esTemplateValue);
                source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                if (escapeValue) {
                    source += "' +\n__e(" + escapeValue + ") +\n'"
                }
                if (evaluateValue) {
                    isEvaluating = true;
                    source += "';\n" + evaluateValue + ";\n__p += '"
                }
                if (interpolateValue) {
                    source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'"
                }
                index = offset + match.length;
                return match
            });
            source += "';\n";
            var variable = options.variable, hasVariable = variable;
            if (!hasVariable) {
                variable = "obj";
                source = "with (" + variable + ") {\n" + source + "\n}\n"
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + variable + ") {\n" + (hasVariable ? "" : variable + " || (" + variable + " = {});\n") + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var sourceURL = "\n/*\n//# sourceURL=" + (options.sourceURL || "/lodash/template/source[" + templateCounter++ + "]") + "\n*/";
            try {
                var result = Function(importsKeys, "return " + source + sourceURL).apply(undefined, importsValues)
            } catch (e) {
                e.source = source;
                throw e
            }
            if (data) {
                return result(data)
            }
            result.source = source;
            return result
        }
        function times(n, callback, thisArg) {
            n = (n = +n) > -1 ? n : 0;
            var index = -1, result = Array(n);
            callback = baseCreateCallback(callback, thisArg, 1);
            while (++index < n) {
                result[index] = callback(index)
            }
            return result
        }
        function unescape(string) {
            return string == null ? "" : String(string).replace(reEscapedHtml, unescapeHtmlChar)
        }
        function uniqueId(prefix) {
            var id = ++idCounter;
            return String(prefix == null ? "" : prefix) + id
        }
        function chain(value) {
            value = new lodashWrapper(value);
            value.__chain__ = true;
            return value
        }
        function tap(value, interceptor) {
            interceptor(value);
            return value
        }
        function wrapperChain() {
            this.__chain__ = true;
            return this
        }
        function wrapperToString() {
            return String(this.__wrapped__)
        }
        function wrapperValueOf() {
            return this.__wrapped__
        }
        lodash.after = after;
        lodash.assign = assign;
        lodash.at = at;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.chain = chain;
        lodash.compact = compact;
        lodash.compose = compose;
        lodash.countBy = countBy;
        lodash.createCallback = createCallback;
        lodash.curry = curry;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.map = map;
        lodash.max = max;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.min = min;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.pull = pull;
        lodash.range = range;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.shuffle = shuffle;
        lodash.sortBy = sortBy;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.values = values;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.collect = map;
        lodash.drop = rest;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        lodash.unzip = zip;
        mixin(lodash);
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.contains = contains;
        lodash.escape = escape;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.has = has;
        lodash.identity = identity;
        lodash.indexOf = indexOf;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isNaN = isNaN;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isUndefined = isUndefined;
        lodash.lastIndexOf = lastIndexOf;
        lodash.mixin = mixin;
        lodash.noConflict = noConflict;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.result = result;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.template = template;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.all = every;
        lodash.any = some;
        lodash.detect = find;
        lodash.findWhere = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.include = contains;
        lodash.inject = reduce;
        forOwn(lodash, function(func, methodName) {
            if (!lodash.prototype[methodName]) {
                lodash.prototype[methodName] = function() {
                    var args = [this.__wrapped__], chainAll = this.__chain__;
                    push.apply(args, arguments);
                    var result = func.apply(lodash, args);
                    return chainAll ? new lodashWrapper(result, chainAll) : result
                }
            }
        });
        lodash.first = first;
        lodash.last = last;
        lodash.sample = sample;
        lodash.take = first;
        lodash.head = first;
        forOwn(lodash, function(func, methodName) {
            var callbackable = methodName !== "sample";
            if (!lodash.prototype[methodName]) {
                lodash.prototype[methodName] = function(n, guard) {
                    var chainAll = this.__chain__, result = func(this.__wrapped__, n, guard);
                    return !chainAll && (n == null || guard && !(callbackable && typeof n == "function")) ? result : new lodashWrapper(result, chainAll)
                }
            }
        });
        lodash.VERSION = "2.2.1";
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.value = wrapperValueOf;
        lodash.prototype.valueOf = wrapperValueOf;
        forEach(["join", "pop", "shift"], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
                var chainAll = this.__chain__, result = func.apply(this.__wrapped__, arguments);
                return chainAll ? new lodashWrapper(result, chainAll) : result
            }
        });
        forEach(["push", "reverse", "sort", "unshift"], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
                func.apply(this.__wrapped__, arguments);
                return this
            }
        });
        forEach(["concat", "slice", "splice"], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
                return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__)
            }
        });
        return lodash
    }
    var _ = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
            return _
        })
    } else if (freeExports && freeModule) {
        if (moduleExports) {
            (freeModule.exports = _)._ = _
        } else {
            freeExports._ = _
        }
    } else {
        root._ = _
    }
}).call(this);
(function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define(["underscore", "jquery", "exports"], function(_, $, exports) {
            root.Backbone = factory(root, exports, _, $)
        })
    } else if (typeof exports !== "undefined") {
        var _ = require("underscore");
        factory(root, exports, _)
    } else {
        root.Backbone = factory(root, {}, root._, root.jQuery || root.Zepto || root.ender || root.$)
    }
})(this, function(root, Backbone, _, $) {
    var previousBackbone = root.Backbone;
    var array = [];
    var push = array.push;
    var slice = array.slice;
    var splice = array.splice;
    Backbone.VERSION = "1.1.2";
    Backbone.$ = $;
    Backbone.noConflict = function() {
        root.Backbone = previousBackbone;
        return this
    };
    Backbone.emulateHTTP = false;
    Backbone.emulateJSON = false;
    var Events = Backbone.Events = {on: function(name, callback, context) {
        if (!eventsApi(this, "on", name, [callback, context]) || !callback)
            return this;
        this._events || (this._events = {});
        var events = this._events[name] || (this._events[name] = []);
        events.push({callback: callback,context: context,ctx: context || this});
        return this
    },once: function(name, callback, context) {
        if (!eventsApi(this, "once", name, [callback, context]) || !callback)
            return this;
        var self = this;
        var once = _.once(function() {
            self.off(name, once);
            callback.apply(this, arguments)
        });
        once._callback = callback;
        return this.on(name, once, context)
    },off: function(name, callback, context) {
        var retain, ev, events, names, i, l, j, k;
        if (!this._events || !eventsApi(this, "off", name, [callback, context]))
            return this;
        if (!name && !callback && !context) {
            this._events = void 0;
            return this
        }
        names = name ? [name] : _.keys(this._events);
        for (i = 0, l = names.length; i < l; i++) {
            name = names[i];
            if (events = this._events[name]) {
                this._events[name] = retain = [];
                if (callback || context) {
                    for (j = 0, k = events.length; j < k; j++) {
                        ev = events[j];
                        if (callback && callback !== ev.callback && callback !== ev.callback._callback || context && context !== ev.context) {
                            retain.push(ev)
                        }
                    }
                }
                if (!retain.length)
                    delete this._events[name]
            }
        }
        return this
    },trigger: function(name) {
        if (!this._events)
            return this;
        var args = slice.call(arguments, 1);
        if (!eventsApi(this, "trigger", name, args))
            return this;
        var events = this._events[name];
        var allEvents = this._events.all;
        if (events)
            triggerEvents(events, args);
        if (allEvents)
            triggerEvents(allEvents, arguments);
        return this
    },stopListening: function(obj, name, callback) {
        var listeningTo = this._listeningTo;
        if (!listeningTo)
            return this;
        var remove = !name && !callback;
        if (!callback && typeof name === "object")
            callback = this;
        if (obj)
            (listeningTo = {})[obj._listenId] = obj;
        for (var id in listeningTo) {
            obj = listeningTo[id];
            obj.off(name, callback, this);
            if (remove || _.isEmpty(obj._events))
                delete this._listeningTo[id]
        }
        return this
    }};
    var eventSplitter = /\s+/;
    var eventsApi = function(obj, action, name, rest) {
        if (!name)
            return true;
        if (typeof name === "object") {
            for (var key in name) {
                obj[action].apply(obj, [key, name[key]].concat(rest))
            }
            return false
        }
        if (eventSplitter.test(name)) {
            var names = name.split(eventSplitter);
            for (var i = 0, l = names.length; i < l; i++) {
                obj[action].apply(obj, [names[i]].concat(rest))
            }
            return false
        }
        return true
    };
    var triggerEvents = function(events, args) {
        var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
        switch (args.length) {
            case 0:
                while (++i < l)
                    (ev = events[i]).callback.call(ev.ctx);
                return;
            case 1:
                while (++i < l)
                    (ev = events[i]).callback.call(ev.ctx, a1);
                return;
            case 2:
                while (++i < l)
                    (ev = events[i]).callback.call(ev.ctx, a1, a2);
                return;
            case 3:
                while (++i < l)
                    (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
                return;
            default:
                while (++i < l)
                    (ev = events[i]).callback.apply(ev.ctx, args);
                return
        }
    };
    var listenMethods = {listenTo: "on",listenToOnce: "once"};
    _.each(listenMethods, function(implementation, method) {
        Events[method] = function(obj, name, callback) {
            var listeningTo = this._listeningTo || (this._listeningTo = {});
            var id = obj._listenId || (obj._listenId = _.uniqueId("l"));
            listeningTo[id] = obj;
            if (!callback && typeof name === "object")
                callback = this;
            obj[implementation](name, callback, this);
            return this
        }
    });
    Events.bind = Events.on;
    Events.unbind = Events.off;
    _.extend(Backbone, Events);
    var Model = Backbone.Model = function(attributes, options) {
        var attrs = attributes || {};
        options || (options = {});
        this.cid = _.uniqueId("c");
        this.attributes = {};
        if (options.collection)
            this.collection = options.collection;
        if (options.parse)
            attrs = this.parse(attrs, options) || {};
        attrs = _.defaults({}, attrs, _.result(this, "defaults"));
        this.set(attrs, options);
        this.changed = {};
        this.initialize.apply(this, arguments)
    };
    _.extend(Model.prototype, Events, {changed: null,validationError: null,idAttribute: "id",initialize: function() {
    },toJSON: function(options) {
        return _.clone(this.attributes)
    },sync: function() {
        return Backbone.sync.apply(this, arguments)
    },get: function(attr) {
        return this.attributes[attr]
    },escape: function(attr) {
        return _.escape(this.get(attr))
    },has: function(attr) {
        return this.get(attr) != null
    },set: function(key, val, options) {
        var attr, attrs, unset, changes, silent, changing, prev, current;
        if (key == null)
            return this;
        if (typeof key === "object") {
            attrs = key;
            options = val
        } else {
            (attrs = {})[key] = val
        }
        options || (options = {});
        if (!this._validate(attrs, options))
            return false;
        unset = options.unset;
        silent = options.silent;
        changes = [];
        changing = this._changing;
        this._changing = true;
        if (!changing) {
            this._previousAttributes = _.clone(this.attributes);
            this.changed = {}
        }
        current = this.attributes, prev = this._previousAttributes;
        if (this.idAttribute in attrs)
            this.id = attrs[this.idAttribute];
        for (attr in attrs) {
            val = attrs[attr];
            if (!_.isEqual(current[attr], val))
                changes.push(attr);
            if (!_.isEqual(prev[attr], val)) {
                this.changed[attr] = val
            } else {
                delete this.changed[attr]
            }
            unset ? delete current[attr] : current[attr] = val
        }
        if (!silent) {
            if (changes.length)
                this._pending = options;
            for (var i = 0, l = changes.length; i < l; i++) {
                this.trigger("change:" + changes[i], this, current[changes[i]], options)
            }
        }
        if (changing)
            return this;
        if (!silent) {
            while (this._pending) {
                options = this._pending;
                this._pending = false;
                this.trigger("change", this, options)
            }
        }
        this._pending = false;
        this._changing = false;
        return this
    },unset: function(attr, options) {
        return this.set(attr, void 0, _.extend({}, options, {unset: true}))
    },clear: function(options) {
        var attrs = {};
        for (var key in this.attributes)
            attrs[key] = void 0;
        return this.set(attrs, _.extend({}, options, {unset: true}))
    },hasChanged: function(attr) {
        if (attr == null)
            return !_.isEmpty(this.changed);
        return _.has(this.changed, attr)
    },changedAttributes: function(diff) {
        if (!diff)
            return this.hasChanged() ? _.clone(this.changed) : false;
        var val, changed = false;
        var old = this._changing ? this._previousAttributes : this.attributes;
        for (var attr in diff) {
            if (_.isEqual(old[attr], val = diff[attr]))
                continue;
            (changed || (changed = {}))[attr] = val
        }
        return changed
    },previous: function(attr) {
        if (attr == null || !this._previousAttributes)
            return null;
        return this._previousAttributes[attr]
    },previousAttributes: function() {
        return _.clone(this._previousAttributes)
    },fetch: function(options) {
        options = options ? _.clone(options) : {};
        if (options.parse === void 0)
            options.parse = true;
        var model = this;
        var success = options.success;
        options.success = function(resp) {
            if (!model.set(model.parse(resp, options), options))
                return false;
            if (success)
                success(model, resp, options);
            model.trigger("sync", model, resp, options)
        };
        wrapError(this, options);
        return this.sync("read", this, options)
    },save: function(key, val, options) {
        var attrs, method, xhr, attributes = this.attributes;
        if (key == null || typeof key === "object") {
            attrs = key;
            options = val
        } else {
            (attrs = {})[key] = val
        }
        options = _.extend({validate: true}, options);
        if (attrs && !options.wait) {
            if (!this.set(attrs, options))
                return false
        } else {
            if (!this._validate(attrs, options))
                return false
        }
        if (attrs && options.wait) {
            this.attributes = _.extend({}, attributes, attrs)
        }
        if (options.parse === void 0)
            options.parse = true;
        var model = this;
        var success = options.success;
        options.success = function(resp) {
            model.attributes = attributes;
            var serverAttrs = model.parse(resp, options);
            if (options.wait)
                serverAttrs = _.extend(attrs || {}, serverAttrs);
            if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
                return false
            }
            if (success)
                success(model, resp, options);
            model.trigger("sync", model, resp, options)
        };
        wrapError(this, options);
        method = this.isNew() ? "create" : options.patch ? "patch" : "update";
        if (method === "patch")
            options.attrs = attrs;
        xhr = this.sync(method, this, options);
        if (attrs && options.wait)
            this.attributes = attributes;
        return xhr
    },destroy: function(options) {
        options = options ? _.clone(options) : {};
        var model = this;
        var success = options.success;
        var destroy = function() {
            model.trigger("destroy", model, model.collection, options)
        };
        options.success = function(resp) {
            if (options.wait || model.isNew())
                destroy();
            if (success)
                success(model, resp, options);
            if (!model.isNew())
                model.trigger("sync", model, resp, options)
        };
        if (this.isNew()) {
            options.success();
            return false
        }
        wrapError(this, options);
        var xhr = this.sync("delete", this, options);
        if (!options.wait)
            destroy();
        return xhr
    },url: function() {
        var base = _.result(this, "urlRoot") || _.result(this.collection, "url") || urlError();
        if (this.isNew())
            return base;
        return base.replace(/([^\/])$/, "$1/") + encodeURIComponent(this.id)
    },parse: function(resp, options) {
        return resp
    },clone: function() {
        return new this.constructor(this.attributes)
    },isNew: function() {
        return !this.has(this.idAttribute)
    },isValid: function(options) {
        return this._validate({}, _.extend(options || {}, {validate: true}))
    },_validate: function(attrs, options) {
        if (!options.validate || !this.validate)
            return true;
        attrs = _.extend({}, this.attributes, attrs);
        var error = this.validationError = this.validate(attrs, options) || null;
        if (!error)
            return true;
        this.trigger("invalid", this, error, _.extend(options, {validationError: error}));
        return false
    }});
    var modelMethods = ["keys", "values", "pairs", "invert", "pick", "omit"];
    _.each(modelMethods, function(method) {
        Model.prototype[method] = function() {
            var args = slice.call(arguments);
            args.unshift(this.attributes);
            return _[method].apply(_, args)
        }
    });
    var Collection = Backbone.Collection = function(models, options) {
        options || (options = {});
        if (options.model)
            this.model = options.model;
        if (options.comparator !== void 0)
            this.comparator = options.comparator;
        this._reset();
        this.initialize.apply(this, arguments);
        if (models)
            this.reset(models, _.extend({silent: true}, options))
    };
    var setOptions = {add: true,remove: true,merge: true};
    var addOptions = {add: true,remove: false};
    _.extend(Collection.prototype, Events, {model: Model,initialize: function() {
    },toJSON: function(options) {
        return this.map(function(model) {
            return model.toJSON(options)
        })
    },sync: function() {
        return Backbone.sync.apply(this, arguments)
    },add: function(models, options) {
        return this.set(models, _.extend({merge: false}, options, addOptions))
    },remove: function(models, options) {
        var singular = !_.isArray(models);
        models = singular ? [models] : _.clone(models);
        options || (options = {});
        var i, l, index, model;
        for (i = 0, l = models.length; i < l; i++) {
            model = models[i] = this.get(models[i]);
            if (!model)
                continue;
            delete this._byId[model.id];
            delete this._byId[model.cid];
            index = this.indexOf(model);
            this.models.splice(index, 1);
            this.length--;
            if (!options.silent) {
                options.index = index;
                model.trigger("remove", model, this, options)
            }
            this._removeReference(model, options)
        }
        return singular ? models[0] : models
    },set: function(models, options) {
        options = _.defaults({}, options, setOptions);
        if (options.parse)
            models = this.parse(models, options);
        var singular = !_.isArray(models);
        models = singular ? models ? [models] : [] : _.clone(models);
        var i, l, id, model, attrs, existing, sort;
        var at = options.at;
        var targetModel = this.model;
        var sortable = this.comparator && at == null && options.sort !== false;
        var sortAttr = _.isString(this.comparator) ? this.comparator : null;
        var toAdd = [], toRemove = [], modelMap = {};
        var add = options.add, merge = options.merge, remove = options.remove;
        var order = !sortable && add && remove ? [] : false;
        for (i = 0, l = models.length; i < l; i++) {
            attrs = models[i] || {};
            if (attrs instanceof Model) {
                id = model = attrs
            } else {
                id = attrs[targetModel.prototype.idAttribute || "id"]
            }
            if (existing = this.get(id)) {
                if (remove)
                    modelMap[existing.cid] = true;
                if (merge) {
                    attrs = attrs === model ? model.attributes : attrs;
                    if (options.parse)
                        attrs = existing.parse(attrs, options);
                    existing.set(attrs, options);
                    if (sortable && !sort && existing.hasChanged(sortAttr))
                        sort = true
                }
                models[i] = existing
            } else if (add) {
                model = models[i] = this._prepareModel(attrs, options);
                if (!model)
                    continue;
                toAdd.push(model);
                this._addReference(model, options)
            }
            model = existing || model;
            if (order && (model.isNew() || !modelMap[model.id]))
                order.push(model);
            modelMap[model.id] = true
        }
        if (remove) {
            for (i = 0, l = this.length; i < l; ++i) {
                if (!modelMap[(model = this.models[i]).cid])
                    toRemove.push(model)
            }
            if (toRemove.length)
                this.remove(toRemove, options)
        }
        if (toAdd.length || order && order.length) {
            if (sortable)
                sort = true;
            this.length += toAdd.length;
            if (at != null) {
                for (i = 0, l = toAdd.length; i < l; i++) {
                    this.models.splice(at + i, 0, toAdd[i])
                }
            } else {
                if (order)
                    this.models.length = 0;
                var orderedModels = order || toAdd;
                for (i = 0, l = orderedModels.length; i < l; i++) {
                    this.models.push(orderedModels[i])
                }
            }
        }
        if (sort)
            this.sort({silent: true});
        if (!options.silent) {
            for (i = 0, l = toAdd.length; i < l; i++) {
                (model = toAdd[i]).trigger("add", model, this, options)
            }
            if (sort || order && order.length)
                this.trigger("sort", this, options)
        }
        return singular ? models[0] : models
    },reset: function(models, options) {
        options || (options = {});
        for (var i = 0, l = this.models.length; i < l; i++) {
            this._removeReference(this.models[i], options)
        }
        options.previousModels = this.models;
        this._reset();
        models = this.add(models, _.extend({silent: true}, options));
        if (!options.silent)
            this.trigger("reset", this, options);
        return models
    },push: function(model, options) {
        return this.add(model, _.extend({at: this.length}, options))
    },pop: function(options) {
        var model = this.at(this.length - 1);
        this.remove(model, options);
        return model
    },unshift: function(model, options) {
        return this.add(model, _.extend({at: 0}, options))
    },shift: function(options) {
        var model = this.at(0);
        this.remove(model, options);
        return model
    },slice: function() {
        return slice.apply(this.models, arguments)
    },get: function(obj) {
        if (obj == null)
            return void 0;
        return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid]
    },at: function(index) {
        return this.models[index]
    },where: function(attrs, first) {
        if (_.isEmpty(attrs))
            return first ? void 0 : [];
        return this[first ? "find" : "filter"](function(model) {
            for (var key in attrs) {
                if (attrs[key] !== model.get(key))
                    return false
            }
            return true
        })
    },findWhere: function(attrs) {
        return this.where(attrs, true)
    },sort: function(options) {
        if (!this.comparator)
            throw new Error("Cannot sort a set without a comparator");
        options || (options = {});
        if (_.isString(this.comparator) || this.comparator.length === 1) {
            this.models = this.sortBy(this.comparator, this)
        } else {
            this.models.sort(_.bind(this.comparator, this))
        }
        if (!options.silent)
            this.trigger("sort", this, options);
        return this
    },pluck: function(attr) {
        return _.invoke(this.models, "get", attr)
    },fetch: function(options) {
        options = options ? _.clone(options) : {};
        if (options.parse === void 0)
            options.parse = true;
        var success = options.success;
        var collection = this;
        options.success = function(resp) {
            var method = options.reset ? "reset" : "set";
            collection[method](resp, options);
            if (success)
                success(collection, resp, options);
            collection.trigger("sync", collection, resp, options)
        };
        wrapError(this, options);
        return this.sync("read", this, options)
    },create: function(model, options) {
        options = options ? _.clone(options) : {};
        if (!(model = this._prepareModel(model, options)))
            return false;
        if (!options.wait)
            this.add(model, options);
        var collection = this;
        var success = options.success;
        options.success = function(model, resp) {
            if (options.wait)
                collection.add(model, options);
            if (success)
                success(model, resp, options)
        };
        model.save(null, options);
        return model
    },parse: function(resp, options) {
        return resp
    },clone: function() {
        return new this.constructor(this.models)
    },_reset: function() {
        this.length = 0;
        this.models = [];
        this._byId = {}
    },_prepareModel: function(attrs, options) {
        if (attrs instanceof Model)
            return attrs;
        options = options ? _.clone(options) : {};
        options.collection = this;
        var model = new this.model(attrs, options);
        if (!model.validationError)
            return model;
        this.trigger("invalid", this, model.validationError, options);
        return false
    },_addReference: function(model, options) {
        this._byId[model.cid] = model;
        if (model.id != null)
            this._byId[model.id] = model;
        if (!model.collection)
            model.collection = this;
        model.on("all", this._onModelEvent, this)
    },_removeReference: function(model, options) {
        if (this === model.collection)
            delete model.collection;
        model.off("all", this._onModelEvent, this)
    },_onModelEvent: function(event, model, collection, options) {
        if ((event === "add" || event === "remove") && collection !== this)
            return;
        if (event === "destroy")
            this.remove(model, options);
        if (model && event === "change:" + model.idAttribute) {
            delete this._byId[model.previous(model.idAttribute)];
            if (model.id != null)
                this._byId[model.id] = model
        }
        this.trigger.apply(this, arguments)
    }});
    var methods = ["forEach", "each", "map", "collect", "reduce", "foldl", "inject", "reduceRight", "foldr", "find", "detect", "filter", "select", "reject", "every", "all", "some", "any", "include", "contains", "invoke", "max", "min", "toArray", "size", "first", "head", "take", "initial", "rest", "tail", "drop", "last", "without", "difference", "indexOf", "shuffle", "lastIndexOf", "isEmpty", "chain", "sample"];
    _.each(methods, function(method) {
        Collection.prototype[method] = function() {
            var args = slice.call(arguments);
            args.unshift(this.models);
            return _[method].apply(_, args)
        }
    });
    var attributeMethods = ["groupBy", "countBy", "sortBy", "indexBy"];
    _.each(attributeMethods, function(method) {
        Collection.prototype[method] = function(value, context) {
            var iterator = _.isFunction(value) ? value : function(model) {
                return model.get(value)
            };
            return _[method](this.models, iterator, context)
        }
    });
    var View = Backbone.View = function(options) {
        this.cid = _.uniqueId("view");
        options || (options = {});
        _.extend(this, _.pick(options, viewOptions));
        this._ensureElement();
        this.initialize.apply(this, arguments);
        this.delegateEvents()
    };
    var delegateEventSplitter = /^(\S+)\s*(.*)$/;
    var viewOptions = ["model", "collection", "el", "id", "attributes", "className", "tagName", "events"];
    _.extend(View.prototype, Events, {tagName: "div",$: function(selector) {
        return this.$el.find(selector)
    },initialize: function() {
    },render: function() {
        return this
    },remove: function() {
        this.$el.remove();
        this.stopListening();
        return this
    },setElement: function(element, delegate) {
        if (this.$el)
            this.undelegateEvents();
        this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
        this.el = this.$el[0];
        if (delegate !== false)
            this.delegateEvents();
        return this
    },delegateEvents: function(events) {
        if (!(events || (events = _.result(this, "events"))))
            return this;
        this.undelegateEvents();
        for (var key in events) {
            var method = events[key];
            if (!_.isFunction(method))
                method = this[events[key]];
            if (!method)
                continue;
            var match = key.match(delegateEventSplitter);
            var eventName = match[1], selector = match[2];
            method = _.bind(method, this);
            eventName += ".delegateEvents" + this.cid;
            if (selector === "") {
                this.$el.on(eventName, method)
            } else {
                this.$el.on(eventName, selector, method)
            }
        }
        return this
    },undelegateEvents: function() {
        this.$el.off(".delegateEvents" + this.cid);
        return this
    },_ensureElement: function() {
        if (!this.el) {
            var attrs = _.extend({}, _.result(this, "attributes"));
            if (this.id)
                attrs.id = _.result(this, "id");
            if (this.className)
                attrs["class"] = _.result(this, "className");
            var $el = Backbone.$("<" + _.result(this, "tagName") + ">").attr(attrs);
            this.setElement($el, false)
        } else {
            this.setElement(_.result(this, "el"), false)
        }
    }});
    Backbone.sync = function(method, model, options) {
        var type = methodMap[method];
        _.defaults(options || (options = {}), {emulateHTTP: Backbone.emulateHTTP,emulateJSON: Backbone.emulateJSON});
        var params = {type: type,dataType: "json"};
        if (!options.url) {
            params.url = _.result(model, "url") || urlError()
        }
        if (options.data == null && model && (method === "create" || method === "update" || method === "patch")) {
            params.contentType = "application/json";
            params.data = JSON.stringify(options.attrs || model.toJSON(options))
        }
        if (options.emulateJSON) {
            params.contentType = "application/x-www-form-urlencoded";
            params.data = params.data ? {model: params.data} : {}
        }
        if (options.emulateHTTP && (type === "PUT" || type === "DELETE" || type === "PATCH")) {
            params.type = "POST";
            if (options.emulateJSON)
                params.data._method = type;
            var beforeSend = options.beforeSend;
            options.beforeSend = function(xhr) {
                xhr.setRequestHeader("X-HTTP-Method-Override", type);
                if (beforeSend)
                    return beforeSend.apply(this, arguments)
            }
        }
        if (params.type !== "GET" && !options.emulateJSON) {
            params.processData = false
        }
        if (params.type === "PATCH" && noXhrPatch) {
            params.xhr = function() {
                return new ActiveXObject("Microsoft.XMLHTTP")
            }
        }
        var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
        model.trigger("request", model, xhr, options);
        return xhr
    };
    var noXhrPatch = typeof window !== "undefined" && !!window.ActiveXObject && !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);
    var methodMap = {create: "POST",update: "PUT",patch: "PATCH","delete": "DELETE",read: "GET"};
    Backbone.ajax = function() {
        return Backbone.$.ajax.apply(Backbone.$, arguments)
    };
    var Router = Backbone.Router = function(options) {
        options || (options = {});
        if (options.routes)
            this.routes = options.routes;
        this._bindRoutes();
        this.initialize.apply(this, arguments)
    };
    var optionalParam = /\((.*?)\)/g;
    var namedParam = /(\(\?)?:\w+/g;
    var splatParam = /\*\w+/g;
    var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
    _.extend(Router.prototype, Events, {initialize: function() {
    },route: function(route, name, callback) {
        if (!_.isRegExp(route))
            route = this._routeToRegExp(route);
        if (_.isFunction(name)) {
            callback = name;
            name = ""
        }
        if (!callback)
            callback = this[name];
        var router = this;
        Backbone.history.route(route, function(fragment) {
            var args = router._extractParameters(route, fragment);
            router.execute(callback, args);
            router.trigger.apply(router, ["route:" + name].concat(args));
            router.trigger("route", name, args);
            Backbone.history.trigger("route", router, name, args)
        });
        return this
    },execute: function(callback, args) {
        if (callback)
            callback.apply(this, args)
    },navigate: function(fragment, options) {
        Backbone.history.navigate(fragment, options);
        return this
    },_bindRoutes: function() {
        if (!this.routes)
            return;
        this.routes = _.result(this, "routes");
        var route, routes = _.keys(this.routes);
        while ((route = routes.pop()) != null) {
            this.route(route, this.routes[route])
        }
    },_routeToRegExp: function(route) {
        route = route.replace(escapeRegExp, "\\$&").replace(optionalParam, "(?:$1)?").replace(namedParam, function(match, optional) {
            return optional ? match : "([^/?]+)"
        }).replace(splatParam, "([^?]*?)");
        return new RegExp("^" + route + "(?:\\?([\\s\\S]*))?$")
    },_extractParameters: function(route, fragment) {
        var params = route.exec(fragment).slice(1);
        return _.map(params, function(param, i) {
            if (i === params.length - 1)
                return param || null;
            return param ? decodeURIComponent(param) : null
        })
    }});
    var History = Backbone.History = function() {
        this.handlers = [];
        _.bindAll(this, "checkUrl");
        if (typeof window !== "undefined") {
            this.location = window.location;
            this.history = window.history
        }
    };
    var routeStripper = /^[#\/]|\s+$/g;
    var rootStripper = /^\/+|\/+$/g;
    var isExplorer = /msie [\w.]+/;
    var trailingSlash = /\/$/;
    var pathStripper = /#.*$/;
    History.started = false;
    _.extend(History.prototype, Events, {interval: 50,atRoot: function() {
        return this.location.pathname.replace(/[^\/]$/, "$&/") === this.root
    },getHash: function(window) {
        var match = (window || this).location.href.match(/#(.*)$/);
        return match ? match[1] : ""
    },getFragment: function(fragment, forcePushState) {
        if (fragment == null) {
            if (this._hasPushState || !this._wantsHashChange || forcePushState) {
                fragment = decodeURI(this.location.pathname + this.location.search);
                var root = this.root.replace(trailingSlash, "");
                if (!fragment.indexOf(root))
                    fragment = fragment.slice(root.length)
            } else {
                fragment = this.getHash()
            }
        }
        return fragment.replace(routeStripper, "")
    },start: function(options) {
        if (History.started)
            throw new Error("Backbone.history has already been started");
        History.started = true;
        this.options = _.extend({root: "/"}, this.options, options);
        this.root = this.options.root;
        this._wantsHashChange = this.options.hashChange !== false;
        this._wantsPushState = !!this.options.pushState;
        this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);
        var fragment = this.getFragment();
        var docMode = document.documentMode;
        var oldIE = isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7);
        this.root = ("/" + this.root + "/").replace(rootStripper, "/");
        if (oldIE && this._wantsHashChange) {
            var frame = Backbone.$('<iframe src="javascript:0" tabindex="-1">');
            this.iframe = frame.hide().appendTo("body")[0].contentWindow;
            this.navigate(fragment)
        }
        if (this._hasPushState) {
            Backbone.$(window).on("popstate", this.checkUrl)
        } else if (this._wantsHashChange && "onhashchange" in window && !oldIE) {
            Backbone.$(window).on("hashchange", this.checkUrl)
        } else if (this._wantsHashChange) {
            this._checkUrlInterval = setInterval(this.checkUrl, this.interval)
        }
        this.fragment = fragment;
        var loc = this.location;
        if (this._wantsHashChange && this._wantsPushState) {
            if (!this._hasPushState && !this.atRoot()) {
                this.fragment = this.getFragment(null, true);
                this.location.replace(this.root + "#" + this.fragment);
                return true
            } else if (this._hasPushState && this.atRoot() && loc.hash) {
                this.fragment = this.getHash().replace(routeStripper, "");
                this.history.replaceState({}, document.title, this.root + this.fragment)
            }
        }
        if (!this.options.silent)
            return this.loadUrl()
    },stop: function() {
        Backbone.$(window).off("popstate", this.checkUrl).off("hashchange", this.checkUrl);
        if (this._checkUrlInterval)
            clearInterval(this._checkUrlInterval);
        History.started = false
    },route: function(route, callback) {
        this.handlers.unshift({route: route,callback: callback})
    },checkUrl: function(e) {
        var current = this.getFragment();
        if (current === this.fragment && this.iframe) {
            current = this.getFragment(this.getHash(this.iframe))
        }
        if (current === this.fragment)
            return false;
        if (this.iframe)
            this.navigate(current);
        this.loadUrl()
    },loadUrl: function(fragment) {
        fragment = this.fragment = this.getFragment(fragment);
        return _.any(this.handlers, function(handler) {
            if (handler.route.test(fragment)) {
                handler.callback(fragment);
                return true
            }
        })
    },navigate: function(fragment, options) {
        if (!History.started)
            return false;
        if (!options || options === true)
            options = {trigger: !!options};
        var url = this.root + (fragment = this.getFragment(fragment || ""));
        fragment = fragment.replace(pathStripper, "");
        if (this.fragment === fragment)
            return;
        this.fragment = fragment;
        if (fragment === "" && url !== "/")
            url = url.slice(0, -1);
        if (this._hasPushState) {
            this.history[options.replace ? "replaceState" : "pushState"]({}, document.title, url)
        } else if (this._wantsHashChange) {
            this._updateHash(this.location, fragment, options.replace);
            if (this.iframe && fragment !== this.getFragment(this.getHash(this.iframe))) {
                if (!options.replace)
                    this.iframe.document.open().close();
                this._updateHash(this.iframe.location, fragment, options.replace)
            }
        } else {
            return this.location.assign(url)
        }
        if (options.trigger)
            return this.loadUrl(fragment)
    },_updateHash: function(location, fragment, replace) {
        if (replace) {
            var href = location.href.replace(/(javascript:|#).*$/, "");
            location.replace(href + "#" + fragment)
        } else {
            location.hash = "#" + fragment
        }
    }});
    Backbone.history = new History;
    var extend = function(protoProps, staticProps) {
        var parent = this;
        var child;
        if (protoProps && _.has(protoProps, "constructor")) {
            child = protoProps.constructor
        } else {
            child = function() {
                return parent.apply(this, arguments)
            }
        }
        _.extend(child, parent, staticProps);
        var Surrogate = function() {
            this.constructor = child
        };
        Surrogate.prototype = parent.prototype;
        child.prototype = new Surrogate;
        if (protoProps)
            _.extend(child.prototype, protoProps);
        child.__super__ = parent.prototype;
        return child
    };
    Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
    var urlError = function() {
        throw new Error('A "url" property or function must be specified')
    };
    var wrapError = function(model, options) {
        var error = options.error;
        options.error = function(resp) {
            if (error)
                error(model, resp, options);
            model.trigger("error", model, resp, options)
        }
    };
    return Backbone
});
(function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define([], factory)
    } else {
        root.Vectorizer = root.V = factory()
    }
})(this, function() {
    var SVGsupported = !!(window.SVGAngle || document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"));
    var ns = {xmlns: "http://www.w3.org/2000/svg",xlink: "http://www.w3.org/1999/xlink"};
    var SVGversion = "1.1";
    var idCounter = 0;
    function uniqueId() {
        var id = ++idCounter + "";
        return "v-" + id
    }
    function createSvgDocument(content) {
        var svg = '<svg xmlns="' + ns.xmlns + '" xmlns:xlink="' + ns.xlink + '" version="' + SVGversion + '">' + (content || "") + "</svg>";
        var parser = new DOMParser;
        parser.async = false;
        return parser.parseFromString(svg, "text/xml").documentElement
    }
    function createElement(el, attrs, children) {
        if (!el)
            return undefined;
        if (typeof el === "object") {
            return new VElement(el)
        }
        attrs = attrs || {};
        if (el.toLowerCase() === "svg") {
            return new VElement(createSvgDocument())
        } else if (el[0] === "<") {
            var svgDoc = createSvgDocument(el);
            if (svgDoc.childNodes.length > 1) {
                var ret = [];
                for (var i = 0, len = svgDoc.childNodes.length; i < len; i++) {
                    var childNode = svgDoc.childNodes[i];
                    ret.push(new VElement(document.importNode(childNode, true)))
                }
                return ret
            }
            return new VElement(document.importNode(svgDoc.firstChild, true))
        }
        el = document.createElementNS(ns.xmlns, el);
        for (var key in attrs) {
            setAttribute(el, key, attrs[key])
        }
        if (Object.prototype.toString.call(children) != "[object Array]")
            children = [children];
        var i = 0, len = children[0] && children.length || 0, child;
        for (; i < len; i++) {
            child = children[i];
            el.appendChild(child instanceof VElement ? child.node : child)
        }
        return new VElement(el)
    }
    function setAttribute(el, name, value) {
        if (name.indexOf(":") > -1) {
            var combinedKey = name.split(":");
            el.setAttributeNS(ns[combinedKey[0]], combinedKey[1], value)
        } else if (name === "id") {
            el.id = value
        } else {
            el.setAttribute(name, value)
        }
    }
    function parseTransformString(transform) {
        var translate, rotate, scale;
        if (transform) {
            var separator = /[ ,]+/;
            var translateMatch = transform.match(/translate\((.*)\)/);
            if (translateMatch) {
                translate = translateMatch[1].split(separator)
            }
            var rotateMatch = transform.match(/rotate\((.*)\)/);
            if (rotateMatch) {
                rotate = rotateMatch[1].split(separator)
            }
            var scaleMatch = transform.match(/scale\((.*)\)/);
            if (scaleMatch) {
                scale = scaleMatch[1].split(separator)
            }
        }
        var sx = scale && scale[0] ? parseFloat(scale[0]) : 1;
        return {translate: {tx: translate && translate[0] ? parseInt(translate[0], 10) : 0,ty: translate && translate[1] ? parseInt(translate[1], 10) : 0},rotate: {angle: rotate && rotate[0] ? parseInt(rotate[0], 10) : 0,cx: rotate && rotate[1] ? parseInt(rotate[1], 10) : undefined,cy: rotate && rotate[2] ? parseInt(rotate[2], 10) : undefined},scale: {sx: sx,sy: scale && scale[1] ? parseFloat(scale[1]) : sx}}
    }
    function deltaTransformPoint(matrix, point) {
        var dx = point.x * matrix.a + point.y * matrix.c + 0;
        var dy = point.x * matrix.b + point.y * matrix.d + 0;
        return {x: dx,y: dy}
    }
    function decomposeMatrix(matrix) {
        var px = deltaTransformPoint(matrix, {x: 0,y: 1});
        var py = deltaTransformPoint(matrix, {x: 1,y: 0});
        var skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90;
        var skewY = 180 / Math.PI * Math.atan2(py.y, py.x);
        return {translateX: matrix.e,translateY: matrix.f,scaleX: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),scaleY: Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d),skewX: skewX,skewY: skewY,rotation: skewX}
    }
    function VElement(el) {
        this.node = el;
        if (!this.node.id) {
            this.node.id = uniqueId()
        }
    }
    VElement.prototype = {translate: function(tx, ty, opt) {
        opt = opt || {};
        ty = ty || 0;
        var transformAttr = this.attr("transform") || "", transform = parseTransformString(transformAttr);
        if (typeof tx === "undefined") {
            return transform.translate
        }
        transformAttr = transformAttr.replace(/translate\([^\)]*\)/g, "").trim();
        var newTx = opt.absolute ? tx : transform.translate.tx + tx, newTy = opt.absolute ? ty : transform.translate.ty + ty, newTranslate = "translate(" + newTx + "," + newTy + ")";
        this.attr("transform", (newTranslate + " " + transformAttr).trim());
        return this
    },rotate: function(angle, cx, cy, opt) {
        opt = opt || {};
        var transformAttr = this.attr("transform") || "", transform = parseTransformString(transformAttr);
        if (typeof angle === "undefined") {
            return transform.rotate
        }
        transformAttr = transformAttr.replace(/rotate\([^\)]*\)/g, "").trim();
        angle %= 360;
        var newAngle = opt.absolute ? angle : transform.rotate.angle + angle, newOrigin = cx !== undefined && cy !== undefined ? "," + cx + "," + cy : "", newRotate = "rotate(" + newAngle + newOrigin + ")";
        this.attr("transform", (transformAttr + " " + newRotate).trim());
        return this
    },scale: function(sx, sy) {
        sy = typeof sy === "undefined" ? sx : sy;
        var transformAttr = this.attr("transform") || "", transform = parseTransformString(transformAttr);
        if (typeof sx === "undefined") {
            return transform.scale
        }
        transformAttr = transformAttr.replace(/scale\([^\)]*\)/g, "").trim();
        var newScale = "scale(" + sx + "," + sy + ")";
        this.attr("transform", (transformAttr + " " + newScale).trim());
        return this
    },bbox: function(withoutTransformations, target) {
        if (!this.node.ownerSVGElement)
            return {x: 0,y: 0,width: 0,height: 0};
        var box;
        try {
            box = this.node.getBBox();
            box = {x: box.x | 0,y: box.y | 0,width: box.width | 0,height: box.height | 0}
        } catch (e) {
            box = {x: this.node.clientLeft,y: this.node.clientTop,width: this.node.clientWidth,height: this.node.clientHeight}
        }
        if (withoutTransformations) {
            return box
        }
        var matrix = this.node.getTransformToElement(target || this.node.ownerSVGElement);
        return V.transformRect(box, matrix)
    },text: function(content, opt) {
        opt = opt || {};
        var lines = content.split("\n");
        var i = 0;
        var tspan;
        this.attr("y", "0.8em");
        this.attr("display", content ? null : "none");
        this.node.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
        this.node.textContent = "";
        var textNode = this.node;
        if (opt.textPath) {
            var defs = this.find("defs");
            if (defs.length === 0) {
                defs = createElement("defs");
                this.append(defs)
            }
            var d = Object(opt.textPath) === opt.textPath ? opt.textPath.d : opt.textPath;
            if (d) {
                var path = createElement("path", {d: d});
                defs.append(path)
            }
            var textPath = createElement("textPath");
            if (!opt.textPath["xlink:href"] && path) {
                textPath.attr("xlink:href", "#" + path.node.id)
            }
            if (Object(opt.textPath) === opt.textPath) {
                textPath.attr(opt.textPath)
            }
            this.append(textPath);
            textNode = textPath.node
        }
        if (lines.length === 1) {
            textNode.textContent = content;
            return this
        }
        for (; i < lines.length; i++) {
            tspan = V("tspan", {dy: i == 0 ? "0em" : opt.lineHeight || "1em",x: this.attr("x") || 0});
            tspan.addClass("line");
            if (!lines[i]) {
                tspan.addClass("empty-line")
            }
            tspan.node.textContent = lines[i] || " ";
            V(textNode).append(tspan)
        }
        return this
    },attr: function(name, value) {
        if (typeof name === "string" && typeof value === "undefined") {
            return this.node.getAttribute(name)
        }
        if (typeof name === "object") {
            for (var attrName in name) {
                if (name.hasOwnProperty(attrName)) {
                    setAttribute(this.node, attrName, name[attrName])
                }
            }
        } else {
            setAttribute(this.node, name, value)
        }
        return this
    },remove: function() {
        if (this.node.parentNode) {
            this.node.parentNode.removeChild(this.node)
        }
    },append: function(el) {
        var els = el;
        if (Object.prototype.toString.call(el) !== "[object Array]") {
            els = [el]
        }
        for (var i = 0, len = els.length; i < len; i++) {
            el = els[i];
            this.node.appendChild(el instanceof VElement ? el.node : el)
        }
        return this
    },prepend: function(el) {
        this.node.insertBefore(el instanceof VElement ? el.node : el, this.node.firstChild)
    },svg: function() {
        return this.node instanceof window.SVGSVGElement ? this : V(this.node.ownerSVGElement)
    },defs: function() {
        var defs = this.svg().node.getElementsByTagName("defs");
        return defs && defs.length ? V(defs[0]) : undefined
    },clone: function() {
        var clone = V(this.node.cloneNode(true));
        clone.node.id = uniqueId();
        return clone
    },findOne: function(selector) {
        var found = this.node.querySelector(selector);
        return found ? V(found) : undefined
    },find: function(selector) {
        var nodes = this.node.querySelectorAll(selector);
        for (var i = 0, len = nodes.length; i < len; i++) {
            nodes[i] = V(nodes[i])
        }
        return nodes
    },toLocalPoint: function(x, y) {
        var svg = this.svg().node;
        var p = svg.createSVGPoint();
        p.x = x;
        p.y = y;
        try {
            var globalPoint = p.matrixTransform(svg.getScreenCTM().inverse());
            var globalToLocalMatrix = this.node.getTransformToElement(svg).inverse()
        } catch (e) {
            return p
        }
        return globalPoint.matrixTransform(globalToLocalMatrix)
    },translateCenterToPoint: function(p) {
        var bbox = this.bbox();
        var center = g.rect(bbox).center();
        this.translate(p.x - center.x, p.y - center.y)
    },translateAndAutoOrient: function(position, reference, target) {
        var s = this.scale();
        this.attr("transform", "");
        this.scale(s.sx, s.sy);
        var svg = this.svg().node;
        var bbox = this.bbox(false, target);
        var translateToOrigin = svg.createSVGTransform();
        translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);
        var rotateAroundOrigin = svg.createSVGTransform();
        var angle = g.point(position).changeInAngle(position.x - reference.x, position.y - reference.y, reference);
        rotateAroundOrigin.setRotate(angle, 0, 0);
        var translateFinal = svg.createSVGTransform();
        var finalPosition = g.point(position).move(reference, bbox.width / 2);
        translateFinal.setTranslate(position.x + (position.x - finalPosition.x), position.y + (position.y - finalPosition.y));
        var ctm = this.node.getTransformToElement(target);
        var transform = svg.createSVGTransform();
        transform.setMatrix(translateFinal.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm))));
        var decomposition = decomposeMatrix(transform.matrix);
        this.translate(decomposition.translateX, decomposition.translateY);
        this.rotate(decomposition.rotation);
        return this
    },animateAlongPath: function(attrs, path) {
        var animateMotion = V("animateMotion", attrs);
        var mpath = V("mpath", {"xlink:href": "#" + V(path).node.id});
        animateMotion.append(mpath);
        this.append(animateMotion);
        try {
            animateMotion.node.beginElement()
        } catch (e) {
            if (document.documentElement.getAttribute("smiling") === "fake") {
                var animation = animateMotion.node;
                animation.animators = [];
                var animationID = animation.getAttribute("id");
                if (animationID)
                    id2anim[animationID] = animation;
                var targets = getTargets(animation);
                for (var i = 0, len = targets.length; i < len; i++) {
                    var target = targets[i];
                    var animator = new Animator(animation, target, i);
                    animators.push(animator);
                    animation.animators[i] = animator;
                    animator.register()
                }
            }
        }
    },hasClass: function(className) {
        return new RegExp("(\\s|^)" + className + "(\\s|$)").test(this.node.getAttribute("class"))
    },addClass: function(className) {
        if (!this.hasClass(className)) {
            var prevClasses = this.node.getAttribute("class") || "";
            this.node.setAttribute("class", (prevClasses + " " + className).trim())
        }
        return this
    },removeClass: function(className) {
        if (this.hasClass(className)) {
            var newClasses = this.node.getAttribute("class").replace(new RegExp("(\\s|^)" + className + "(\\s|$)", "g"), "$2");
            this.node.setAttribute("class", newClasses)
        }
        return this
    },toggleClass: function(className, toAdd) {
        var toRemove = typeof toAdd === "undefined" ? this.hasClass(className) : !toAdd;
        if (toRemove) {
            this.removeClass(className)
        } else {
            this.addClass(className)
        }
        return this
    }};
    function rectToPath(r) {
        var topRx = r.rx || r["top-rx"] || 0;
        var bottomRx = r.rx || r["bottom-rx"] || 0;
        var topRy = r.ry || r["top-ry"] || 0;
        var bottomRy = r.ry || r["bottom-ry"] || 0;
        return ["M", r.x, r.y + topRy, "v", r.height - topRy - bottomRy, "a", bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy, "h", r.width - 2 * bottomRx, "a", bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy, "v", -(r.height - bottomRy - topRy), "a", topRx, topRy, 0, 0, 0, -topRx, -topRy, "h", -(r.width - 2 * topRx), "a", topRx, topRy, 0, 0, 0, -topRx, topRy].join(" ")
    }
    var V = createElement;
    V.decomposeMatrix = decomposeMatrix;
    V.rectToPath = rectToPath;
    var svgDocument = V("svg").node;
    V.createSVGMatrix = function(m) {
        var svgMatrix = svgDocument.createSVGMatrix();
        for (var component in m) {
            svgMatrix[component] = m[component]
        }
        return svgMatrix
    };
    V.createSVGTransform = function() {
        return svgDocument.createSVGTransform()
    };
    V.createSVGPoint = function(x, y) {
        var p = svgDocument.createSVGPoint();
        p.x = x;
        p.y = y;
        return p
    };
    V.transformRect = function(r, matrix) {
        var p = svgDocument.createSVGPoint();
        p.x = r.x;
        p.y = r.y;
        var corner1 = p.matrixTransform(matrix);
        p.x = r.x + r.width;
        p.y = r.y;
        var corner2 = p.matrixTransform(matrix);
        p.x = r.x + r.width;
        p.y = r.y + r.height;
        var corner3 = p.matrixTransform(matrix);
        p.x = r.x;
        p.y = r.y + r.height;
        var corner4 = p.matrixTransform(matrix);
        var minX = Math.min(corner1.x, corner2.x, corner3.x, corner4.x);
        var maxX = Math.max(corner1.x, corner2.x, corner3.x, corner4.x);
        var minY = Math.min(corner1.y, corner2.y, corner3.y, corner4.y);
        var maxY = Math.max(corner1.y, corner2.y, corner3.y, corner4.y);
        return {x: minX,y: minY,width: maxX - minX,height: maxY - minY}
    };
    return V
});
(function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define([], factory)
    } else if (typeof exports === "object") {
        module.exports = factory()
    } else {
        root.g = factory()
    }
})(this, function() {
    var math = Math;
    var abs = math.abs;
    var cos = math.cos;
    var sin = math.sin;
    var sqrt = math.sqrt;
    var mmin = math.min;
    var mmax = math.max;
    var atan = math.atan;
    var atan2 = math.atan2;
    var acos = math.acos;
    var round = math.round;
    var floor = math.floor;
    var PI = math.PI;
    var random = math.random;
    var toDeg = function(rad) {
        return 180 * rad / PI % 360
    };
    var toRad = function(deg, over360) {
        over360 = over360 || false;
        deg = over360 ? deg : deg % 360;
        return deg * PI / 180
    };
    var snapToGrid = function(val, gridSize) {
        return gridSize * Math.round(val / gridSize)
    };
    var normalizeAngle = function(angle) {
        return angle % 360 + (angle < 0 ? 360 : 0)
    };
    function point(x, y) {
        if (!(this instanceof point))
            return new point(x, y);
        var xy;
        if (y === undefined && Object(x) !== x) {
            xy = x.split(x.indexOf("@") === -1 ? " " : "@");
            this.x = parseInt(xy[0], 10);
            this.y = parseInt(xy[1], 10)
        } else if (Object(x) === x) {
            this.x = x.x;
            this.y = x.y
        } else {
            this.x = x;
            this.y = y
        }
    }
    point.prototype = {toString: function() {
        return this.x + "@" + this.y
    },adhereToRect: function(r) {
        if (r.containsPoint(this)) {
            return this
        }
        this.x = mmin(mmax(this.x, r.x), r.x + r.width);
        this.y = mmin(mmax(this.y, r.y), r.y + r.height);
        return this
    },theta: function(p) {
        p = point(p);
        var y = -(p.y - this.y);
        var x = p.x - this.x;
        var PRECISION = 10;
        var rad = y.toFixed(PRECISION) == 0 && x.toFixed(PRECISION) == 0 ? 0 : atan2(y, x);
        if (rad < 0) {
            rad = 2 * PI + rad
        }
        return 180 * rad / PI
    },distance: function(p) {
        return line(this, p).length()
    },manhattanDistance: function(p) {
        return abs(p.x - this.x) + abs(p.y - this.y)
    },offset: function(dx, dy) {
        this.x += dx || 0;
        this.y += dy || 0;
        return this
    },magnitude: function() {
        return sqrt(this.x * this.x + this.y * this.y) || .01
    },update: function(x, y) {
        this.x = x || 0;
        this.y = y || 0;
        return this
    },round: function(decimals) {
        this.x = decimals ? this.x.toFixed(decimals) : round(this.x);
        this.y = decimals ? this.y.toFixed(decimals) : round(this.y);
        return this
    },normalize: function(len) {
        var s = (len || 1) / this.magnitude();
        this.x = s * this.x;
        this.y = s * this.y;
        return this
    },difference: function(p) {
        return point(this.x - p.x, this.y - p.y)
    },bearing: function(p) {
        return line(this, p).bearing()
    },toPolar: function(o) {
        o = o && point(o) || point(0, 0);
        var x = this.x;
        var y = this.y;
        this.x = sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y));
        this.y = toRad(o.theta(point(x, y)));
        return this
    },rotate: function(o, angle) {
        angle = (angle + 360) % 360;
        this.toPolar(o);
        this.y += toRad(angle);
        var p = point.fromPolar(this.x, this.y, o);
        this.x = p.x;
        this.y = p.y;
        return this
    },move: function(ref, distance) {
        var theta = toRad(point(ref).theta(this));
        return this.offset(cos(theta) * distance, -sin(theta) * distance)
    },changeInAngle: function(dx, dy, ref) {
        return point(this).offset(-dx, -dy).theta(ref) - this.theta(ref)
    },equals: function(p) {
        return this.x === p.x && this.y === p.y
    },snapToGrid: function(gx, gy) {
        this.x = snapToGrid(this.x, gx);
        this.y = snapToGrid(this.y, gy || gx);
        return this
    },reflection: function(ref) {
        return point(ref).move(this, this.distance(ref))
    }};
    point.fromPolar = function(r, angle, o) {
        o = o && point(o) || point(0, 0);
        var x = abs(r * cos(angle));
        var y = abs(r * sin(angle));
        var deg = normalizeAngle(toDeg(angle));
        if (deg < 90)
            y = -y;
        else if (deg < 180) {
            x = -x;
            y = -y
        } else if (deg < 270)
            x = -x;
        return point(o.x + x, o.y + y)
    };
    point.random = function(x1, x2, y1, y2) {
        return point(floor(random() * (x2 - x1 + 1) + x1), floor(random() * (y2 - y1 + 1) + y1))
    };
    function line(p1, p2) {
        if (!(this instanceof line))
            return new line(p1, p2);
        this.start = point(p1);
        this.end = point(p2)
    }
    line.prototype = {toString: function() {
        return this.start.toString() + " " + this.end.toString()
    },length: function() {
        return sqrt(this.squaredLength())
    },squaredLength: function() {
        var x0 = this.start.x;
        var y0 = this.start.y;
        var x1 = this.end.x;
        var y1 = this.end.y;
        return (x0 -= x1) * x0 + (y0 -= y1) * y0
    },midpoint: function() {
        return point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2)
    },intersection: function(l) {
        var pt1Dir = point(this.end.x - this.start.x, this.end.y - this.start.y);
        var pt2Dir = point(l.end.x - l.start.x, l.end.y - l.start.y);
        var det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;
        var deltaPt = point(l.start.x - this.start.x, l.start.y - this.start.y);
        var alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;
        var beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;
        if (det === 0 || alpha * det < 0 || beta * det < 0) {
            return null
        }
        if (det > 0) {
            if (alpha > det || beta > det) {
                return null
            }
        } else {
            if (alpha < det || beta < det) {
                return null
            }
        }
        return point(this.start.x + alpha * pt1Dir.x / det, this.start.y + alpha * pt1Dir.y / det)
    },bearing: function() {
        var lat1 = toRad(this.start.y);
        var lat2 = toRad(this.end.y);
        var lon1 = this.start.x;
        var lon2 = this.end.x;
        var dLon = toRad(lon2 - lon1);
        var y = sin(dLon) * cos(lat2);
        var x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon);
        var brng = toDeg(atan2(y, x));
        var bearings = ["NE", "E", "SE", "S", "SW", "W", "NW", "N"];
        var index = brng - 22.5;
        if (index < 0)
            index += 360;
        index = parseInt(index / 45);
        return bearings[index]
    },pointAt: function(t) {
        var x = (1 - t) * this.start.x + t * this.end.x;
        var y = (1 - t) * this.start.y + t * this.end.y;
        return point(x, y)
    }};
    function rect(x, y, w, h) {
        if (!(this instanceof rect))
            return new rect(x, y, w, h);
        if (y === undefined) {
            y = x.y;
            w = x.width;
            h = x.height;
            x = x.x
        }
        this.x = x;
        this.y = y;
        this.width = w;
        this.height = h
    }
    rect.prototype = {toString: function() {
        return this.origin().toString() + " " + this.corner().toString()
    },origin: function() {
        return point(this.x, this.y)
    },corner: function() {
        return point(this.x + this.width, this.y + this.height)
    },topRight: function() {
        return point(this.x + this.width, this.y)
    },bottomLeft: function() {
        return point(this.x, this.y + this.height)
    },center: function() {
        return point(this.x + this.width / 2, this.y + this.height / 2)
    },intersect: function(r) {
        var myOrigin = this.origin();
        var myCorner = this.corner();
        var rOrigin = r.origin();
        var rCorner = r.corner();
        if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y)
            return false;
        return true
    },sideNearestToPoint: function(p) {
        p = point(p);
        var distToLeft = p.x - this.x;
        var distToRight = this.x + this.width - p.x;
        var distToTop = p.y - this.y;
        var distToBottom = this.y + this.height - p.y;
        var closest = distToLeft;
        var side = "left";
        if (distToRight < closest) {
            closest = distToRight;
            side = "right"
        }
        if (distToTop < closest) {
            closest = distToTop;
            side = "top"
        }
        if (distToBottom < closest) {
            closest = distToBottom;
            side = "bottom"
        }
        return side
    },containsPoint: function(p) {
        p = point(p);
        if (p.x >= this.x && p.x <= this.x + this.width && p.y >= this.y && p.y <= this.y + this.height) {
            return true
        }
        return false
    },containsRect: function(r) {
        var nr = rect(r).normalize();
        var W = nr.width;
        var H = nr.height;
        var X = nr.x;
        var Y = nr.y;
        var w = this.width;
        var h = this.height;
        if ((w | h | W | H) < 0) {
            return false
        }
        var x = this.x;
        var y = this.y;
        if (X < x || Y < y) {
            return false
        }
        w += x;
        W += X;
        if (W <= X) {
            if (w >= x || W > w)
                return false
        } else {
            if (w >= x && W > w)
                return false
        }
        h += y;
        H += Y;
        if (H <= Y) {
            if (h >= y || H > h)
                return false
        } else {
            if (h >= y && H > h)
                return false
        }
        return true
    },pointNearestToPoint: function(p) {
        p = point(p);
        if (this.containsPoint(p)) {
            var side = this.sideNearestToPoint(p);
            switch (side) {
                case "right":
                    return point(this.x + this.width, p.y);
                case "left":
                    return point(this.x, p.y);
                case "bottom":
                    return point(p.x, this.y + this.height);
                case "top":
                    return point(p.x, this.y)
            }
        }
        return p.adhereToRect(this)
    },intersectionWithLineFromCenterToPoint: function(p, angle) {
        p = point(p);
        var center = point(this.x + this.width / 2, this.y + this.height / 2);
        var result;
        if (angle)
            p.rotate(center, angle);
        var sides = [line(this.origin(), this.topRight()), line(this.topRight(), this.corner()), line(this.corner(), this.bottomLeft()), line(this.bottomLeft(), this.origin())];
        var connector = line(center, p);
        for (var i = sides.length - 1; i >= 0; --i) {
            var intersection = sides[i].intersection(connector);
            if (intersection !== null) {
                result = intersection;
                break
            }
        }
        if (result && angle)
            result.rotate(center, -angle);
        return result
    },moveAndExpand: function(r) {
        this.x += r.x;
        this.y += r.y;
        this.width += r.width;
        this.height += r.height;
        return this
    },round: function(decimals) {
        this.x = decimals ? this.x.toFixed(decimals) : round(this.x);
        this.y = decimals ? this.y.toFixed(decimals) : round(this.y);
        this.width = decimals ? this.width.toFixed(decimals) : round(this.width);
        this.height = decimals ? this.height.toFixed(decimals) : round(this.height);
        return this
    },normalize: function() {
        var newx = this.x;
        var newy = this.y;
        var newwidth = this.width;
        var newheight = this.height;
        if (this.width < 0) {
            newx = this.x + this.width;
            newwidth = -this.width
        }
        if (this.height < 0) {
            newy = this.y + this.height;
            newheight = -this.height
        }
        this.x = newx;
        this.y = newy;
        this.width = newwidth;
        this.height = newheight;
        return this
    },bbox: function(angle) {
        var theta = toRad(angle || 0);
        var st = abs(sin(theta));
        var ct = abs(cos(theta));
        var w = this.width * ct + this.height * st;
        var h = this.width * st + this.height * ct;
        return rect(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h)
    }};
    function ellipse(c, a, b) {
        if (!(this instanceof ellipse))
            return new ellipse(c, a, b);
        c = point(c);
        this.x = c.x;
        this.y = c.y;
        this.a = a;
        this.b = b
    }
    ellipse.prototype = {toString: function() {
        return point(this.x, this.y).toString() + " " + this.a + " " + this.b
    },bbox: function() {
        return rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b)
    },intersectionWithLineFromCenterToPoint: function(p, angle) {
        p = point(p);
        if (angle)
            p.rotate(point(this.x, this.y), angle);
        var dx = p.x - this.x;
        var dy = p.y - this.y;
        var result;
        if (dx === 0) {
            result = this.bbox().pointNearestToPoint(p);
            if (angle)
                return result.rotate(point(this.x, this.y), -angle);
            return result
        }
        var m = dy / dx;
        var mSquared = m * m;
        var aSquared = this.a * this.a;
        var bSquared = this.b * this.b;
        var x = sqrt(1 / (1 / aSquared + mSquared / bSquared));
        x = dx < 0 ? -x : x;
        var y = m * x;
        result = point(this.x + x, this.y + y);
        if (angle)
            return result.rotate(point(this.x, this.y), -angle);
        return result
    }};
    var bezier = {curveThroughPoints: function(points) {
        var controlPoints = this.getCurveControlPoints(points);
        var path = ["M", points[0].x, points[0].y];
        for (var i = 0; i < controlPoints[0].length; i++) {
            path.push("C", controlPoints[0][i].x, controlPoints[0][i].y, controlPoints[1][i].x, controlPoints[1][i].y, points[i + 1].x, points[i + 1].y)
        }
        return path
    },getCurveControlPoints: function(knots) {
        var firstControlPoints = [];
        var secondControlPoints = [];
        var n = knots.length - 1;
        var i;
        if (n == 1) {
            firstControlPoints[0] = point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);
            secondControlPoints[0] = point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);
            return [firstControlPoints, secondControlPoints]
        }
        var rhs = [];
        for (i = 1; i < n - 1; i++) {
            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x
        }
        rhs[0] = knots[0].x + 2 * knots[1].x;
        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2;
        var x = this.getFirstControlPoints(rhs);
        for (i = 1; i < n - 1; ++i) {
            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y
        }
        rhs[0] = knots[0].y + 2 * knots[1].y;
        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2;
        var y = this.getFirstControlPoints(rhs);
        for (i = 0; i < n; i++) {
            firstControlPoints.push(point(x[i], y[i]));
            if (i < n - 1) {
                secondControlPoints.push(point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]))
            } else {
                secondControlPoints.push(point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2))
            }
        }
        return [firstControlPoints, secondControlPoints]
    },getFirstControlPoints: function(rhs) {
        var n = rhs.length;
        var x = [];
        var tmp = [];
        var b = 2;
        x[0] = rhs[0] / b;
        for (var i = 1; i < n; i++) {
            tmp[i] = 1 / b;
            b = (i < n - 1 ? 4 : 3.5) - tmp[i];
            x[i] = (rhs[i] - x[i - 1]) / b
        }
        for (i = 1; i < n; i++) {
            x[n - i - 1] -= tmp[n - i] * x[n - i]
        }
        return x
    },getInversionSolver: function(p0, p1, p2, p3) {
        var pts = arguments;
        function l(i, j) {
            var pi = pts[i], pj = pts[j];
            return function(p) {
                var w = (i % 3 ? 3 : 1) * (j % 3 ? 3 : 1);
                var lij = p.x * (pi.y - pj.y) + p.y * (pj.x - pi.x) + pi.x * pj.y - pi.y * pj.x;
                return w * lij
            }
        }
        return function solveInversion(p) {
            var ct = 3 * l(2, 3)(p1);
            var c1 = l(1, 3)(p0) / ct;
            var c2 = -l(2, 3)(p0) / ct;
            var la = c1 * l(3, 1)(p) + c2 * (l(3, 0)(p) + l(2, 1)(p)) + l(2, 0)(p);
            var lb = c1 * l(3, 0)(p) + c2 * l(2, 0)(p) + l(1, 0)(p);
            return lb / (lb - la)
        }
    },getCurveDivider: function(p0, p1, p2, p3) {
        return function divideCurve(t) {
            var l = line(p0, p1).pointAt(t);
            var m = line(p1, p2).pointAt(t);
            var n = line(p2, p3).pointAt(t);
            var p = line(l, m).pointAt(t);
            var q = line(m, n).pointAt(t);
            var r = line(p, q).pointAt(t);
            return [{p0: p0,p1: l,p2: p,p3: r}, {p0: r,p1: q,p2: n,p3: p3}]
        }
    }};
    var scale = {linear: function(domain, range, value) {
        var domainSpan = domain[1] - domain[0];
        var rangeSpan = range[1] - range[0];
        return (value - domain[0]) / domainSpan * rangeSpan + range[0] || 0
    }};
    return {toDeg: toDeg,toRad: toRad,snapToGrid: snapToGrid,normalizeAngle: normalizeAngle,point: point,line: line,rect: rect,ellipse: ellipse,bezier: bezier,scale: scale}
});
if (typeof exports === "object") {
    var _ = require("lodash")
}


var joint = {version: "0.9.3",dia: {},ui: {},layout: {},shapes: {},format: {},connectors: {},routers: {},util: {hashCode: function(str) {
    var hash = 0;
    if (str.length == 0)
        return hash;
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        hash = (hash << 5) - hash + c;
        hash = hash & hash
    }
    return hash
},getByPath: function(obj, path, delim) {
    delim = delim || ".";
    var keys = path.split(delim);
    var key;
    while (keys.length) {
        key = keys.shift();
        if (Object(obj) === obj && key in obj) {
            obj = obj[key]
        } else {
            return undefined
        }
    }
    return obj
},setByPath: function(obj, path, value, delim) {
    delim = delim || ".";
    var keys = path.split(delim);
    var diver = obj;
    var i = 0;
    if (path.indexOf(delim) > -1) {
        for (var len = keys.length; i < len - 1; i++) {
            diver = diver[keys[i]] || (diver[keys[i]] = {})
        }
        diver[keys[len - 1]] = value
    } else {
        obj[path] = value
    }
    return obj
},unsetByPath: function(obj, path, delim) {
    delim = delim || ".";
    var i = path.lastIndexOf(delim);
    if (i > -1) {
        var parent = joint.util.getByPath(obj, path.substr(0, i), delim);
        if (parent) {
            delete parent[path.slice(i + 1)]
        }
    } else {
        delete obj[path]
    }
    return obj
},flattenObject: function(obj, delim, stop) {
    delim = delim || ".";
    var ret = {};
    for (var key in obj) {
        if (!obj.hasOwnProperty(key))
            continue;
        var shouldGoDeeper = typeof obj[key] === "object";
        if (shouldGoDeeper && stop && stop(obj[key])) {
            shouldGoDeeper = false
        }
        if (shouldGoDeeper) {
            var flatObject = this.flattenObject(obj[key], delim, stop);
            for (var flatKey in flatObject) {
                if (!flatObject.hasOwnProperty(flatKey))
                    continue;
                ret[key + delim + flatKey] = flatObject[flatKey]
            }
        } else {
            ret[key] = obj[key]
        }
    }
    return ret
},uuid: function() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
        return v.toString(16)
    })
},guid: function(obj) {
    this.guid.id = this.guid.id || 1;
    obj.id = obj.id === undefined ? "j_" + this.guid.id++ : obj.id;
    return obj.id
},mixin: function() {
    var target = arguments[0];
    for (var i = 1, l = arguments.length; i < l; i++) {
        var extension = arguments[i];
        if (Object(extension) !== extension && !_.isFunction(extension) && (extension === null || extension === undefined)) {
            continue
        }
        _.each(extension, function(copy, key) {
            if (this.mixin.deep && Object(copy) === copy) {
                if (!target[key]) {
                    target[key] = _.isArray(copy) ? [] : {}
                }
                this.mixin(target[key], copy);
                return
            }
            if (target[key] !== copy) {
                if (!this.mixin.supplement || !target.hasOwnProperty(key)) {
                    target[key] = copy
                }
            }
        }, this)
    }
    return target
},supplement: function() {
    this.mixin.supplement = true;
    var ret = this.mixin.apply(this, arguments);
    this.mixin.supplement = false;
    return ret
},deepMixin: function() {
    this.mixin.deep = true;
    var ret = this.mixin.apply(this, arguments);
    this.mixin.deep = false;
    return ret
},deepSupplement: function() {
    this.mixin.deep = this.mixin.supplement = true;
    var ret = this.mixin.apply(this, arguments);
    this.mixin.deep = this.mixin.supplement = false;
    return ret
},normalizeEvent: function(evt) {
    return evt.originalEvent && evt.originalEvent.changedTouches && evt.originalEvent.changedTouches.length ? evt.originalEvent.changedTouches[0] : evt
},nextFrame: function() {
    var raf;
    var client = typeof window != "undefined";
    if (client) {
        raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame
    }
    if (!raf) {
        var lastTime = 0;
        raf = function(callback) {
            var currTime = (new Date).getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = setTimeout(function() {
                callback(currTime + timeToCall)
            }, timeToCall);
            lastTime = currTime + timeToCall;
            return id
        }
    }
    return client ? _.bind(raf, window) : raf
}(),cancelFrame: function() {
    var caf;
    var client = typeof window != "undefined";
    if (client) {
        caf = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame || window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame
    }
    caf = caf || clearTimeout;
    return client ? _.bind(caf, window) : caf
}(),findIntersection: function(node, ref) {
    var bbox = g.rect(V(node).bbox()).moveAndExpand(g.rect(-5, -5, 10, 10));
    var center = bbox.center();
    var spot = g.rect(bbox).intersectionWithLineFromCenterToPoint(ref);
    if (!spot)
        return undefined;
    if (!_.contains(["PATH", "CIRCLE", "ELLIPSE", "RECT", "POLYGON", "LINE", "POLYLINE"], node.localName.toUpperCase())) {
        return spot
    }
    if (!node.isPointInStroke || !node.isPointInFill) {
        return spot
    }
    var lastSpot = spot;
    var ctm = node.getCTM();
    var svgPoint = V.createSVGPoint(0, 0);
    var dist = spot.distance(center);
    while (dist > 1) {
        spot = spot.move(center, -1);
        dist = spot.distance(center);
        svgPoint.x = spot.x;
        svgPoint.y = spot.y;
        svgPoint = svgPoint.matrixTransform(ctm.inverse());
        if (node.isPointInStroke(svgPoint) || node.isPointInFill(svgPoint)) {
            return lastSpot
        }
        lastSpot = g.point(spot)
    }
    return undefined
},shapePerimeterConnectionPoint: function(linkView, view, magnet, reference) {
    var bbox = g.rect(view.getBBox());
    var spot;
    if (!magnet) {
        var scalable = view.$(".scalable")[0];
        var rotatable = view.$(".rotatable")[0];
        if (scalable && scalable.firstChild) {
            magnet = scalable.firstChild
        } else if (rotatable && rotatable.firstChild) {
            magnet = rotatable.firstChild
        }
    }
    if (magnet) {
        spot = joint.util.findIntersection(magnet, reference)
    } else {
        spot = bbox.intersectionWithLineFromCenterToPoint(reference)
    }
    return spot || bbox.center()
},breakText: function(text, size, styles, opt) {
    opt = opt || {};
    var width = size.width;
    var height = size.height;
    var svgDocument = opt.svgDocument || V("svg").node;
    var textElement = V("<text><tspan></tspan></text>").attr(styles || {}).node;
    var textSpan = textElement.firstChild;
    var textNode = document.createTextNode("");
    textSpan.appendChild(textNode);
    svgDocument.appendChild(textElement);
    if (!opt.svgDocument) {
        document.body.appendChild(svgDocument)
    }
    var words = text.split(" ");
    var full = [];
    var lines = [];
    var p;
    for (var i = 0, l = 0, len = words.length; i < len; i++) {
        var word = words[i];
        textNode.data = lines[l] ? lines[l] + " " + word : word;
        if (textSpan.getComputedTextLength() <= width) {
            lines[l] = textNode.data;
            if (p) {
                full[l++] = true;
                p = 0
            }
        } else {
            if (!lines[l] || p) {
                var partition = !!p;
                p = word.length - 1;
                if (partition || !p) {
                    if (!p) {
                        if (!lines[l]) {
                            lines = [];
                            break
                        }
                        words.splice(i, 2, word + words[i + 1]);
                        len--;
                        full[l++] = true;
                        i--;
                        continue
                    }
                    words[i] = word.substring(0, p);
                    words[i + 1] = word.substring(p) + words[i + 1]
                } else {
                    words.splice(i, 1, word.substring(0, p), word.substring(p));
                    len++;
                    if (l && !full[l - 1]) {
                        l--
                    }
                }
                i--;
                continue
            }
            l++;
            i--
        }
        if (typeof height !== "undefined") {
            var lh = lh || textElement.getBBox().height * 1.25;
            if (lh * lines.length > height) {
                lines.splice(Math.floor(height / lh));
                break
            }
        }
    }
    if (opt.svgDocument) {
        svgDocument.removeChild(textElement)
    } else {
        document.body.removeChild(svgDocument)
    }
    return lines.join("\n")
},imageToDataUri: function(url, callback) {
    if (!url || url.substr(0, "data:".length) === "data:") {
        return setTimeout(function() {
            callback(null, url)
        }, 0)
    }
    var canvas = document.createElement("canvas");
    var img = document.createElement("img");
    img.onload = function() {
        var ctx = canvas.getContext("2d");
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        try {
            var suffix = url.split(".").pop() || "png";
            var type = "image/" + (suffix === "jpg") ? "jpeg" : suffix;
            var dataUri = canvas.toDataURL(type)
        } catch (e) {
            if (/\.svg$/.test(url)) {
                var xhr = window.XMLHttpRequest ? new XMLHttpRequest : new ActiveXObject("Microsoft.XMLHTTP");
                xhr.open("GET", url, false);
                xhr.send(null);
                var svg = xhr.responseText;
                return callback(null, "data:image/svg+xml," + encodeURIComponent(svg))
            }
            console.error(img.src, "fails to convert", e)
        }
        callback(null, dataUri)
    };
    img.ononerror = function() {
        callback(new Error("Failed to load image."))
    };
    img.src = url
},timing: {linear: function(t) {
    return t
},quad: function(t) {
    return t * t
},cubic: function(t) {
    return t * t * t
},inout: function(t) {
    if (t <= 0)
        return 0;
    if (t >= 1)
        return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75)
},exponential: function(t) {
    return Math.pow(2, 10 * (t - 1))
},bounce: function(t) {
    for (var a = 0, b = 1; 1; a += b, b /= 2) {
        if (t >= (7 - 4 * a) / 11) {
            var q = (11 - 6 * a - 11 * t) / 4;
            return -q * q + b * b
        }
    }
},reverse: function(f) {
    return function(t) {
        return 1 - f(1 - t)
    }
},reflect: function(f) {
    return function(t) {
        return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t))
    }
},clamp: function(f, n, x) {
    n = n || 0;
    x = x || 1;
    return function(t) {
        var r = f(t);
        return r < n ? n : r > x ? x : r
    }
},back: function(s) {
    if (!s)
        s = 1.70158;
    return function(t) {
        return t * t * ((s + 1) * t - s)
    }
},elastic: function(x) {
    if (!x)
        x = 1.5;
    return function(t) {
        return Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t)
    }
}},interpolate: {number: function(a, b) {
    var d = b - a;
    return function(t) {
        return a + d * t
    }
},object: function(a, b) {
    var s = _.keys(a);
    return function(t) {
        var i, p, r = {};
        for (i = s.length - 1; i != -1; i--) {
            p = s[i];
            r[p] = a[p] + (b[p] - a[p]) * t
        }
        return r
    }
},hexColor: function(a, b) {
    var ca = parseInt(a.slice(1), 16), cb = parseInt(b.slice(1), 16);
    var ra = ca & 255, rd = (cb & 255) - ra;
    var ga = ca & 65280, gd = (cb & 65280) - ga;
    var ba = ca & 16711680, bd = (cb & 16711680) - ba;
    return function(t) {
        var r = ra + rd * t & 255;
        var g = ga + gd * t & 65280;
        var b = ba + bd * t & 16711680;
        return "#" + (1 << 24 | r | g | b).toString(16).slice(1)
    }
},unit: function(a, b) {
    var r = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;
    var ma = r.exec(a), mb = r.exec(b);
    var p = mb[1].indexOf("."), f = p > 0 ? mb[1].length - p - 1 : 0;
    var a = +ma[1], d = +mb[1] - a, u = ma[2];
    return function(t) {
        return (a + d * t).toFixed(f) + u
    }
}},filter: {blur: function(args) {
    var x = _.isFinite(args.x) ? args.x : 2;
    return _.template('<filter><feGaussianBlur stdDeviation="${stdDeviation}"/></filter>', {stdDeviation: _.isFinite(args.y) ? [x, args.y] : x})
},dropShadow: function(args) {
    var tpl = "SVGFEDropShadowElement" in window ? '<filter><feDropShadow stdDeviation="${blur}" dx="${dx}" dy="${dy}" flood-color="${color}" flood-opacity="${opacity}"/></filter>' : '<filter><feGaussianBlur in="SourceAlpha" stdDeviation="${blur}"/><feOffset dx="${dx}" dy="${dy}" result="offsetblur"/><feFlood flood-color="${color}"/><feComposite in2="offsetblur" operator="in"/><feComponentTransfer><feFuncA type="linear" slope="${opacity}"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
    return _.template(tpl, {dx: args.dx || 0,dy: args.dy || 0,opacity: _.isFinite(args.opacity) ? args.opacity : 1,color: args.color || "black",blur: _.isFinite(args.blur) ? args.blur : 4})
},grayscale: function(args) {
    var amount = _.isFinite(args.amount) ? args.amount : 1;
    return _.template('<filter><feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0"/></filter>', {a: .2126 + .7874 * (1 - amount),b: .7152 - .7152 * (1 - amount),c: .0722 - .0722 * (1 - amount),d: .2126 - .2126 * (1 - amount),e: .7152 + .2848 * (1 - amount),f: .0722 - .0722 * (1 - amount),g: .2126 - .2126 * (1 - amount),h: .0722 + .9278 * (1 - amount)})
},sepia: function(args) {
    var amount = _.isFinite(args.amount) ? args.amount : 1;
    return _.template('<filter><feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0"/></filter>', {a: .393 + .607 * (1 - amount),b: .769 - .769 * (1 - amount),c: .189 - .189 * (1 - amount),d: .349 - .349 * (1 - amount),e: .686 + .314 * (1 - amount),f: .168 - .168 * (1 - amount),g: .272 - .272 * (1 - amount),h: .534 - .534 * (1 - amount),i: .131 + .869 * (1 - amount)})
},saturate: function(args) {
    var amount = _.isFinite(args.amount) ? args.amount : 1;
    return _.template('<filter><feColorMatrix type="saturate" values="${amount}"/></filter>', {amount: 1 - amount})
},hueRotate: function(args) {
    return _.template('<filter><feColorMatrix type="hueRotate" values="${angle}"/></filter>', {angle: args.angle || 0})
},invert: function(args) {
    var amount = _.isFinite(args.amount) ? args.amount : 1;
    return _.template('<filter><feComponentTransfer><feFuncR type="table" tableValues="${amount} ${amount2}"/><feFuncG type="table" tableValues="${amount} ${amount2}"/><feFuncB type="table" tableValues="${amount} ${amount2}"/></feComponentTransfer></filter>', {amount: amount,amount2: 1 - amount})
},brightness: function(args) {
    return _.template('<filter><feComponentTransfer><feFuncR type="linear" slope="${amount}"/><feFuncG type="linear" slope="${amount}"/><feFuncB type="linear" slope="${amount}"/></feComponentTransfer></filter>', {amount: _.isFinite(args.amount) ? args.amount : 1})
},contrast: function(args) {
    var amount = _.isFinite(args.amount) ? args.amount : 1;
    return _.template('<filter><feComponentTransfer><feFuncR type="linear" slope="${amount}" intercept="${amount2}"/><feFuncG type="linear" slope="${amount}" intercept="${amount2}"/><feFuncB type="linear" slope="${amount}" intercept="${amount2}"/></feComponentTransfer></filter>', {amount: amount,amount2: .5 - amount / 2})
}},format: {number: function(specifier, value, locale) {
    locale = locale || {currency: ["$", ""],decimal: ".",thousands: ",",grouping: [3]};
    var re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
    var match = re.exec(specifier);
    var fill = match[1] || " ";
    var align = match[2] || ">";
    var sign = match[3] || "";
    var symbol = match[4] || "";
    var zfill = match[5];
    var width = +match[6];
    var comma = match[7];
    var precision = match[8];
    var type = match[9];
    var scale = 1;
    var prefix = "";
    var suffix = "";
    var integer = false;
    if (precision)
        precision = +precision.substring(1);
    if (zfill || fill === "0" && align === "=") {
        zfill = fill = "0";
        align = "=";
        if (comma)
            width -= Math.floor((width - 1) / 4)
    }
    switch (type) {
        case "n":
            comma = true;
            type = "g";
            break;
        case "%":
            scale = 100;
            suffix = "%";
            type = "f";
            break;
        case "p":
            scale = 100;
            suffix = "%";
            type = "r";
            break;
        case "b":
        case "o":
        case "x":
        case "X":
            if (symbol === "#")
                prefix = "0" + type.toLowerCase();
        case "c":
        case "d":
            integer = true;
            precision = 0;
            break;
        case "s":
            scale = -1;
            type = "r";
            break
    }
    if (symbol === "$") {
        prefix = locale.currency[0];
        suffix = locale.currency[1]
    }
    if (type == "r" && !precision)
        type = "g";
    if (precision != null) {
        if (type == "g")
            precision = Math.max(1, Math.min(21, precision));
        else if (type == "e" || type == "f")
            precision = Math.max(0, Math.min(20, precision))
    }
    var zcomma = zfill && comma;
    if (integer && value % 1)
        return "";
    var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign;
    var fullSuffix = suffix;
    if (scale < 0) {
        var unit = this.prefix(value, precision);
        value = unit.scale(value);
        fullSuffix = unit.symbol + suffix
    } else {
        value *= scale
    }
    value = this.convert(type, value, precision);
    var i = value.lastIndexOf(".");
    var before = i < 0 ? value : value.substring(0, i);
    var after = i < 0 ? "" : locale.decimal + value.substring(i + 1);
    function formatGroup(value) {
        var i = value.length;
        var t = [];
        var j = 0;
        var g = locale.grouping[0];
        while (i > 0 && g > 0) {
            t.push(value.substring(i -= g, i + g));
            g = locale.grouping[j = (j + 1) % locale.grouping.length]
        }
        return t.reverse().join(locale.thousands)
    }
    if (!zfill && comma && locale.grouping) {
        before = formatGroup(before)
    }
    var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length);
    var padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
    if (zcomma)
        before = formatGroup(padding + before);
    negative += prefix;
    value = before + after;
    return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix
},string: function(formatString, value) {
    var fieldDelimiterIndex;
    var fieldDelimiter = "{";
    var endPlaceholder = false;
    var formattedStringArray = [];
    while ((fieldDelimiterIndex = formatString.indexOf(fieldDelimiter)) !== -1) {
        var pieceFormatedString, formatSpec, fieldName;
        pieceFormatedString = formatString.slice(0, fieldDelimiterIndex);
        if (endPlaceholder) {
            formatSpec = pieceFormatedString.split(":");
            fieldName = formatSpec.shift().split(".");
            pieceFormatedString = value;
            for (var i = 0; i < fieldName.length; i++)
                pieceFormatedString = pieceFormatedString[fieldName[i]];
            if (formatSpec.length)
                pieceFormatedString = this.number(formatSpec, pieceFormatedString)
        }
        formattedStringArray.push(pieceFormatedString);
        formatString = formatString.slice(fieldDelimiterIndex + 1);
        fieldDelimiter = (endPlaceholder = !endPlaceholder) ? "}" : "{"
    }
    formattedStringArray.push(formatString);
    return formattedStringArray.join("")
},convert: function(type, value, precision) {
    switch (type) {
        case "b":
            return value.toString(2);
        case "c":
            return String.fromCharCode(value);
        case "o":
            return value.toString(8);
        case "x":
            return value.toString(16);
        case "X":
            return value.toString(16).toUpperCase();
        case "g":
            return value.toPrecision(precision);
        case "e":
            return value.toExponential(precision);
        case "f":
            return value.toFixed(precision);
        case "r":
            return (value = this.round(value, this.precision(value, precision))).toFixed(Math.max(0, Math.min(20, this.precision(value * (1 + 1e-15), precision))));
        default:
            return value + ""
    }
},round: function(value, precision) {
    return precision ? Math.round(value * (precision = Math.pow(10, precision))) / precision : Math.round(value)
},precision: function(value, precision) {
    return precision - (value ? Math.ceil(Math.log(value) / Math.LN10) : 1)
},prefix: function(value, precision) {
    var prefixes = _.map(["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"], function(d, i) {
        var k = Math.pow(10, abs(8 - i) * 3);
        return {scale: i > 8 ? function(d) {
            return d / k
        } : function(d) {
            return d * k
        },symbol: d}
    });
    var i = 0;
    if (value) {
        if (value < 0)
            value *= -1;
        if (precision)
            value = this.round(value, this.precision(value, precision));
        i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
        i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3))
    }
    return prefixes[8 + i / 3]
}}}};


if (typeof exports === "object") {
    module.exports = joint
}
if (typeof exports === "object") {
    var joint = {dia: {Link: require("./joint.dia.link").Link,Element: require("./joint.dia.element").Element},shapes: require("../plugins/shapes")};
    var Backbone = require("backbone");
    var _ = require("lodash");
    var g = require("./geometry")
}


joint.dia.GraphCells = Backbone.Collection.extend({initialize: function() {
    this.on("change:z", this.sort, this)
},model: function(attrs, options) {
    if (attrs.type === "link") {
        return new joint.dia.Link(attrs, options)
    }
    var module = attrs.type.split(".")[0];
    var entity = attrs.type.split(".")[1];
    if (joint.shapes[module] && joint.shapes[module][entity]) {
        return new joint.shapes[module][entity](attrs, options)
    }
    return new joint.dia.Element(attrs, options)
},comparator: function(model) {
    return model.get("z") || 0
},getConnectedLinks: function(model, opt) {
    opt = opt || {};
    if (_.isUndefined(opt.inbound) && _.isUndefined(opt.outbound)) {
        opt.inbound = opt.outbound = true
    }
    var links = this.filter(function(cell) {
        var source = cell.get("source");
        var target = cell.get("target");
        return source && source.id === model.id && opt.outbound || target && target.id === model.id && opt.inbound
    });
    if (opt.deep) {
        var embeddedCells = model.getEmbeddedCells({deep: true});
        _.each(this.difference(links, embeddedCells), function(cell) {
            if (opt.outbound) {
                var source = cell.get("source");
                if (source && source.id && _.find(embeddedCells, {id: source.id})) {
                    links.push(cell);
                    return
                }
            }
            if (opt.inbound) {
                var target = cell.get("target");
                if (target && target.id && _.find(embeddedCells, {id: target.id})) {
                    links.push(cell)
                }
            }
        })
    }
    return links
},getCommonAncestor: function() {
    var cellsAncestors = _.map(arguments, function(cell) {
        var ancestors = [cell.id];
        var parentId = cell.get("parent");
        while (parentId) {
            ancestors.push(parentId);
            parentId = this.get(parentId).get("parent")
        }
        return ancestors
    }, this);
    cellsAncestors = _.sortBy(cellsAncestors, "length");
    var commonAncestor = _.find(cellsAncestors.shift(), function(ancestor) {
        return _.every(cellsAncestors, function(cellAncestors) {
            return _.contains(cellAncestors, ancestor)
        })
    });
    return this.get(commonAncestor)
}});
joint.dia.Graph = Backbone.Model.extend({initialize: function(attrs, opt) {
    this.set("cells", new joint.dia.GraphCells([], {model: opt && opt.cellModel}));
    this.get("cells").on("all", this.trigger, this);
    this.get("cells").on("remove", this.removeCell, this)
},toJSON: function() {
    var json = Backbone.Model.prototype.toJSON.apply(this, arguments);
    json.cells = this.get("cells").toJSON();
    return json
},fromJSON: function(json, opt) {
    if (!json.cells) {
        throw new Error("Graph JSON must contain cells array.")
    }
    this.set(_.omit(json, "cells"), opt);
    this.resetCells(json.cells, opt)
},clear: function(opt) {
    this.trigger("batch:start");
    this.get("cells").remove(this.get("cells").models, opt);
    this.trigger("batch:stop")
},_prepareCell: function(cell) {
    if (cell instanceof Backbone.Model && _.isUndefined(cell.get("z"))) {
        cell.set("z", this.maxZIndex() + 1, {silent: true})
    } else if (_.isUndefined(cell.z)) {
        cell.z = this.maxZIndex() + 1
    }
    return cell
},maxZIndex: function() {
    var lastCell = this.get("cells").last();
    return lastCell ? lastCell.get("z") || 0 : 0
},addCell: function(cell, options) {
    if (_.isArray(cell)) {
        return this.addCells(cell, options)
    }
    this.get("cells").add(this._prepareCell(cell), options || {});
    return this
},addCells: function(cells, options) {
    options = options || {};
    options.position = cells.length;
    _.each(cells, function(cell) {
        options.position--;
        this.addCell(cell, options)
    }, this);
    return this
},resetCells: function(cells, opt) {
    this.get("cells").reset(_.map(cells, this._prepareCell, this), opt);
    return this
},removeCell: function(cell, collection, options) {
    if (options && options.disconnectLinks) {
        this.disconnectLinks(cell, options)
    } else {
        this.removeLinks(cell, options)
    }
    this.get("cells").remove(cell, {silent: true})
},getCell: function(id) {
    return this.get("cells").get(id)
},getElements: function() {
    return this.get("cells").filter(function(cell) {
        return cell instanceof joint.dia.Element
    })
},getLinks: function() {
    return this.get("cells").filter(function(cell) {
        return cell instanceof joint.dia.Link
    })
},getConnectedLinks: function(model, opt) {
    return this.get("cells").getConnectedLinks(model, opt)
},getNeighbors: function(el) {
    var links = this.getConnectedLinks(el);
    var neighbors = [];
    var cells = this.get("cells");
    _.each(links, function(link) {
        var source = link.get("source");
        var target = link.get("target");
        if (!source.x) {
            var sourceElement = cells.get(source.id);
            if (sourceElement !== el) {
                neighbors.push(sourceElement)
            }
        }
        if (!target.x) {
            var targetElement = cells.get(target.id);
            if (targetElement !== el) {
                neighbors.push(targetElement)
            }
        }
    });
    return neighbors
},disconnectLinks: function(model, options) {
    _.each(this.getConnectedLinks(model), function(link) {
        link.set(link.get("source").id === model.id ? "source" : "target", g.point(0, 0), options)
    })
},removeLinks: function(model, options) {
    _.invoke(this.getConnectedLinks(model), "remove", options)
},findModelsFromPoint: function(p) {
    return _.filter(this.getElements(), function(el) {
        return el.getBBox().containsPoint(p)
    })
},findModelsInArea: function(r) {
    return _.filter(this.getElements(), function(el) {
        return el.getBBox().intersect(r)
    })
},getBBox: function(elements) {
    var origin = {x: Infinity,y: Infinity};
    var corner = {x: 0,y: 0};
    _.each(elements, function(cell) {
        var bbox = cell.getBBox();
        origin.x = Math.min(origin.x, bbox.x);
        origin.y = Math.min(origin.y, bbox.y);
        corner.x = Math.max(corner.x, bbox.x + bbox.width);
        corner.y = Math.max(corner.y, bbox.y + bbox.height)
    });
    return g.rect(origin.x, origin.y, corner.x - origin.x, corner.y - origin.y)
},getCommonAncestor: function() {
    var collection = this.get("cells");
    return collection.getCommonAncestor.apply(collection, arguments)
}});


if (typeof exports === "object") {
    module.exports.Graph = joint.dia.Graph
}
if (typeof exports === "object") {
    var joint = {util: require("./core").util,dia: {Link: require("./joint.dia.link").Link}};
    var Backbone = require("backbone");
    var _ = require("lodash")
}


joint.dia.Cell = Backbone.Model.extend({constructor: function(attributes, options) {
    var defaults;
    var attrs = attributes || {};
    this.cid = _.uniqueId("c");
    this.attributes = {};
    if (options && options.collection)
        this.collection = options.collection;
    if (options && options.parse)
        attrs = this.parse(attrs, options) || {};
    if (defaults = _.result(this, "defaults")) {
        attrs = _.merge({}, defaults, attrs)
    }
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments)
},toJSON: function() {
    var defaultAttrs = this.constructor.prototype.defaults.attrs || {};
    var attrs = this.attributes.attrs;
    var finalAttrs = {};
    _.each(attrs, function(attr, selector) {
        var defaultAttr = defaultAttrs[selector];
        _.each(attr, function(value, name) {
            if (_.isObject(value) && !_.isArray(value)) {
                _.each(value, function(value2, name2) {
                    if (!defaultAttr || !defaultAttr[name] || !_.isEqual(defaultAttr[name][name2], value2)) {
                        finalAttrs[selector] = finalAttrs[selector] || {};
                        (finalAttrs[selector][name] || (finalAttrs[selector][name] = {}))[name2] = value2
                    }
                })
            } else if (!defaultAttr || !_.isEqual(defaultAttr[name], value)) {
                finalAttrs[selector] = finalAttrs[selector] || {};
                finalAttrs[selector][name] = value
            }
        })
    });
    var attributes = _.cloneDeep(_.omit(this.attributes, "attrs"));
    attributes.attrs = finalAttrs;
    return attributes
},initialize: function(options) {
    if (!options || !options.id) {
        this.set("id", joint.util.uuid(), {silent: true})
    }
    this._transitionIds = {};
    this.processPorts();
    this.on("change:attrs", this.processPorts, this)
},processPorts: function() {
    var previousPorts = this.ports;
    var ports = {};
    _.each(this.get("attrs"), function(attrs, selector) {
        if (attrs && attrs.port) {
            if (!_.isUndefined(attrs.port.id)) {
                ports[attrs.port.id] = attrs.port
            } else {
                ports[attrs.port] = {id: attrs.port}
            }
        }
    });
    var removedPorts = {};
    _.each(previousPorts, function(port, id) {
        if (!ports[id])
            removedPorts[id] = true
    });
    if (this.collection && !_.isEmpty(removedPorts)) {
        var inboundLinks = this.collection.getConnectedLinks(this, {inbound: true});
        _.each(inboundLinks, function(link) {
            if (removedPorts[link.get("target").port])
                link.remove()
        });
        var outboundLinks = this.collection.getConnectedLinks(this, {outbound: true});
        _.each(outboundLinks, function(link) {
            if (removedPorts[link.get("source").port])
                link.remove()
        })
    }
    this.ports = ports
},remove: function(options) {
    var collection = this.collection;
    if (collection) {
        collection.trigger("batch:start")
    }
    var parentCellId = this.get("parent");
    if (parentCellId) {
        var parentCell = this.collection && this.collection.get(parentCellId);
        parentCell.unembed(this)
    }
    _.invoke(this.getEmbeddedCells(), "remove", options);
    this.trigger("remove", this, this.collection, options);
    if (collection) {
        collection.trigger("batch:stop")
    }
    return this
},toFront: function(opt) {
    if (this.collection) {
        opt = opt || {};
        var z = (this.collection.last().get("z") || 0) + 1;
        this.trigger("batch:start").set("z", z, opt);
        if (opt.deep) {
            var cells = this.getEmbeddedCells({deep: true,breadthFirst: true});
            _.each(cells, function(cell) {
                cell.set("z", ++z, opt)
            })
        }
        this.trigger("batch:stop")
    }
    return this
},toBack: function(opt) {
    if (this.collection) {
        opt = opt || {};
        var z = (this.collection.first().get("z") || 0) - 1;
        this.trigger("batch:start");
        if (opt.deep) {
            var cells = this.getEmbeddedCells({deep: true,breadthFirst: true});
            _.eachRight(cells, function(cell) {
                cell.set("z", z--, opt)
            })
        }
        this.set("z", z, opt).trigger("batch:stop")
    }
    return this
},embed: function(cell, opt) {
    if (this == cell || this.isEmbeddedIn(cell)) {
        throw new Error("Recursive embedding not allowed.")
    } else {
        this.trigger("batch:start");
        var embeds = _.clone(this.get("embeds") || []);
        embeds[cell.isLink() ? "unshift" : "push"](cell.id);
        cell.set("parent", this.id, opt);
        this.set("embeds", _.uniq(embeds), opt);
        this.trigger("batch:stop")
    }
    return this
},unembed: function(cell, opt) {
    this.trigger("batch:start");
    cell.unset("parent", opt);
    this.set("embeds", _.without(this.get("embeds"), cell.id), opt);
    this.trigger("batch:stop");
    return this
},getEmbeddedCells: function(opt) {
    opt = opt || {};
    if (this.collection) {
        var cells;
        if (opt.deep) {
            if (opt.breadthFirst) {
                cells = [];
                var queue = this.getEmbeddedCells();
                while (queue.length > 0) {
                    var parent = queue.shift();
                    cells.push(parent);
                    queue.push.apply(queue, parent.getEmbeddedCells())
                }
            } else {
                cells = this.getEmbeddedCells();
                _.each(cells, function(cell) {
                    cells.push.apply(cells, cell.getEmbeddedCells(opt))
                })
            }
        } else {
            cells = _.map(this.get("embeds"), this.collection.get, this.collection)
        }
        return cells
    }
    return []
},isEmbeddedIn: function(cell, opt) {
    var cellId = _.isString(cell) ? cell : cell.id;
    opt = _.defaults({deep: true}, opt);
    var parentId = this.get("parent");
    if (this.collection && opt.deep) {
        while (parentId) {
            if (parentId == cellId) {
                return true
            }
            parentId = this.collection.get(parentId).get("parent")
        }
        return false
    } else {
        return parentId == cellId
    }
},clone: function(opt) {
    opt = opt || {};
    var clone = Backbone.Model.prototype.clone.apply(this, arguments);
    clone.set("id", joint.util.uuid(), {silent: true});
    clone.set("embeds", "");
    if (!opt.deep)
        return clone;
    var embeds = _.sortBy(this.getEmbeddedCells(), function(cell) {
        return cell instanceof joint.dia.Element
    });
    var clones = [clone];
    var linkCloneMapping = {};
    _.each(embeds, function(embed) {
        var embedClones = embed.clone({deep: true});
        clone.embed(embedClones[0]);
        _.each(embedClones, function(embedClone) {
            if (embedClone instanceof joint.dia.Link) {
                if (embedClone.get("source").id == this.id) {
                    embedClone.prop("source", {id: clone.id})
                }
                if (embedClone.get("target").id == this.id) {
                    embedClone.prop("target", {id: clone.id})
                }
                linkCloneMapping[embed.id] = embedClone;
                return
            }
            clones.push(embedClone);
            var inboundLinks = this.collection.getConnectedLinks(embed, {inbound: true});
            _.each(inboundLinks, function(link) {
                var linkClone = linkCloneMapping[link.id] || link.clone();
                linkCloneMapping[link.id] = linkClone;
                linkClone.prop("target", {id: embedClone.id})
            });
            var outboundLinks = this.collection.getConnectedLinks(embed, {outbound: true});
            _.each(outboundLinks, function(link) {
                var linkClone = linkCloneMapping[link.id] || link.clone();
                linkCloneMapping[link.id] = linkClone;
                linkClone.prop("source", {id: embedClone.id})
            })
        }, this)
    }, this);
    clones = clones.concat(_.values(linkCloneMapping));
    return clones
},prop: function(props, value, opt) {
    var delim = "/";
    if (_.isString(props)) {
        if (typeof value !== "undefined") {
            var path = props;
            var pathArray = path.split("/");
            var property = pathArray[0];
            opt = opt || {};
            opt.propertyPath = path;
            opt.propertyValue = value;
            if (pathArray.length == 1) {
                return this.set(property, value, opt)
            }
            var update = {};
            var initializer = update;
            var prevProperty = property;
            _.each(_.rest(pathArray), function(key) {
                initializer = initializer[prevProperty] = _.isFinite(Number(key)) ? [] : {};
                prevProperty = key
            });
            update = joint.util.setByPath(update, path, value, "/");
            var baseAttributes = _.merge({}, this.attributes);
            opt.rewrite && joint.util.unsetByPath(baseAttributes, path, "/");
            var attributes = _.merge(baseAttributes, update);
            return this.set(property, attributes[property], opt)
        } else {
            return joint.util.getByPath(this.attributes, props, delim)
        }
    }
    return this.set(_.merge({}, this.attributes, props), value)
},attr: function(attrs, value, opt) {
    if (_.isString(attrs)) {
        return this.prop("attrs/" + attrs, value, opt)
    }
    return this.prop({attrs: attrs}, value)
},removeAttr: function(path, opt) {
    if (_.isArray(path)) {
        _.each(path, function(p) {
            this.removeAttr(p, opt)
        }, this);
        return this
    }
    var attrs = joint.util.unsetByPath(_.merge({}, this.get("attrs")), path, "/");
    return this.set("attrs", attrs, _.extend({dirty: true}, opt))
},transition: function(path, value, opt, delim) {
    delim = delim || "/";
    var defaults = {duration: 100,delay: 10,timingFunction: joint.util.timing.linear,valueFunction: joint.util.interpolate.number};
    opt = _.extend(defaults, opt);
    var firstFrameTime = 0;
    var interpolatingFunction;
    var setter = _.bind(function(runtime) {
        var id, progress, propertyValue, status;
        firstFrameTime = firstFrameTime || runtime;
        runtime -= firstFrameTime;
        progress = runtime / opt.duration;
        if (progress < 1) {
            this._transitionIds[path] = id = joint.util.nextFrame(setter)
        } else {
            progress = 1;
            delete this._transitionIds[path]
        }
        propertyValue = interpolatingFunction(opt.timingFunction(progress));
        opt.transitionId = id;
        this.prop(path, propertyValue, opt);
        if (!id)
            this.trigger("transition:end", this, path)
    }, this);
    var initiator = _.bind(function(callback) {
        this.stopTransitions(path);
        interpolatingFunction = opt.valueFunction(joint.util.getByPath(this.attributes, path, delim), value);
        this._transitionIds[path] = joint.util.nextFrame(callback);
        this.trigger("transition:start", this, path)
    }, this);
    return _.delay(initiator, opt.delay, setter)
},getTransitions: function() {
    return _.keys(this._transitionIds)
},stopTransitions: function(path, delim) {
    delim = delim || "/";
    var pathArray = path && path.split(delim);
    _(this._transitionIds).keys().filter(pathArray && function(key) {
            return _.isEqual(pathArray, key.split(delim).slice(0, pathArray.length))
        }).each(function(key) {
        joint.util.cancelFrame(this._transitionIds[key]);
        delete this._transitionIds[key];
        this.trigger("transition:end", this, key)
    }, this);
    return this
},addTo: function(graph) {
    graph.addCell(this);
    return this
},findView: function(paper) {
    return paper.findViewByModel(this)
},isLink: function() {
    return false
}});
joint.dia.CellView = Backbone.View.extend({tagName: "g",attributes: function() {
    return {"model-id": this.model.id}
},constructor: function(options) {
    this._configure(options);
    Backbone.View.apply(this, arguments)
},_configure: function(options) {
    if (this.options)
        options = _.extend({}, _.result(this, "options"), options);
    this.options = options;
    this.options.id = this.options.id || joint.util.guid(this)
},initialize: function() {
    _.bindAll(this, "remove", "update");
    this.$el.data("view", this);
    this.listenTo(this.model, "remove", this.remove);
    this.listenTo(this.model, "change:attrs", this.onChangeAttrs)
},onChangeAttrs: function(cell, attrs, opt) {
    if (opt.dirty) {
        return this.render()
    }
    return this.update()
},_ensureElement: function() {
    var el;
    if (!this.el) {
        var attrs = _.extend({id: this.id}, _.result(this, "attributes"));
        if (this.className)
            attrs["class"] = _.result(this, "className");
        el = V(_.result(this, "tagName"), attrs).node
    } else {
        el = _.result(this, "el")
    }
    this.setElement(el, false)
},findBySelector: function(selector) {
    var $selected = selector === "." ? this.$el : this.$el.find(selector);
    return $selected
},notify: function(evt) {
    if (this.paper) {
        var args = Array.prototype.slice.call(arguments, 1);
        this.trigger.apply(this, [evt].concat(args));
        this.paper.trigger.apply(this.paper, [evt, this].concat(args))
    }
},getStrokeBBox: function(el) {
    var isMagnet = !!el;
    el = el || this.el;
    var bbox = V(el).bbox(false, this.paper.viewport);
    var strokeWidth;
    if (isMagnet) {
        strokeWidth = V(el).attr("stroke-width")
    } else {
        strokeWidth = this.model.attr("rect/stroke-width") || this.model.attr("circle/stroke-width") || this.model.attr("ellipse/stroke-width") || this.model.attr("path/stroke-width")
    }
    strokeWidth = parseFloat(strokeWidth) || 0;
    return g.rect(bbox).moveAndExpand({x: -strokeWidth / 2,y: -strokeWidth / 2,width: strokeWidth,height: strokeWidth})
},getBBox: function() {
    return V(this.el).bbox()
},highlight: function(el, opt) {
    el = !el ? this.el : this.$(el)[0] || this.el;
    opt = opt || {};
    opt.partial = el != this.el;
    this.notify("cell:highlight", el, opt);
    return this
},unhighlight: function(el, opt) {
    el = !el ? this.el : this.$(el)[0] || this.el;
    opt = opt || {};
    opt.partial = el != this.el;
    this.notify("cell:unhighlight", el, opt);
    return this
},findMagnet: function(el) {
    var $el = this.$(el);
    if ($el.length === 0 || $el[0] === this.el) {
        var attrs = this.model.get("attrs") || {};
        if (attrs["."] && attrs["."]["magnet"] === false) {
            return undefined
        }
        return this.el
    }
    if ($el.attr("magnet")) {
        return $el[0]
    }
    return this.findMagnet($el.parent())
},applyFilter: function(selector, filter) {
    var $selected = this.findBySelector(selector);
    var filterId = filter.name + this.paper.svg.id + joint.util.hashCode(JSON.stringify(filter));
    if (!this.paper.svg.getElementById(filterId)) {
        var filterSVGString = joint.util.filter[filter.name] && joint.util.filter[filter.name](filter.args || {});
        if (!filterSVGString) {
            throw new Error("Non-existing filter " + filter.name)
        }
        var filterElement = V(filterSVGString);
        filterElement.attr({filterUnits: "objectBoundingBox",x: -1,y: -1,width: 3,height: 3});
        if (filter.attrs)
            filterElement.attr(filter.attrs);
        filterElement.node.id = filterId;
        V(this.paper.svg).defs().append(filterElement)
    }
    $selected.each(function() {
        V(this).attr("filter", "url(#" + filterId + ")")
    })
},applyGradient: function(selector, attr, gradient) {
    var $selected = this.findBySelector(selector);
    var gradientId = gradient.type + this.paper.svg.id + joint.util.hashCode(JSON.stringify(gradient));
    if (!this.paper.svg.getElementById(gradientId)) {
        var gradientSVGString = ["<" + gradient.type + ">", _.map(gradient.stops, function(stop) {
            return '<stop offset="' + stop.offset + '" stop-color="' + stop.color + '" stop-opacity="' + (_.isFinite(stop.opacity) ? stop.opacity : 1) + '" />'
        }).join(""), "</" + gradient.type + ">"].join("");
        var gradientElement = V(gradientSVGString);
        if (gradient.attrs) {
            gradientElement.attr(gradient.attrs)
        }
        gradientElement.node.id = gradientId;
        V(this.paper.svg).defs().append(gradientElement)
    }
    $selected.each(function() {
        V(this).attr(attr, "url(#" + gradientId + ")")
    })
},getSelector: function(el, selector) {
    if (el === this.el) {
        return selector
    }
    var index = $(el).index();
    selector = el.tagName + ":nth-child(" + (index + 1) + ")" + " " + (selector || "");
    return this.getSelector($(el).parent()[0], selector + " ")
},pointerdblclick: function(evt, x, y) {
    this.notify("cell:pointerdblclick", evt, x, y)
},pointerclick: function(evt, x, y) {
    this.notify("cell:pointerclick", evt, x, y)
},pointerdown: function(evt, x, y) {
    if (this.model.collection) {
        this.model.trigger("batch:start");
        this._collection = this.model.collection
    }
    this.notify("cell:pointerdown", evt, x, y)
},pointermove: function(evt, x, y) {
    this.notify("cell:pointermove", evt, x, y)
},pointerup: function(evt, x, y) {
    this.notify("cell:pointerup", evt, x, y);
    if (this._collection) {
        this._collection.trigger("batch:stop");
        delete this._collection
    }
},mouseover: function(evt) {
    this.notify("cell:mouseover", evt)
},mouseout: function(evt) {
    this.notify("cell:mouseout", evt)
}});


if (typeof exports === "object") {
    module.exports.Cell = joint.dia.Cell;
    module.exports.CellView = joint.dia.CellView
}
if (typeof exports === "object") {
    var joint = {util: require("./core").util,dia: {Cell: require("./joint.dia.cell").Cell,CellView: require("./joint.dia.cell").CellView}};
    var Backbone = require("backbone");
    var _ = require("lodash")
}


joint.dia.Element = joint.dia.Cell.extend({defaults: {position: {x: 0,y: 0},size: {width: 1,height: 1},angle: 0},position: function(x, y, opt) {
    var isSetter = _.isNumber(y);
    opt = (isSetter ? opt : x) || {};
    if (opt.parentRelative) {
        if (!this.collection)
            throw new Error("Element must be part of a collection.");
        var parent = this.collection.get(this.get("parent"));
        var parentPosition = parent && !parent.isLink() ? parent.get("position") : {x: 0,y: 0}
    }
    if (isSetter) {
        if (opt.parentRelative) {
            x += parentPosition.x;
            y += parentPosition.y
        }
        return this.set("position", {x: x,y: y}, opt)
    } else {
        var elementPosition = g.point(this.get("position"));
        return opt.parentRelative ? elementPosition.difference(parentPosition) : elementPosition
    }
},translate: function(tx, ty, opt) {
    ty = ty || 0;
    if (tx === 0 && ty === 0) {
        return this
    }
    opt = opt || {};
    opt.translateBy = opt.translateBy || this.id;
    opt.tx = tx;
    opt.ty = ty;
    var position = this.get("position") || {x: 0,y: 0};
    var translatedPosition = {x: position.x + tx || 0,y: position.y + ty || 0};
    if (opt.transition) {
        if (!_.isObject(opt.transition))
            opt.transition = {};
        this.transition("position", translatedPosition, _.extend({}, opt.transition, {valueFunction: joint.util.interpolate.object}))
    } else {
        this.set("position", translatedPosition, opt);
        _.invoke(this.getEmbeddedCells(), "translate", tx, ty, opt)
    }
    return this
},resize: function(width, height) {
    this.trigger("batch:start");
    this.set("size", {width: width,height: height});
    this.trigger("batch:stop");
    return this
},rotate: function(angle, absolute, origin) {
    if (origin) {
        var center = this.getBBox().center();
        var size = this.get("size");
        var position = this.get("position");
        center.rotate(origin, (this.get("angle") || 0) - angle);
        var dx = center.x - size.width / 2 - position.x;
        var dy = center.y - size.height / 2 - position.y;
        this.trigger("batch:start");
        this.translate(dx, dy);
        this.rotate(angle, absolute);
        this.trigger("batch:stop")
    } else {
        this.set("angle", absolute ? angle : ((this.get("angle") || 0) + angle) % 360)
    }
    return this
},getBBox: function() {
    var position = this.get("position");
    var size = this.get("size");
    return g.rect(position.x, position.y, size.width, size.height)
}});
joint.dia.ElementView = joint.dia.CellView.extend({className: function() {
    return "element " + this.model.get("type").split(".").join(" ")
},initialize: function() {
    _.bindAll(this, "translate", "resize", "rotate");
    joint.dia.CellView.prototype.initialize.apply(this, arguments);
    this.listenTo(this.model, "change:position", this.translate);
    this.listenTo(this.model, "change:size", this.resize);
    this.listenTo(this.model, "change:angle", this.rotate)
},update: function(cell, renderingOnlyAttrs) {
    var allAttrs = this.model.get("attrs");
    var rotatable = V(this.$(".rotatable")[0]);
    if (rotatable) {
        var rotation = rotatable.attr("transform");
        rotatable.attr("transform", "")
    }
    var relativelyPositioned = [];
    _.each(renderingOnlyAttrs || allAttrs, function(attrs, selector) {
        var $selected = this.findBySelector(selector);
        if ($selected.length === 0)
            return;
        var specialAttributes = ["style", "text", "html", "ref-x", "ref-y", "ref-dx", "ref-dy", "ref-width", "ref-height", "ref", "x-alignment", "y-alignment", "port"];
        if (_.isObject(attrs.filter)) {
            specialAttributes.push("filter");
            this.applyFilter(selector, attrs.filter)
        }
        if (_.isObject(attrs.fill)) {
            specialAttributes.push("fill");
            this.applyGradient(selector, "fill", attrs.fill)
        }
        if (_.isObject(attrs.stroke)) {
            specialAttributes.push("stroke");
            this.applyGradient(selector, "stroke", attrs.stroke)
        }
        if (!_.isUndefined(attrs.text)) {
            $selected.each(function() {
                V(this).text(attrs.text + "", {lineHeight: attrs.lineHeight,textPath: attrs.textPath})
            });
            specialAttributes.push("lineHeight", "textPath")
        }
        var finalAttributes = _.omit(attrs, specialAttributes);
        $selected.each(function() {
            V(this).attr(finalAttributes)
        });
        if (attrs.port) {
            $selected.attr("port", _.isUndefined(attrs.port.id) ? attrs.port : attrs.port.id)
        }
        if (attrs.style) {
            $selected.css(attrs.style)
        }
        if (!_.isUndefined(attrs.html)) {
            $selected.each(function() {
                $(this).html(attrs.html + "")
            })
        }
        if (!_.isUndefined(attrs["ref-x"]) || !_.isUndefined(attrs["ref-y"]) || !_.isUndefined(attrs["ref-dx"]) || !_.isUndefined(attrs["ref-dy"]) || !_.isUndefined(attrs["x-alignment"]) || !_.isUndefined(attrs["y-alignment"]) || !_.isUndefined(attrs["ref-width"]) || !_.isUndefined(attrs["ref-height"])) {
            _.each($selected, function(el, index, list) {
                var $el = $(el);
                $el.selector = list.selector;
                relativelyPositioned.push($el)
            })
        }
    }, this);
    var bbox = this.el.getBBox();
    renderingOnlyAttrs = renderingOnlyAttrs || {};
    _.each(relativelyPositioned, function($el) {
        var renderingOnlyElAttrs = renderingOnlyAttrs[$el.selector];
        var elAttrs = renderingOnlyElAttrs ? _.merge({}, allAttrs[$el.selector], renderingOnlyElAttrs) : allAttrs[$el.selector];
        this.positionRelative($el, bbox, elAttrs)
    }, this);
    if (rotatable) {
        rotatable.attr("transform", rotation || "")
    }
},positionRelative: function($el, bbox, elAttrs) {
    var ref = elAttrs["ref"];
    var refX = parseFloat(elAttrs["ref-x"]);
    var refY = parseFloat(elAttrs["ref-y"]);
    var refDx = parseFloat(elAttrs["ref-dx"]);
    var refDy = parseFloat(elAttrs["ref-dy"]);
    var yAlignment = elAttrs["y-alignment"];
    var xAlignment = elAttrs["x-alignment"];
    var refWidth = parseFloat(elAttrs["ref-width"]);
    var refHeight = parseFloat(elAttrs["ref-height"]);
    var isScalable = _.contains(_.pluck(_.pluck($el.parents("g"), "className"), "baseVal"), "scalable");
    if (ref) {
        bbox = V(this.findBySelector(ref)[0]).bbox(false, this.el)
    }
    var vel = V($el[0]);
    if (vel.attr("transform")) {
        vel.attr("transform", vel.attr("transform").replace(/translate\([^)]*\)/g, "").trim() || "")
    }
    function isDefined(x) {
        return _.isNumber(x) && !_.isNaN(x)
    }
    var tx = 0;
    var ty = 0;
    if (isDefined(refWidth)) {
        if (refWidth >= 0 && refWidth <= 1) {
            vel.attr("width", refWidth * bbox.width)
        } else {
            vel.attr("width", Math.max(refWidth + bbox.width, 0))
        }
    }
    if (isDefined(refHeight)) {
        if (refHeight >= 0 && refHeight <= 1) {
            vel.attr("height", refHeight * bbox.height)
        } else {
            vel.attr("height", Math.max(refHeight + bbox.height, 0))
        }
    }
    if (isDefined(refDx)) {
        if (isScalable) {
            var scale = V(this.$(".scalable")[0]).scale();
            tx = bbox.x + bbox.width + refDx / scale.sx
        } else {
            tx = bbox.x + bbox.width + refDx
        }
    }
    if (isDefined(refDy)) {
        if (isScalable) {
            var scale = V(this.$(".scalable")[0]).scale();
            ty = bbox.y + bbox.height + refDy / scale.sy
        } else {
            ty = bbox.y + bbox.height + refDy
        }
    }
    if (isDefined(refX)) {
        if (refX > 0 && refX < 1) {
            tx = bbox.x + bbox.width * refX
        } else if (isScalable) {
            var scale = V(this.$(".scalable")[0]).scale();
            tx = bbox.x + refX / scale.sx
        } else {
            tx = bbox.x + refX
        }
    }
    if (isDefined(refY)) {
        if (refY > 0 && refY < 1) {
            ty = bbox.y + bbox.height * refY
        } else if (isScalable) {
            var scale = V(this.$(".scalable")[0]).scale();
            ty = bbox.y + refY / scale.sy
        } else {
            ty = bbox.y + refY
        }
    }
    var velbbox = vel.bbox(false, this.paper.viewport);
    if (yAlignment === "middle") {
        ty -= velbbox.height / 2
    } else if (isDefined(yAlignment)) {
        ty += yAlignment > -1 && yAlignment < 1 ? velbbox.height * yAlignment : yAlignment
    }
    if (xAlignment === "middle") {
        tx -= velbbox.width / 2
    } else if (isDefined(xAlignment)) {
        tx += xAlignment > -1 && xAlignment < 1 ? velbbox.width * xAlignment : xAlignment
    }
    vel.translate(tx, ty)
},renderMarkup: function() {
    var markup = this.model.markup || this.model.get("markup");
    if (markup) {
        var nodes = V(markup);
        V(this.el).append(nodes)
    } else {
        throw new Error("properties.markup is missing while the default render() implementation is used.")
    }
},render: function() {
    this.$el.empty();
    this.renderMarkup();
    this.update();
    this.resize();
    this.rotate();
    this.translate();
    return this
},scale: function(sx, sy) {
    V(this.el).scale(sx, sy)
},resize: function() {
    var size = this.model.get("size") || {width: 1,height: 1};
    var angle = this.model.get("angle") || 0;
    var scalable = V(this.$(".scalable")[0]);
    if (!scalable) {
        return
    }
    var scalableBbox = scalable.bbox(true);
    scalable.attr("transform", "scale(" + size.width / (scalableBbox.width || 1) + "," + size.height / (scalableBbox.height || 1) + ")");
    var rotatable = V(this.$(".rotatable")[0]);
    var rotation = rotatable && rotatable.attr("transform");
    if (rotation && rotation !== "null") {
        rotatable.attr("transform", rotation + " rotate(" + -angle + "," + size.width / 2 + "," + size.height / 2 + ")");
        var rotatableBbox = scalable.bbox(false, this.paper.viewport);
        this.model.set("position", {x: rotatableBbox.x,y: rotatableBbox.y});
        this.rotate()
    }
    this.update()
},translate: function(model, changes, opt) {
    var position = this.model.get("position") || {x: 0,y: 0};
    V(this.el).attr("transform", "translate(" + position.x + "," + position.y + ")")
},rotate: function() {
    var rotatable = V(this.$(".rotatable")[0]);
    if (!rotatable) {
        return
    }
    var angle = this.model.get("angle") || 0;
    var size = this.model.get("size") || {width: 1,height: 1};
    var ox = size.width / 2;
    var oy = size.height / 2;
    rotatable.attr("transform", "rotate(" + angle + "," + ox + "," + oy + ")")
},getBBox: function(opt) {
    if (opt && opt.useModelGeometry) {
        var noTransformationBBox = this.model.getBBox().bbox(this.model.get("angle"));
        var transformationMatrix = this.paper.viewport.getCTM();
        return V.transformRect(noTransformationBBox, transformationMatrix)
    }
    return joint.dia.CellView.prototype.getBBox.apply(this, arguments)
},findParentsByKey: function(key) {
    var bbox = this.model.getBBox();
    return key == "bbox" ? this.paper.model.findModelsInArea(bbox) : this.paper.model.findModelsFromPoint(bbox[key]())
},prepareEmbedding: function() {
    this.model.toFront({deep: true,ui: true});
    _.invoke(this.paper.model.getConnectedLinks(this.model, {deep: true}), "toFront", {ui: true});
    var parentId = this.model.get("parent");
    parentId && this.paper.model.getCell(parentId).unembed(this.model, {ui: true})
},processEmbedding: function(opt) {
    opt = opt || this.paper.options;
    var candidates = this.findParentsByKey(opt.findParentBy);
    candidates = _.reject(candidates, function(el) {
        return this.model.id == el.id || el.isEmbeddedIn(this.model)
    }, this);
    if (opt.frontParentOnly) {
        candidates = candidates.slice(-1)
    }
    var newCandidateView = null;
    var prevCandidateView = this._candidateEmbedView;
    for (var i = candidates.length - 1; i >= 0; i--) {
        var candidate = candidates[i];
        if (prevCandidateView && prevCandidateView.model.id == candidate.id) {
            newCandidateView = prevCandidateView;
            break
        } else {
            var view = candidate.findView(this.paper);
            if (opt.validateEmbedding.call(this.paper, this, view)) {
                newCandidateView = view;
                break
            }
        }
    }
    if (newCandidateView && newCandidateView != prevCandidateView) {
        prevCandidateView && prevCandidateView.unhighlight(null, {embedding: true});
        this._candidateEmbedView = newCandidateView.highlight(null, {embedding: true})
    }
    if (!newCandidateView && prevCandidateView) {
        prevCandidateView.unhighlight(null, {embedding: true});
        delete this._candidateEmbedView
    }
},finalizeEmbedding: function() {
    var candidateView = this._candidateEmbedView;
    if (candidateView) {
        candidateView.model.embed(this.model, {ui: true});
        candidateView.unhighlight(null, {embedding: true});
        delete this._candidateEmbedView
    }
    _.invoke(this.paper.model.getConnectedLinks(this.model, {deep: true}), "reparent", {ui: true})
},pointerdown: function(evt, x, y) {
    this.model.trigger("batch:start");
    if (evt.target.getAttribute("magnet") && this.paper.options.validateMagnet.call(this.paper, this, evt.target)) {
        var link = this.paper.getDefaultLink(this, evt.target);
        link.set({source: {id: this.model.id,selector: this.getSelector(evt.target),port: $(evt.target).attr("port")},target: {x: x,y: y}});
        this.paper.model.addCell(link);
        this._linkView = this.paper.findViewByModel(link);
        this._linkView.startArrowheadMove("target")
    } else {
        this._dx = x;
        this._dy = y;
        joint.dia.CellView.prototype.pointerdown.apply(this, arguments)
    }
},pointermove: function(evt, x, y) {
    if (this._linkView) {
        this._linkView.pointermove(evt, x, y)
    } else {
        var grid = this.paper.options.gridSize;
        var interactive = _.isFunction(this.options.interactive) ? this.options.interactive(this, "pointermove") : this.options.interactive;
        if (interactive !== false) {
            var position = this.model.get("position");
            this.model.translate(g.snapToGrid(position.x, grid) - position.x + g.snapToGrid(x - this._dx, grid), g.snapToGrid(position.y, grid) - position.y + g.snapToGrid(y - this._dy, grid));
            if (this.paper.options.embeddingMode) {
                if (!this._inProcessOfEmbedding) {
                    this.prepareEmbedding();
                    this._inProcessOfEmbedding = true
                }
                this.processEmbedding()
            }
        }
        this._dx = g.snapToGrid(x, grid);
        this._dy = g.snapToGrid(y, grid);
        joint.dia.CellView.prototype.pointermove.apply(this, arguments)
    }
},pointerup: function(evt, x, y) {
    if (this._linkView) {
        this._linkView.pointerup(evt, x, y);
        delete this._linkView
    } else {
        if (this._inProcessOfEmbedding) {
            this.finalizeEmbedding();
            this._inProcessOfEmbedding = false
        }
        joint.dia.CellView.prototype.pointerup.apply(this, arguments)
    }
    this.model.trigger("batch:stop")
}});


if (typeof exports === "object") {
    module.exports.Element = joint.dia.Element;
    module.exports.ElementView = joint.dia.ElementView
}
if (typeof exports === "object") {
    var joint = {dia: {Cell: require("./joint.dia.cell").Cell,CellView: require("./joint.dia.cell").CellView}};
    var Backbone = require("backbone");
    var _ = require("lodash");
    var g = require("./geometry")
}




joint.dia.Link = joint.dia.Cell.extend({markup: ['<path class="connection" stroke="black"/>', '<path class="marker-source" fill="black" stroke="black" />', '<path class="marker-target" fill="black" stroke="black" />', '<path class="connection-wrap"/>', '<g class="labels"/>', '<g class="marker-vertices"/>', '<g class="marker-arrowheads"/>', '<g class="link-tools"/>'].join(""),labelMarkup: ['<g class="label">', "<rect />", "<text />", "</g>"].join(""),toolMarkup: ['<g class="link-tool">', '<g class="tool-remove" event="remove">', '<circle r="11" />', '<path transform="scale(.8) translate(-16, -16)" d="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z"/>', "<title>Remove link.</title>", "</g>", '<g class="tool-options" event="link:options">', '<circle r="11" transform="translate(25)"/>', '<path fill="white" transform="scale(.55) translate(29, -16)" d="M31.229,17.736c0.064-0.571,0.104-1.148,0.104-1.736s-0.04-1.166-0.104-1.737l-4.377-1.557c-0.218-0.716-0.504-1.401-0.851-2.05l1.993-4.192c-0.725-0.91-1.549-1.734-2.458-2.459l-4.193,1.994c-0.647-0.347-1.334-0.632-2.049-0.849l-1.558-4.378C17.165,0.708,16.588,0.667,16,0.667s-1.166,0.041-1.737,0.105L12.707,5.15c-0.716,0.217-1.401,0.502-2.05,0.849L6.464,4.005C5.554,4.73,4.73,5.554,4.005,6.464l1.994,4.192c-0.347,0.648-0.632,1.334-0.849,2.05l-4.378,1.557C0.708,14.834,0.667,15.412,0.667,16s0.041,1.165,0.105,1.736l4.378,1.558c0.217,0.715,0.502,1.401,0.849,2.049l-1.994,4.193c0.725,0.909,1.549,1.733,2.459,2.458l4.192-1.993c0.648,0.347,1.334,0.633,2.05,0.851l1.557,4.377c0.571,0.064,1.148,0.104,1.737,0.104c0.588,0,1.165-0.04,1.736-0.104l1.558-4.377c0.715-0.218,1.399-0.504,2.049-0.851l4.193,1.993c0.909-0.725,1.733-1.549,2.458-2.458l-1.993-4.193c0.347-0.647,0.633-1.334,0.851-2.049L31.229,17.736zM16,20.871c-2.69,0-4.872-2.182-4.872-4.871c0-2.69,2.182-4.872,4.872-4.872c2.689,0,4.871,2.182,4.871,4.872C20.871,18.689,18.689,20.871,16,20.871z"/>', "<title>Link options.</title>", "</g>", "</g>"].join(""),vertexMarkup: ['<g class="marker-vertex-group" transform="translate(<%= x %>, <%= y %>)">', '<circle class="marker-vertex" idx="<%= idx %>" r="10" />', '<path class="marker-vertex-remove-area" idx="<%= idx %>" d="M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z" transform="translate(5, -33)"/>', '<path class="marker-vertex-remove" idx="<%= idx %>" transform="scale(.8) translate(9.5, -37)" d="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z">', "<title>Remove vertex.</title>", "</path>", "</g>"].join(""),arrowheadMarkup: ['<g class="marker-arrowhead-group marker-arrowhead-group-<%= end %>">', '<path class="marker-arrowhead" end="<%= end %>" d="M 26 0 L 0 13 L 26 26 z" />', "</g>"].join(""),defaults: {type: "link",source: {},target: {}},disconnect: function() {
    return this.set({source: g.point(0, 0),target: g.point(0, 0)})
},label: function(idx, value) {
    idx = idx || 0;
    var labels = this.get("labels") || [];
    if (arguments.length === 0 || arguments.length === 1) {
        return labels[idx]
    }
    var newValue = _.merge({}, labels[idx], value);
    var newLabels = labels.slice();
    newLabels[idx] = newValue;
    return this.set({labels: newLabels})
},translate: function(tx, ty, opt) {
    var attrs = {};
    var source = this.get("source");
    var target = this.get("target");
    var vertices = this.get("vertices");
    if (!source.id) {
        attrs.source = {x: source.x + tx,y: source.y + ty}
    }
    if (!target.id) {
        attrs.target = {x: target.x + tx,y: target.y + ty}
    }
    if (vertices && vertices.length) {
        attrs.vertices = _.map(vertices, function(vertex) {
            return {x: vertex.x + tx,y: vertex.y + ty}
        })
    }
    return this.set(attrs, opt)
},reparent: function(opt) {
    var newParent;
    if (this.collection) {
        var source = this.collection.get(this.get("source").id);
        var target = this.collection.get(this.get("target").id);
        var prevParent = this.collection.get(this.get("parent"));
        if (source && target) {
            newParent = this.collection.getCommonAncestor(source, target)
        }
        if (prevParent && (!newParent || newParent.id != prevParent.id)) {
            prevParent.unembed(this, opt)
        }
        if (newParent) {
            newParent.embed(this, opt)
        }
    }
    return newParent
},isLink: function() {
    return true
},hasLoop: function() {
    var sourceId = this.get("source").id;
    var targetId = this.get("target").id;
    return sourceId && targetId && sourceId == targetId
}});
joint.dia.LinkView = joint.dia.CellView.extend({className: function() {
    return _.unique(this.model.get("type").split(".").concat("link")).join(" ")
},options: {shortLinkLength: 100,doubleLinkTools: false,longLinkLength: 160,linkToolsOffset: 40,doubleLinkToolsOffset: 60},initialize: function(options) {
    joint.dia.CellView.prototype.initialize.apply(this, arguments);
    if (typeof this.constructor.prototype.watchSource !== "function") {
        this.constructor.prototype.watchSource = this.createWatcher("source");
        this.constructor.prototype.watchTarget = this.createWatcher("target")
    }
    this._labelCache = {};
    this._markerCache = {};
    this.startListening()
},startListening: function() {
    this.listenTo(this.model, "change:markup", this.render);
    this.listenTo(this.model, "change:smooth change:manhattan change:router change:connector", this.update);
    this.listenTo(this.model, "change:toolMarkup", function() {
        this.renderTools().updateToolsPosition()
    });
    this.listenTo(this.model, "change:labels change:labelMarkup", function() {
        this.renderLabels().updateLabelPositions()
    });
    this.listenTo(this.model, "change:vertices change:vertexMarkup", function(cell, changed, opt) {
        this.renderVertexMarkers();
        if (!opt.translateBy || (opt.translateBy == this.model.id || this.model.hasLoop())) {
            this.update()
        }
    });
    this.listenTo(this.model, "change:source", function(cell, source) {
        this.watchSource(cell, source).update()
    });
    this.listenTo(this.model, "change:target", function(cell, target) {
        this.watchTarget(cell, target).update()
    })
},render: function() {
    this.$el.empty();
    var children = V(this.model.get("markup") || this.model.markup);
    if (!_.isArray(children))
        children = [children];
    this._V = {};
    _.each(children, function(child) {
        var c = child.attr("class");
        c && (this._V[$.camelCase(c)] = child)
    }, this);
    if (!this._V.connection)
        throw new Error("link: no connection path in the markup");
    this.renderTools();
    this.renderVertexMarkers();
    this.renderArrowheadMarkers();
    V(this.el).append(children);
    this.renderLabels();
    this.watchSource(this.model, this.model.get("source")).watchTarget(this.model, this.model.get("target")).update();
    return this
},renderLabels: function() {
    if (!this._V.labels)
        return this;
    this._labelCache = {};
    var $labels = $(this._V.labels.node).empty();
    var labels = this.model.get("labels") || [];
    if (!labels.length)
        return this;
    var labelTemplate = _.template(this.model.get("labelMarkup") || this.model.labelMarkup);
    var labelNodeInstance = V(labelTemplate());
    _.each(labels, function(label, idx) {
        var labelNode = labelNodeInstance.clone().node;
        this._labelCache[idx] = V(labelNode);
        var $text = $(labelNode).find("text");
        var $rect = $(labelNode).find("rect");
        var textAttributes = _.extend({"text-anchor": "middle","font-size": 14}, joint.util.getByPath(label, "attrs/text", "/"));
        $text.attr(_.omit(textAttributes, "text"));
        if (!_.isUndefined(textAttributes.text)) {
            V($text[0]).text(textAttributes.text + "")
        }
        $labels.append(labelNode);
        var textBbox = V($text[0]).bbox(true, $labels[0]);
        V($text[0]).translate(0, -textBbox.height / 2);
        var rectAttributes = _.extend({fill: "white",rx: 3,ry: 3}, joint.util.getByPath(label, "attrs/rect", "/"));
        $rect.attr(_.extend(rectAttributes, {x: textBbox.x,y: textBbox.y - textBbox.height / 2,width: textBbox.width,height: textBbox.height}))
    }, this);
    return this
},renderTools: function() {
    if (!this._V.linkTools)
        return this;
    var $tools = $(this._V.linkTools.node).empty();
    var toolTemplate = _.template(this.model.get("toolMarkup") || this.model.toolMarkup);
    var tool = V(toolTemplate());
    $tools.append(tool.node);
    this._toolCache = tool;
    if (this.options.doubleLinkTools) {
        var tool2 = tool.clone();
        $tools.append(tool2.node);
        this._tool2Cache = tool2
    }
    return this
},renderVertexMarkers: function() {
    if (!this._V.markerVertices)
        return this;
    var $markerVertices = $(this._V.markerVertices.node).empty();
    var markupTemplate = _.template(this.model.get("vertexMarkup") || this.model.vertexMarkup);
    _.each(this.model.get("vertices"), function(vertex, idx) {
        $markerVertices.append(V(markupTemplate(_.extend({idx: idx}, vertex))).node)
    });
    return this
},renderArrowheadMarkers: function() {
    if (!this._V.markerArrowheads)
        return this;
    var $markerArrowheads = $(this._V.markerArrowheads.node);
    $markerArrowheads.empty();
    var markupTemplate = _.template(this.model.get("arrowheadMarkup") || this.model.arrowheadMarkup);
    this._V.sourceArrowhead = V(markupTemplate({end: "source"}));
    this._V.targetArrowhead = V(markupTemplate({end: "target"}));
    $markerArrowheads.append(this._V.sourceArrowhead.node, this._V.targetArrowhead.node);
    return this
},update: function() {
    _.each(this.model.get("attrs"), function(attrs, selector) {
        var processedAttributes = [];
        if (_.isObject(attrs.fill)) {
            this.applyGradient(selector, "fill", attrs.fill);
            processedAttributes.push("fill")
        }
        if (_.isObject(attrs.stroke)) {
            this.applyGradient(selector, "stroke", attrs.stroke);
            processedAttributes.push("stroke")
        }
        if (_.isObject(attrs.filter)) {
            this.applyFilter(selector, attrs.filter);
            processedAttributes.push("filter")
        }
        if (processedAttributes.length > 0) {
            processedAttributes.unshift(attrs);
            attrs = _.omit.apply(_, processedAttributes)
        }
        this.findBySelector(selector).attr(attrs)
    }, this);
    var vertices = this.route = this.findRoute(this.model.get("vertices") || []);
    this._findConnectionPoints(vertices);
    var pathData = this.getPathData(vertices);
    this._V.connection.attr("d", pathData);
    this._V.connectionWrap && this._V.connectionWrap.attr("d", pathData);
    this._translateAndAutoOrientArrows(this._V.markerSource, this._V.markerTarget);
    this.updateLabelPositions();
    this.updateToolsPosition();
    this.updateArrowheadMarkers();
    delete this.options.perpendicular;
    this.updatePostponed = false;
    return this
},_findConnectionPoints: function(vertices) {
    var sourcePoint, targetPoint, sourceMarkerPoint, targetMarkerPoint;
    var firstVertex = _.first(vertices);
    sourcePoint = this.getConnectionPoint("source", this.model.get("source"), firstVertex || this.model.get("target")).round();
    var lastVertex = _.last(vertices);
    targetPoint = this.getConnectionPoint("target", this.model.get("target"), lastVertex || sourcePoint).round();
    var cache = this._markerCache;
    if (this._V.markerSource) {
        cache.sourceBBox = cache.sourceBBox || this._V.markerSource.bbox(true);
        sourceMarkerPoint = g.point(sourcePoint).move(firstVertex || targetPoint, cache.sourceBBox.width * this._V.markerSource.scale().sx * -1).round()
    }
    if (this._V.markerTarget) {
        cache.targetBBox = cache.targetBBox || this._V.markerTarget.bbox(true);
        targetMarkerPoint = g.point(targetPoint).move(lastVertex || sourcePoint, cache.targetBBox.width * this._V.markerTarget.scale().sx * -1).round()
    }
    cache.sourcePoint = sourceMarkerPoint || sourcePoint;
    cache.targetPoint = targetMarkerPoint || targetPoint;
    this.sourcePoint = sourcePoint;
    this.targetPoint = targetPoint
},updateLabelPositions: function() {
    if (!this._V.labels)
        return this;
    var labels = this.model.get("labels") || [];
    if (!labels.length)
        return this;
    var connectionElement = this._V.connection.node;
    var connectionLength = connectionElement.getTotalLength();
    if (!_.isNaN(connectionLength)) {
        _.each(labels, function(label, idx) {
            var position = label.position;
            position = position > connectionLength ? connectionLength : position;
            position = position < 0 ? connectionLength + position : position;
            position = position > 1 ? position : connectionLength * position;
            var labelCoordinates = connectionElement.getPointAtLength(position);
            this._labelCache[idx].attr("transform", "translate(" + labelCoordinates.x + ", " + labelCoordinates.y + ")")
        }, this)
    }
    return this
},updateToolsPosition: function() {
    if (!this._V.linkTools)
        return this;
    var scale = "";
    var offset = this.options.linkToolsOffset;
    var connectionLength = this.getConnectionLength();
    if (connectionLength < this.options.shortLinkLength) {
        scale = "scale(.5)";
        offset /= 2
    }
    var toolPosition = this.getPointAtLength(offset);
    this._toolCache.attr("transform", "translate(" + toolPosition.x + ", " + toolPosition.y + ") " + scale);
    if (this.options.doubleLinkTools && connectionLength >= this.options.longLinkLength) {
        var doubleLinkToolsOffset = this.options.doubleLinkToolsOffset || offset;
        toolPosition = this.getPointAtLength(connectionLength - doubleLinkToolsOffset);
        this._tool2Cache.attr("transform", "translate(" + toolPosition.x + ", " + toolPosition.y + ") " + scale);
        this._tool2Cache.attr("visibility", "visible")
    } else if (this.options.doubleLinkTools) {
        this._tool2Cache.attr("visibility", "hidden")
    }
    return this
},updateArrowheadMarkers: function() {
    if (!this._V.markerArrowheads)
        return this;
    if ($.css(this._V.markerArrowheads.node, "display") === "none")
        return this;
    var sx = this.getConnectionLength() < this.options.shortLinkLength ? .5 : 1;
    this._V.sourceArrowhead.scale(sx);
    this._V.targetArrowhead.scale(sx);
    this._translateAndAutoOrientArrows(this._V.sourceArrowhead, this._V.targetArrowhead);
    return this
},createWatcher: function(endType) {
    var onModelChange = _.partial(this.onEndModelChange, endType);
    function watchEndModel(link, end) {
        end = end || {};
        var endModel = null;
        var previousEnd = link.previous(endType) || {};
        if (previousEnd.id) {
            this.stopListening(this.paper.getModelById(previousEnd.id), "change", onModelChange)
        }
        if (end.id) {
            endModel = this.paper.getModelById(end.id);
            this.listenTo(endModel, "change", onModelChange)
        }
        onModelChange.call(this, endModel, {cacheOnly: true});
        return this
    }
    return watchEndModel
},onEndModelChange: function(endType, endModel, opt) {
    var doUpdate = !opt.cacheOnly;
    var end = this.model.get(endType) || {};
    if (endModel) {
        var selector = this.constructor.makeSelector(end);
        var oppositeEndType = endType == "source" ? "target" : "source";
        var oppositeEnd = this.model.get(oppositeEndType) || {};
        var oppositeSelector = oppositeEnd.id && this.constructor.makeSelector(oppositeEnd);
        if (opt.isLoop && selector == oppositeSelector) {
            this[endType + "BBox"] = this[oppositeEndType + "BBox"];
            this[endType + "View"] = this[oppositeEndType + "View"];
            this[endType + "Magnet"] = this[oppositeEndType + "Magnet"]
        } else if (opt.translateBy) {
            var bbox = this[endType + "BBox"];
            bbox.x += opt.tx;
            bbox.y += opt.ty
        } else {
            var view = this.paper.findViewByModel(end.id);
            var magnetElement = view.el.querySelector(selector);
            this[endType + "BBox"] = view.getStrokeBBox(magnetElement);
            this[endType + "View"] = view;
            this[endType + "Magnet"] = magnetElement
        }
        if (opt.isLoop && opt.translateBy && this.model.isEmbeddedIn(endModel) && !_.isEmpty(this.model.get("vertices"))) {
            doUpdate = false
        }
        if (!this.updatePostponed && oppositeEnd.id) {
            var oppositeEndModel = this.paper.getModelById(oppositeEnd.id);
            opt.isLoop = end.id == oppositeEnd.id;
            if (opt.isLoop || opt.translateBy && oppositeEndModel.isEmbeddedIn(opt.translateBy)) {
                this.updatePostponed = true;
                doUpdate = false
            }
        }
    } else {
        this[endType + "BBox"] = g.rect(end.x || 0, end.y || 0, 1, 1);
        this[endType + "View"] = this[endType + "Magnet"] = null
    }
    this.lastEndChange = endType;
    doUpdate && this.update()
},_translateAndAutoOrientArrows: function(sourceArrow, targetArrow) {
    if (sourceArrow) {
        sourceArrow.translateAndAutoOrient(this.sourcePoint, _.first(this.route) || this.targetPoint, this.paper.viewport)
    }
    if (targetArrow) {
        targetArrow.translateAndAutoOrient(this.targetPoint, _.last(this.route) || this.sourcePoint, this.paper.viewport)
    }
},removeVertex: function(idx) {
    var vertices = _.clone(this.model.get("vertices"));
    if (vertices && vertices.length) {
        vertices.splice(idx, 1);
        this.model.set("vertices", vertices, {ui: true})
    }
    return this
},addVertex: function(vertex) {
    var vertices = (this.model.get("vertices") || []).slice();
    var originalVertices = vertices.slice();
    var path = this._V.connection.node.cloneNode(false);
    var originalPathLength = path.getTotalLength();
    var pathLength;
    var pathLengthTolerance = 20;
    var idx = vertices.length + 1;
    while (idx--) {
        vertices.splice(idx, 0, vertex);
        V(path).attr("d", this.getPathData(this.findRoute(vertices)));
        pathLength = path.getTotalLength();
        if (pathLength - originalPathLength > pathLengthTolerance) {
            vertices = originalVertices.slice()
        } else {
            break
        }
    }
    if (idx === -1) {
        idx = 0;
        vertices.splice(idx, 0, vertex)
    }
    this.model.set("vertices", vertices, {ui: true});
    return idx
},sendToken: function(token, duration, callback) {
    duration = duration || 1e3;
    V(this.paper.viewport).append(token);
    V(token).animateAlongPath({dur: duration + "ms",repeatCount: 1}, this._V.connection.node);
    _.delay(function() {
        V(token).remove();
        callback && callback()
    }, duration)
},findRoute: function(oldVertices) {
    var router = this.model.get("router");
    if (!router) {
        if (this.model.get("manhattan")) {
            router = {name: "orthogonal"}
        } else {
            return oldVertices
        }
    }
    var fn = joint.routers[router.name];
    if (!_.isFunction(fn)) {
        throw "unknown router: " + router.name
    }
    var newVertices = fn.call(this, oldVertices || [], router.args || {}, this);
    return newVertices
},getPathData: function(vertices) {
    var connector = this.model.get("connector");
    if (!connector) {
        connector = this.model.get("smooth") ? {name: "smooth"} : {name: "normal"}
    }
    if (!_.isFunction(joint.connectors[connector.name])) {
        throw "unknown connector: " + connector.name
    }
    var pathData = joint.connectors[connector.name].call(this, this._markerCache.sourcePoint, this._markerCache.targetPoint, vertices || (this.model.get("vertices") || {}), connector.args || {}, this);
    return pathData
},getConnectionPoint: function(end, selectorOrPoint, referenceSelectorOrPoint) {
    var spot;
    _.isEmpty(selectorOrPoint) && (selectorOrPoint = {x: 0,y: 0});
    _.isEmpty(referenceSelectorOrPoint) && (referenceSelectorOrPoint = {x: 0,y: 0});
    if (!selectorOrPoint.id) {
        spot = g.point(selectorOrPoint)
    } else {
        var spotBbox = end === "source" ? this.sourceBBox : this.targetBBox;
        var reference;
        if (!referenceSelectorOrPoint.id) {
            reference = g.point(referenceSelectorOrPoint)
        } else {
            var referenceBbox = end === "source" ? this.targetBBox : this.sourceBBox;
            reference = g.rect(referenceBbox).intersectionWithLineFromCenterToPoint(g.rect(spotBbox).center());
            reference = reference || g.rect(referenceBbox).center()
        }
        if (this.paper.options.perpendicularLinks || this.options.perpendicular) {
            var horizontalLineRect = g.rect(0, reference.y, this.paper.options.width, 1);
            var verticalLineRect = g.rect(reference.x, 0, 1, this.paper.options.height);
            var nearestSide;
            if (horizontalLineRect.intersect(g.rect(spotBbox))) {
                nearestSide = g.rect(spotBbox).sideNearestToPoint(reference);
                switch (nearestSide) {
                    case "left":
                        spot = g.point(spotBbox.x, reference.y);
                        break;
                    case "right":
                        spot = g.point(spotBbox.x + spotBbox.width, reference.y);
                        break;
                    default:
                        spot = g.rect(spotBbox).center();
                        break
                }
            } else if (verticalLineRect.intersect(g.rect(spotBbox))) {
                nearestSide = g.rect(spotBbox).sideNearestToPoint(reference);
                switch (nearestSide) {
                    case "top":
                        spot = g.point(reference.x, spotBbox.y);
                        break;
                    case "bottom":
                        spot = g.point(reference.x, spotBbox.y + spotBbox.height);
                        break;
                    default:
                        spot = g.rect(spotBbox).center();
                        break
                }
            } else {
                spot = g.rect(spotBbox).intersectionWithLineFromCenterToPoint(reference);
                spot = spot || g.rect(spotBbox).center()
            }
        } else if (this.paper.options.linkConnectionPoint) {
            var view = end === "target" ? this.targetView : this.sourceView;
            var magnet = end === "target" ? this.targetMagnet : this.sourceMagnet;
            spot = this.paper.options.linkConnectionPoint(this, view, magnet, reference)
        } else {
            spot = g.rect(spotBbox).intersectionWithLineFromCenterToPoint(reference);
            spot = spot || g.rect(spotBbox).center()
        }
    }
    return spot
},getConnectionLength: function() {
    return this._V.connection.node.getTotalLength()
},getPointAtLength: function(length) {
    return this._V.connection.node.getPointAtLength(length)
},_beforeArrowheadMove: function() {
    this.model.trigger("batch:start");
    this._z = this.model.get("z");
    this.model.toFront();
    this.el.style.pointerEvents = "none";
    if (this.paper.options.markAvailable) {
        this._markAvailableMagnets()
    }
},_afterArrowheadMove: function() {
    if (this._z) {
        this.model.set("z", this._z, {ui: true});
        delete this._z
    }
    this.el.style.pointerEvents = "visiblePainted";
    if (this.paper.options.markAvailable) {
        this._unmarkAvailableMagnets()
    }
    this.model.trigger("batch:stop")
},_createValidateConnectionArgs: function(arrowhead) {
    var args = [];
    args[4] = arrowhead;
    args[5] = this;
    var oppositeArrowhead, i = 0, j = 0;
    if (arrowhead === "source") {
        i = 2;
        oppositeArrowhead = "target"
    } else {
        j = 2;
        oppositeArrowhead = "source"
    }
    var end = this.model.get(oppositeArrowhead);
    if (end.id) {
        args[i] = this.paper.findViewByModel(end.id);
        args[i + 1] = end.selector && args[i].el.querySelector(end.selector)
    }
    function validateConnectionArgs(cellView, magnet) {
        args[j] = cellView;
        args[j + 1] = cellView.el === magnet ? undefined : magnet;
        return args
    }
    return validateConnectionArgs
},_markAvailableMagnets: function() {
    var elements = this.paper.model.getElements();
    var validate = this.paper.options.validateConnection;
    _.chain(elements).map(this.paper.findViewByModel, this.paper).each(function(view) {
        var isElementAvailable = view.el.getAttribute("magnet") !== "false" && validate.apply(this.paper, this._validateConnectionArgs(view, null));
        var availableMagnets = _.filter(view.el.querySelectorAll("[magnet]"), function(magnet) {
            return validate.apply(this.paper, this._validateConnectionArgs(view, magnet))
        }, this);
        if (isElementAvailable) {
            V(view.el).addClass("available-magnet")
        }
        _.each(availableMagnets, function(magnet) {
            V(magnet).addClass("available-magnet")
        });
        if (isElementAvailable || availableMagnets.length) {
            V(view.el).addClass("available-cell")
        }
    }, this)
},_unmarkAvailableMagnets: function() {
    _.each(this.paper.el.querySelectorAll(".available-cell, .available-magnet"), function(magnet) {
        V(magnet).removeClass("available-magnet").removeClass("available-cell")
    })
},startArrowheadMove: function(end) {
    this._action = "arrowhead-move";
    this._arrowhead = end;
    this._validateConnectionArgs = this._createValidateConnectionArgs(this._arrowhead);
    this._beforeArrowheadMove()
},pointerdown: function(evt, x, y) {
    joint.dia.CellView.prototype.pointerdown.apply(this, arguments);
    this._dx = x;
    this._dy = y;
    var interactive = _.isFunction(this.options.interactive) ? this.options.interactive(this, "pointerdown") : this.options.interactive;
    if (interactive === false)
        return;
    function can(feature) {
        if (!_.isObject(interactive) || interactive[feature] !== false)
            return true;
        return false
    }
    var className = evt.target.getAttribute("class");
    switch (className) {
        case "marker-vertex":
            if (can("vertexMove")) {
                this._action = "vertex-move";
                this._vertexIdx = evt.target.getAttribute("idx")
            }
            break;
        case "marker-vertex-remove":
        case "marker-vertex-remove-area":
            if (can("vertexRemove")) {
                this.removeVertex(evt.target.getAttribute("idx"))
            }
            break;
        case "marker-arrowhead":
            if (can("arrowheadMove")) {
                this.startArrowheadMove(evt.target.getAttribute("end"))
            }
            break;
        default:
            var targetParentEvent = evt.target.parentNode.getAttribute("event");
            if (targetParentEvent) {
                if (targetParentEvent === "remove") {
                    this.model.remove()
                } else {
                    this.paper.trigger(targetParentEvent, evt, this, x, y)
                }
            } else {
                if (can("vertexAdd")) {
                    this._vertexIdx = this.addVertex({x: x,y: y});
                    this._action = "vertex-move"
                }
            }
    }
    this.paper.trigger("link:pointerdown", evt, this, x, y)
},pointermove: function(evt, x, y) {
    joint.dia.CellView.prototype.pointermove.apply(this, arguments);
    switch (this._action) {
        case "vertex-move":
            var vertices = _.clone(this.model.get("vertices"));
            vertices[this._vertexIdx] = {x: x,y: y};
            this.model.set("vertices", vertices, {ui: true});
            break;
        case "arrowhead-move":
            if (this.paper.options.snapLinks) {
                var r = this.paper.options.snapLinks.radius || 50;
                var viewsInArea = this.paper.findViewsInArea({x: x - r,y: y - r,width: 2 * r,height: 2 * r});
                this._closestView && this._closestView.unhighlight(this._closestEnd.selector, {connecting: true,snapping: true});
                this._closestView = this._closestEnd = null;
                var pointer = g.point(x, y);
                var distance, minDistance = Number.MAX_VALUE;
                _.each(viewsInArea, function(view) {
                    if (view.el.getAttribute("magnet") !== "false") {
                        distance = view.model.getBBox().center().distance(pointer);
                        if (distance < r && distance < minDistance) {
                            if (this.paper.options.validateConnection.apply(this.paper, this._validateConnectionArgs(view, null))) {
                                minDistance = distance;
                                this._closestView = view;
                                this._closestEnd = {id: view.model.id}
                            }
                        }
                    }
                    view.$("[magnet]").each(_.bind(function(index, magnet) {
                        var bbox = V(magnet).bbox(false, this.paper.viewport);
                        distance = pointer.distance({x: bbox.x + bbox.width / 2,y: bbox.y + bbox.height / 2});
                        if (distance < r && distance < minDistance) {
                            if (this.paper.options.validateConnection.apply(this.paper, this._validateConnectionArgs(view, magnet))) {
                                minDistance = distance;
                                this._closestView = view;
                                this._closestEnd = {id: view.model.id,selector: view.getSelector(magnet),port: magnet.getAttribute("port")}
                            }
                        }
                    }, this))
                }, this);
                this._closestView && this._closestView.highlight(this._closestEnd.selector, {connecting: true,snapping: true});
                this.model.set(this._arrowhead, this._closestEnd || {x: x,y: y}, {ui: true})
            } else {
                var target = evt.type === "mousemove" ? evt.target : document.elementFromPoint(evt.clientX, evt.clientY);
                if (this._targetEvent !== target) {
                    this._magnetUnderPointer && this._viewUnderPointer.unhighlight(this._magnetUnderPointer, {connecting: true});
                    this._viewUnderPointer = this.paper.findView(target);
                    if (this._viewUnderPointer) {
                        this._magnetUnderPointer = this._viewUnderPointer.findMagnet(target);
                        if (this._magnetUnderPointer && this.paper.options.validateConnection.apply(this.paper, this._validateConnectionArgs(this._viewUnderPointer, this._magnetUnderPointer))) {
                            this._magnetUnderPointer && this._viewUnderPointer.highlight(this._magnetUnderPointer, {connecting: true})
                        } else {
                            this._magnetUnderPointer = null
                        }
                    } else {
                        this._magnetUnderPointer = null
                    }
                }
                this._targetEvent = target;
                this.model.set(this._arrowhead, {x: x,y: y}, {ui: true})
            }
            break
    }
    this._dx = x;
    this._dy = y
},pointerup: function(evt) {
    joint.dia.CellView.prototype.pointerup.apply(this, arguments);
    if (this._action === "arrowhead-move") {
        if (this.paper.options.snapLinks) {
            this._closestView && this._closestView.unhighlight(this._closestEnd.selector, {connecting: true,snapping: true});
            this._closestView = this._closestEnd = null
        } else {
            if (this._magnetUnderPointer) {
                this._viewUnderPointer.unhighlight(this._magnetUnderPointer, {connecting: true});
                this.model.set(this._arrowhead, {id: this._viewUnderPointer.model.id,selector: this._viewUnderPointer.getSelector(this._magnetUnderPointer),port: $(this._magnetUnderPointer).attr("port")}, {ui: true})
            }
            delete this._viewUnderPointer;
            delete this._magnetUnderPointer
        }
        if (this.paper.options.embeddingMode && this.model.reparent()) {
            delete this._z
        }
        this._afterArrowheadMove()
    }
    delete this._action
}}, {makeSelector: function(end) {
    var selector = '[model-id="' + end.id + '"]';
    if (end.port) {
        selector += ' [port="' + end.port + '"]'
    } else if (end.selector) {
        selector += " " + end.selector
    }
    return selector
}});


if (typeof exports === "object") {
    module.exports.Link = joint.dia.Link;
    module.exports.LinkView = joint.dia.LinkView
}


joint.dia.Paper = Backbone.View.extend({className: "paper",options: {width: 800,height: 600,origin: {x: 0,y: 0},gridSize: 50,perpendicularLinks: false,elementView: joint.dia.ElementView,linkView: joint.dia.LinkView,snapLinks: false,markAvailable: false,defaultLink: new joint.dia.Link,validateMagnet: function(cellView, magnet) {
    return magnet.getAttribute("magnet") !== "passive"
},validateConnection: function(cellViewS, magnetS, cellViewT, magnetT, end, linkView) {
    return (end === "target" ? cellViewT : cellViewS) instanceof joint.dia.ElementView
},embeddingMode: false,validateEmbedding: function(childView, parentView) {
    return true
},findParentBy: "bbox",frontParentOnly: true},events: {mousedown: "pointerdown",dblclick: "mousedblclick",click: "mouseclick",touchstart: "pointerdown",mousemove: "pointermove",touchmove: "pointermove","mouseover .element": "cellMouseover","mouseover .link": "cellMouseover","mouseout .element": "cellMouseout","mouseout .link": "cellMouseout"},constructor: function(options) {
    this._configure(options);
    Backbone.View.apply(this, arguments)
},_configure: function(options) {
    if (this.options)
        options = _.extend({}, _.result(this, "options"), options);
    this.options = options
},initialize: function() {
    _.bindAll(this, "addCell", "sortCells", "resetCells", "pointerup", "asyncRenderCells");
    this.svg = V("svg").node;
    this.viewport = V("g").addClass("viewport").node;
    this.defs = V("defs").node;
    V(this.svg).append([this.viewport, this.defs]);
    this.$el.append(this.svg);
    this.setOrigin();
    this.setDimensions();
    this.listenTo(this.model, "add", this.onAddCell);
    this.listenTo(this.model, "reset", this.resetCells);
    this.listenTo(this.model, "sort", this.sortCells);
    $(document).on("mouseup touchend", this.pointerup);
    this._mousemoved = false;
    this.on({"cell:highlight": this.onCellHighlight,"cell:unhighlight": this.onCellUnhighlight})
},remove: function() {
    this.removeCells();
    $(document).off("mouseup touchend", this.pointerup);
    Backbone.View.prototype.remove.call(this)
},setDimensions: function(width, height) {
    width = this.options.width = width || this.options.width;
    height = this.options.height = height || this.options.height;
    V(this.svg).attr({width: width,height: height});
    this.trigger("resize", width, height)
},setOrigin: function(ox, oy) {
    this.options.origin.x = ox || 0;
    this.options.origin.y = oy || 0;
    V(this.viewport).translate(ox, oy, {absolute: true});
    this.trigger("translate", ox, oy)
},fitToContent: function(gridWidth, gridHeight, padding, opt) {
    if (_.isObject(gridWidth)) {
        opt = gridWidth;
        gridWidth = opt.gridWidth || 1;
        gridHeight = opt.gridHeight || 1;
        padding = opt.padding || 0
    } else {
        opt = opt || {};
        gridWidth = gridWidth || 1;
        gridHeight = gridHeight || 1;
        padding = padding || 0
    }
    var bbox = V(this.viewport).bbox(true, this.svg);
    var currentScale = V(this.viewport).scale();
    bbox.x *= currentScale.sx;
    bbox.y *= currentScale.sy;
    bbox.width *= currentScale.sx;
    bbox.height *= currentScale.sy;
    var calcWidth = Math.max(Math.ceil((bbox.width + bbox.x) / gridWidth), 1) * gridWidth;
    var calcHeight = Math.max(Math.ceil((bbox.height + bbox.y) / gridHeight), 1) * gridHeight;
    var tx = 0;
    var ty = 0;
    if (opt.allowNewOrigin == "negative" && bbox.x < 0 || opt.allowNewOrigin == "positive" && bbox.x >= 0 || opt.allowNewOrigin == "any") {
        tx = Math.ceil(-bbox.x / gridWidth) * gridWidth;
        tx += padding;
        calcWidth += tx
    }
    if (opt.allowNewOrigin == "negative" && bbox.y < 0 || opt.allowNewOrigin == "positive" && bbox.y >= 0 || opt.allowNewOrigin == "any") {
        ty = Math.ceil(-bbox.y / gridHeight) * gridHeight;
        ty += padding;
        calcHeight += ty
    }
    calcWidth += padding;
    calcHeight += padding;
    calcWidth = Math.max(calcWidth, opt.minWidth || 0);
    calcHeight = Math.max(calcHeight, opt.minHeight || 0);
    var dimensionChange = calcWidth != this.options.width || calcHeight != this.options.height;
    var originChange = tx != this.options.origin.x || ty != this.options.origin.y;
    if (originChange) {
        this.setOrigin(tx, ty)
    }
    if (dimensionChange) {
        this.setDimensions(calcWidth, calcHeight)
    }
},scaleContentToFit: function(opt) {
    var contentBBox = this.getContentBBox();
    if (!contentBBox.width || !contentBBox.height)
        return;
    opt = opt || {};
    _.defaults(opt, {padding: 0,preserveAspectRatio: true,scaleGrid: null,minScale: 0,maxScale: Number.MAX_VALUE});
    var padding = opt.padding;
    var minScaleX = opt.minScaleX || opt.minScale;
    var maxScaleX = opt.maxScaleX || opt.maxScale;
    var minScaleY = opt.minScaleY || opt.minScale;
    var maxScaleY = opt.maxScaleY || opt.maxScale;
    var fittingBBox = opt.fittingBBox || {x: this.options.origin.x,y: this.options.origin.y,width: this.options.width,height: this.options.height};
    fittingBBox = g.rect(fittingBBox).moveAndExpand({x: padding,y: padding,width: -2 * padding,height: -2 * padding});
    var currentScale = V(this.viewport).scale();
    var newSx = fittingBBox.width / contentBBox.width * currentScale.sx;
    var newSy = fittingBBox.height / contentBBox.height * currentScale.sy;
    if (opt.preserveAspectRatio) {
        newSx = newSy = Math.min(newSx, newSy)
    }
    if (opt.scaleGrid) {
        var gridSize = opt.scaleGrid;
        newSx = gridSize * Math.floor(newSx / gridSize);
        newSy = gridSize * Math.floor(newSy / gridSize)
    }
    newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));
    newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));
    this.scale(newSx, newSy);
    var contentTranslation = this.getContentBBox();
    var newOx = fittingBBox.x - contentTranslation.x;
    var newOy = fittingBBox.y - contentTranslation.y;
    this.setOrigin(newOx, newOy)
},getContentBBox: function() {
    var crect = this.viewport.getBoundingClientRect();
    var screenCTM = this.viewport.getScreenCTM();
    var viewportCTM = this.viewport.getCTM();
    var bbox = g.rect({x: crect.left - screenCTM.e + viewportCTM.e,y: crect.top - screenCTM.f + viewportCTM.f,width: crect.width,height: crect.height});
    return bbox
},createViewForModel: function(cell) {
    var view;
    var type = cell.get("type");
    var module = type.split(".")[0];
    var entity = type.split(".")[1];
    if (joint.shapes[module] && joint.shapes[module][entity + "View"]) {
        view = new joint.shapes[module][entity + "View"]({model: cell,interactive: this.options.interactive})
    } else if (cell instanceof joint.dia.Element) {
        view = new this.options.elementView({model: cell,interactive: this.options.interactive})
    } else {
        view = new this.options.linkView({model: cell,interactive: this.options.interactive})
    }
    return view
},onAddCell: function(cell, graph, options) {
    if (this.options.async && options.async !== false && _.isNumber(options.position)) {
        this._asyncCells = this._asyncCells || [];
        this._asyncCells.push(cell);
        if (options.position == 0) {
            if (this._frameId)
                throw "another asynchronous rendering in progress";
            this.asyncRenderCells(this._asyncCells);
            delete this._asyncCells
        }
    } else {
        this.addCell(cell)
    }
},addCell: function(cell) {
    var view = this.createViewForModel(cell);
    V(this.viewport).append(view.el);
    view.paper = this;
    view.render();
    $(view.el).find("image").on("dragstart", function() {
        return false
    })
},beforeRenderCells: function(cells) {
    cells.sort(function(a, b) {
        return a instanceof joint.dia.Link ? 1 : -1
    });
    return cells
},afterRenderCells: function() {
    this.sortCells()
},resetCells: function(cellsCollection) {
    $(this.viewport).empty();
    var cells = cellsCollection.models.slice();
    cells = this.beforeRenderCells(cells);
    if (this._frameId) {
        joint.util.cancelFrame(this._frameId);
        delete this._frameId
    }
    if (this.options.async) {
        this.asyncRenderCells(cells)
    } else {
        _.each(cells, this.addCell, this);
        this.sortCells()
    }
},removeCells: function() {
    this.model.get("cells").each(function(cell) {
        var view = this.findViewByModel(cell);
        view && view.remove()
    }, this)
},asyncBatchAdded: _.identity,asyncRenderCells: function(cells, opt) {
    var done = false;
    if (this._frameId) {
        _.each(_.range(this.options.async && this.options.async.batchSize || 50), function() {
            var cell = cells.shift();
            done = !cell;
            if (!done)
                this.addCell(cell)
        }, this);
        this.asyncBatchAdded()
    }
    if (done) {
        delete this._frameId;
        this.afterRenderCells();
        this.trigger("render:done", opt)
    } else {
        this._frameId = joint.util.nextFrame(_.bind(function() {
            this.asyncRenderCells(cells, opt)
        }, this))
    }
},sortCells: function() {
    var $cells = $(this.viewport).children("[model-id]");
    var cells = this.model.get("cells");
    this.sortElements($cells, function(a, b) {
        var cellA = cells.get($(a).attr("model-id"));
        var cellB = cells.get($(b).attr("model-id"));
        return (cellA.get("z") || 0) > (cellB.get("z") || 0) ? 1 : -1
    })
},sortElements: function(elements, comparator) {
    var $elements = $(elements);
    var placements = $elements.map(function() {
        var sortElement = this;
        var parentNode = sortElement.parentNode;
        var nextSibling = parentNode.insertBefore(document.createTextNode(""), sortElement.nextSibling);
        return function() {
            if (parentNode === this) {
                throw new Error("You can't sort elements if any one is a descendant of another.")
            }
            parentNode.insertBefore(this, nextSibling);
            parentNode.removeChild(nextSibling)
        }
    });
    return Array.prototype.sort.call($elements, comparator).each(function(i) {
        placements[i].call(this)
    })
},scale: function(sx, sy, ox, oy) {
    sy = sy || sx;
    if (_.isUndefined(ox)) {
        ox = 0;
        oy = 0
    }
    V(this.viewport).attr("transform", "");
    var oldTx = this.options.origin.x;
    var oldTy = this.options.origin.y;
    if (ox || oy || oldTx || oldTy) {
        var newTx = oldTx - ox * (sx - 1);
        var newTy = oldTy - oy * (sy - 1);
        this.setOrigin(newTx, newTy)
    }
    V(this.viewport).scale(sx, sy);
    this.trigger("scale", sx, sy, ox, oy);
    return this
},rotate: function(deg, ox, oy) {
    if (_.isUndefined(ox)) {
        var bbox = this.viewport.getBBox();
        ox = bbox.width / 2;
        oy = bbox.height / 2
    }
    V(this.viewport).rotate(deg, ox, oy)
},findView: function(el) {
    var $el = this.$(el);
    if ($el.length === 0 || $el[0] === this.el) {
        return undefined
    }
    if ($el.data("view")) {
        return $el.data("view")
    }
    return this.findView($el.parent())
},findViewByModel: function(cell) {
    var id = _.isString(cell) ? cell : cell.id;
    var $view = this.$('[model-id="' + id + '"]');
    if ($view.length) {
        return $view.data("view")
    }
    return undefined
},findViewsFromPoint: function(p) {
    p = g.point(p);
    var views = _.map(this.model.getElements(), this.findViewByModel);
    return _.filter(views, function(view) {
        return view && g.rect(V(view.el).bbox(false, this.viewport)).containsPoint(p)
    }, this)
},findViewsInArea: function(r) {
    r = g.rect(r);
    var views = _.map(this.model.getElements(), this.findViewByModel);
    return _.filter(views, function(view) {
        return view && r.intersect(g.rect(V(view.el).bbox(false, this.viewport)))
    }, this)
},getModelById: function(id) {
    return this.model.getCell(id)
},snapToGrid: function(p) {
    var localPoint = V(this.viewport).toLocalPoint(p.x, p.y);
    return {x: g.snapToGrid(localPoint.x, this.options.gridSize),y: g.snapToGrid(localPoint.y, this.options.gridSize)}
},getDefaultLink: function(cellView, magnet) {
    return _.isFunction(this.options.defaultLink) ? this.options.defaultLink.call(this, cellView, magnet) : this.options.defaultLink.clone()
},onCellHighlight: function(cellView, el) {
    V(el).addClass("highlighted")
},onCellUnhighlight: function(cellView, el) {
    V(el).removeClass("highlighted")
},mousedblclick: function(evt) {
    evt.preventDefault();
    evt = joint.util.normalizeEvent(evt);
    var view = this.findView(evt.target);
    var localPoint = this.snapToGrid({x: evt.clientX,y: evt.clientY});
    if (view) {
        view.pointerdblclick(evt, localPoint.x, localPoint.y)
    } else {
        this.trigger("blank:pointerdblclick", evt, localPoint.x, localPoint.y)
    }
},mouseclick: function(evt) {
    if (!this._mousemoved) {
        evt = joint.util.normalizeEvent(evt);
        var view = this.findView(evt.target);
        var localPoint = this.snapToGrid({x: evt.clientX,y: evt.clientY});
        if (view) {
            view.pointerclick(evt, localPoint.x, localPoint.y)
        } else {
            this.trigger("blank:pointerclick", evt, localPoint.x, localPoint.y)
        }
    }
    this._mousemoved = false
},pointerdown: function(evt) {
    evt = joint.util.normalizeEvent(evt);
    var view = this.findView(evt.target);
    var localPoint = this.snapToGrid({x: evt.clientX,y: evt.clientY});
    if (view) {
        this.sourceView = view;
        view.pointerdown(evt, localPoint.x, localPoint.y)
    } else {
        this.trigger("blank:pointerdown", evt, localPoint.x, localPoint.y)
    }
},pointermove: function(evt) {
    evt.preventDefault();
    evt = joint.util.normalizeEvent(evt);
    if (this.sourceView) {
        this._mousemoved = true;
        var localPoint = this.snapToGrid({x: evt.clientX,y: evt.clientY});
        this.sourceView.pointermove(evt, localPoint.x, localPoint.y)
    }
},pointerup: function(evt) {
    evt = joint.util.normalizeEvent(evt);
    var localPoint = this.snapToGrid({x: evt.clientX,y: evt.clientY});
    if (this.sourceView) {
        this.sourceView.pointerup(evt, localPoint.x, localPoint.y);
        this.sourceView = null
    } else {
        this.trigger("blank:pointerup", evt, localPoint.x, localPoint.y)
    }
},cellMouseover: function(evt) {
    evt = joint.util.normalizeEvent(evt);
    var view = this.findView(evt.target);
    if (view) {
        view.mouseover(evt)
    }
},cellMouseout: function(evt) {
    evt = joint.util.normalizeEvent(evt);
    var view = this.findView(evt.target);
    if (view) {
        view.mouseout(evt)
    }
}});


if (typeof exports === "object") {
    var joint = {util: require("../src/core").util,shapes: {},dia: {Element: require("../src/joint.dia.element").Element,ElementView: require("../src/joint.dia.element").ElementView}};
    var _ = require("lodash")
}


joint.shapes.basic = {};
joint.shapes.basic.Generic = joint.dia.Element.extend({defaults: joint.util.deepSupplement({type: "basic.Generic",attrs: {".": {fill: "#FFFFFF",stroke: "none"}}}, joint.dia.Element.prototype.defaults)});
joint.shapes.basic.Rect = joint.shapes.basic.Generic.extend({markup: '<g class="rotatable"><g class="scalable"><rect/></g><text/></g>',defaults: joint.util.deepSupplement({type: "basic.Rect",attrs: {rect: {fill: "#FFFFFF",stroke: "black",width: 100,height: 60},text: {"font-size": 14,text: "","ref-x": .5,"ref-y": .5,ref: "rect","y-alignment": "middle","x-alignment": "middle",fill: "black","font-family": "Arial, helvetica, sans-serif"}}}, joint.shapes.basic.Generic.prototype.defaults)});
joint.shapes.basic.TextView = joint.dia.ElementView.extend({initialize: function() {
    joint.dia.ElementView.prototype.initialize.apply(this, arguments);
    this.listenTo(this.model, "change:attrs", this.resize)
}});
joint.shapes.basic.Text = joint.shapes.basic.Generic.extend({markup: '<g class="rotatable"><g class="scalable"><text/></g></g>',defaults: joint.util.deepSupplement({type: "basic.Text",attrs: {text: {"font-size": 18,fill: "black"}}}, joint.shapes.basic.Generic.prototype.defaults)});
joint.shapes.basic.Circle = joint.shapes.basic.Generic.extend({markup: '<g class="rotatable"><g class="scalable"><circle/></g><text/></g>',defaults: joint.util.deepSupplement({type: "basic.Circle",size: {width: 60,height: 60},attrs: {circle: {fill: "#FFFFFF",stroke: "black",r: 30,transform: "translate(30, 30)"},text: {"font-size": 14,text: "","text-anchor": "middle","ref-x": .5,"ref-y": .5,ref: "circle","y-alignment": "middle",fill: "black","font-family": "Arial, helvetica, sans-serif"}}}, joint.shapes.basic.Generic.prototype.defaults)});
joint.shapes.basic.Image = joint.shapes.basic.Generic.extend({markup: '<g class="rotatable"><g class="scalable"><image/></g><text/></g>',defaults: joint.util.deepSupplement({type: "basic.Image",attrs: {text: {"font-size": 14,text: "","text-anchor": "middle","ref-x": .5,"ref-dy": 20,ref: "image","y-alignment": "middle",fill: "black","font-family": "Arial, helvetica, sans-serif"}}}, joint.shapes.basic.Generic.prototype.defaults)});
joint.shapes.basic.Path = joint.shapes.basic.Generic.extend({markup: '<g class="rotatable"><g class="scalable"><path/></g><text/></g>',defaults: joint.util.deepSupplement({type: "basic.Path",size: {width: 60,height: 60},attrs: {path: {fill: "#FFFFFF",stroke: "black"},text: {"font-size": 14,text: "","text-anchor": "middle","ref-x": .5,"ref-dy": 20,ref: "path","y-alignment": "middle",fill: "black","font-family": "Arial, helvetica, sans-serif"}}}, joint.shapes.basic.Generic.prototype.defaults)});
joint.shapes.basic.Rhombus = joint.shapes.basic.Path.extend({defaults: joint.util.deepSupplement({type: "basic.Rhombus",attrs: {path: {d: "M 30 0 L 60 30 30 60 0 30 z"},text: {"ref-y": .5}}}, joint.shapes.basic.Path.prototype.defaults)});
joint.shapes.basic.PortsModelInterface = {initialize: function() {
    this.updatePortsAttrs();
    this.on("change:inPorts change:outPorts", this.updatePortsAttrs, this);
    this.constructor.__super__.constructor.__super__.initialize.apply(this, arguments)
},updatePortsAttrs: function(eventName) {
    var currAttrs = this.get("attrs");
    _.each(this._portSelectors, function(selector) {
        if (currAttrs[selector])
            delete currAttrs[selector]
    });
    this._portSelectors = [];
    var attrs = {};
    _.each(this.get("inPorts"), function(portName, index, ports) {
        var portAttributes = this.getPortAttrs(portName, index, ports.length, ".inPorts", "in");
        this._portSelectors = this._portSelectors.concat(_.keys(portAttributes));
        _.extend(attrs, portAttributes)
    }, this);
    _.each(this.get("outPorts"), function(portName, index, ports) {
        var portAttributes = this.getPortAttrs(portName, index, ports.length, ".outPorts", "out");
        this._portSelectors = this._portSelectors.concat(_.keys(portAttributes));
        _.extend(attrs, portAttributes)
    }, this);
    this.attr(attrs, {silent: true});
    this.processPorts();
    this.trigger("process:ports")
},getPortSelector: function(name) {
    var selector = ".inPorts";
    var index = this.get("inPorts").indexOf(name);
    if (index < 0) {
        selector = ".outPorts";
        index = this.get("outPorts").indexOf(name);
        if (index < 0)
            throw new Error("getPortSelector(): Port doesn't exist.")
    }
    return selector + ">g:nth-child(" + (index + 1) + ")>circle"
}};
joint.shapes.basic.PortsViewInterface = {initialize: function() {
    this.listenTo(this.model, "process:ports", this.update);
    joint.dia.ElementView.prototype.initialize.apply(this, arguments)
},update: function() {
    this.renderPorts();
    joint.dia.ElementView.prototype.update.apply(this, arguments)
},renderPorts: function() {
    var $inPorts = this.$(".inPorts").empty();
    var $outPorts = this.$(".outPorts").empty();
    var portTemplate = _.template(this.model.portMarkup);
    _.each(_.filter(this.model.ports, function(p) {
        return p.type === "in"
    }), function(port, index) {
        $inPorts.append(V(portTemplate({id: index,port: port})).node)
    });
    _.each(_.filter(this.model.ports, function(p) {
        return p.type === "out"
    }), function(port, index) {
        $outPorts.append(V(portTemplate({id: index,port: port})).node)
    })
}};
joint.shapes.basic.TextBlock = joint.shapes.basic.Generic.extend({markup: ['<g class="rotatable"><g class="scalable"><rect/></g><switch>', '<foreignObject requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" class="fobj">', '<body xmlns="http://www.w3.org/1999/xhtml"><div/></body>', "</foreignObject>", '<text class="content"/>', "</switch></g>"].join(""),defaults: joint.util.deepSupplement({type: "basic.TextBlock",attrs: {rect: {fill: "#ffffff",stroke: "#000000",width: 80,height: 100},text: {fill: "#000000","font-size": 14,"font-family": "Arial, helvetica, sans-serif"},".content": {text: "",ref: "rect","ref-x": .5,"ref-y": .5,"y-alignment": "middle","x-alignment": "middle"}},content: ""}, joint.shapes.basic.Generic.prototype.defaults),initialize: function() {
    if (typeof SVGForeignObjectElement !== "undefined") {
        this.setForeignObjectSize(this, this.get("size"));
        this.setDivContent(this, this.get("content"));
        this.listenTo(this, "change:size", this.setForeignObjectSize);
        this.listenTo(this, "change:content", this.setDivContent)
    }
    joint.shapes.basic.Generic.prototype.initialize.apply(this, arguments)
},setForeignObjectSize: function(cell, size) {
    cell.attr({".fobj": _.clone(size),div: {style: _.clone(size)}})
},setDivContent: function(cell, content) {
    cell.attr({div: {html: content}})
}});
joint.shapes.basic.TextBlockView = joint.dia.ElementView.extend({initialize: function() {
    joint.dia.ElementView.prototype.initialize.apply(this, arguments);
    if (typeof SVGForeignObjectElement === "undefined") {
        this.noSVGForeignObjectElement = true;
        this.listenTo(this.model, "change:content", function(cell) {
            this.updateContent(cell)
        })
    }
},update: function(cell, renderingOnlyAttrs) {
    if (this.noSVGForeignObjectElement) {
        var model = this.model;
        var noTextAttrs = _.omit(renderingOnlyAttrs || model.get("attrs"), ".content");
        joint.dia.ElementView.prototype.update.call(this, model, noTextAttrs);
        if (!renderingOnlyAttrs || _.has(renderingOnlyAttrs, ".content")) {
            this.updateContent(model, renderingOnlyAttrs)
        }
    } else {
        joint.dia.ElementView.prototype.update.call(this, model, renderingOnlyAttrs)
    }
},updateContent: function(cell, renderingOnlyAttrs) {
    var textAttrs = _.merge({}, (renderingOnlyAttrs || cell.get("attrs"))[".content"]);
    delete textAttrs.text;
    var text = joint.util.breakText(cell.get("content"), cell.get("size"), textAttrs, {svgDocument: this.paper.svg});
    var attrs = joint.util.setByPath({}, ".content", textAttrs, "/");
    attrs[".content"].text = text;
    joint.dia.ElementView.prototype.update.call(this, cell, attrs)
}})


if (typeof exports === "object") {
    module.exports = joint.shapes.basic
}


joint.routers.orthogonal = function() {
    var opposite = {N: "S",S: "N",E: "W",W: "E"};
    var radians = {N: -Math.PI / 2 * 3,S: -Math.PI / 2,E: 0,W: Math.PI};
    function bearing(from, to) {
        if (from.x == to.x)
            return from.y > to.y ? "N" : "S";
        if (from.y == to.y)
            return from.x > to.x ? "W" : "E";
        return null
    }
    function boxSize(bbox, brng) {
        return bbox[brng == "W" || brng == "E" ? "width" : "height"]
    }
    function expand(bbox, val) {
        return g.rect(bbox).moveAndExpand({x: -val,y: -val,width: 2 * val,height: 2 * val})
    }
    function pointBox(p) {
        return g.rect(p.x, p.y, 0, 0)
    }
    function boundary(bbox1, bbox2) {
        var x1 = Math.min(bbox1.x, bbox2.x);
        var y1 = Math.min(bbox1.y, bbox2.y);
        var x2 = Math.max(bbox1.x + bbox1.width, bbox2.x + bbox2.width);
        var y2 = Math.max(bbox1.y + bbox1.height, bbox2.y + bbox2.height);
        return g.rect(x1, y1, x2 - x1, y2 - y1)
    }
    function freeJoin(p1, p2, bbox) {
        var p = g.point(p1.x, p2.y);
        if (bbox.containsPoint(p))
            p = g.point(p2.x, p1.y);
        return p
    }
    function vertexVertex(from, to, brng) {
        var p1 = g.point(from.x, to.y);
        var p2 = g.point(to.x, from.y);
        var d1 = bearing(from, p1);
        var d2 = bearing(from, p2);
        var xBrng = opposite[brng];
        var p = d1 == brng || d1 != xBrng && (d2 == xBrng || d2 != brng) ? p1 : p2;
        return {points: [p],direction: bearing(p, to)}
    }
    function elementVertex(from, to, fromBBox) {
        var p = freeJoin(from, to, fromBBox);
        return {points: [p],direction: bearing(p, to)}
    }
    function vertexElement(from, to, toBBox, brng) {
        var route = {};
        var pts = [g.point(from.x, to.y), g.point(to.x, from.y)];
        var freePts = _.filter(pts, function(pt) {
            return !toBBox.containsPoint(pt)
        });
        var freeBrngPts = _.filter(freePts, function(pt) {
            return bearing(pt, from) != brng
        });
        var p;
        if (freeBrngPts.length > 0) {
            p = _.filter(freeBrngPts, function(pt) {
                return bearing(from, pt) == brng
            }).pop();
            p = p || freeBrngPts[0];
            route.points = [p];
            route.direction = bearing(p, to)
        } else {
            p = _.difference(pts, freePts)[0];
            var p2 = g.point(to).move(p, -boxSize(toBBox, brng) / 2);
            var p1 = freeJoin(p2, from, toBBox);
            route.points = [p1, p2];
            route.direction = bearing(p2, to)
        }
        return route
    }
    function elementElement(from, to, fromBBox, toBBox) {
        var route = elementVertex(to, from, toBBox);
        var p1 = route.points[0];
        if (fromBBox.containsPoint(p1)) {
            route = elementVertex(from, to, fromBBox);
            var p2 = route.points[0];
            if (toBBox.containsPoint(p2)) {
                var fromBorder = g.point(from).move(p2, -boxSize(fromBBox, bearing(from, p2)) / 2);
                var toBorder = g.point(to).move(p1, -boxSize(toBBox, bearing(to, p1)) / 2);
                var mid = g.line(fromBorder, toBorder).midpoint();
                var startRoute = elementVertex(from, mid, fromBBox);
                var endRoute = vertexVertex(mid, to, startRoute.direction);
                route.points = [startRoute.points[0], endRoute.points[0]];
                route.direction = endRoute.direction
            }
        }
        return route
    }
    function insideElement(from, to, fromBBox, toBBox, brng) {
        var route = {};
        var bndry = expand(boundary(fromBBox, toBBox), 1);
        var reversed = bndry.center().distance(to) > bndry.center().distance(from);
        var start = reversed ? to : from;
        var end = reversed ? from : to;
        var p1, p2, p3;
        if (brng) {
            p1 = g.point.fromPolar(bndry.width + bndry.height, radians[brng], start);
            p1 = bndry.pointNearestToPoint(p1).move(p1, -1)
        } else {
            p1 = bndry.pointNearestToPoint(start).move(start, 1)
        }
        p2 = freeJoin(p1, end, bndry);
        if (p1.round().equals(p2.round())) {
            p2 = g.point.fromPolar(bndry.width + bndry.height, g.toRad(p1.theta(start)) + Math.PI / 2, end);
            p2 = bndry.pointNearestToPoint(p2).move(end, 1).round();
            p3 = freeJoin(p1, p2, bndry);
            route.points = reversed ? [p2, p3, p1] : [p1, p3, p2]
        } else {
            route.points = reversed ? [p2, p1] : [p1, p2]
        }
        route.direction = reversed ? bearing(p1, to) : bearing(p2, to);
        return route
    }
    function findOrthogonalRoute(vertices, opt, linkView) {
        var padding = opt.elementPadding || 20;
        var orthogonalVertices = [];
        var sourceBBox = expand(linkView.sourceBBox, padding);
        var targetBBox = expand(linkView.targetBBox, padding);
        vertices = _.map(vertices, g.point);
        vertices.unshift(sourceBBox.center());
        vertices.push(targetBBox.center());
        var brng;
        for (var i = 0, max = vertices.length - 1; i < max; i++) {
            var route = null;
            var from = vertices[i];
            var to = vertices[i + 1];
            var isOrthogonal = !!bearing(from, to);
            if (i == 0) {
                if (i + 1 == max) {
                    if (sourceBBox.intersect(expand(targetBBox, 1))) {
                        route = insideElement(from, to, sourceBBox, targetBBox)
                    } else if (!isOrthogonal) {
                        route = elementElement(from, to, sourceBBox, targetBBox)
                    }
                } else {
                    if (sourceBBox.containsPoint(to)) {
                        route = insideElement(from, to, sourceBBox, expand(pointBox(to), padding))
                    } else if (!isOrthogonal) {
                        route = elementVertex(from, to, sourceBBox)
                    }
                }
            } else if (i + 1 == max) {
                var orthogonalLoop = isOrthogonal && bearing(to, from) == brng;
                if (targetBBox.containsPoint(from) || orthogonalLoop) {
                    route = insideElement(from, to, expand(pointBox(from), padding), targetBBox, brng)
                } else if (!isOrthogonal) {
                    route = vertexElement(from, to, targetBBox, brng)
                }
            } else if (!isOrthogonal) {
                route = vertexVertex(from, to, brng)
            }
            if (route) {
                Array.prototype.push.apply(orthogonalVertices, route.points);
                brng = route.direction
            } else {
                brng = bearing(from, to)
            }
            if (i + 1 < max) {
                orthogonalVertices.push(to)
            }
        }
        return orthogonalVertices
    }
    return findOrthogonalRoute
}();
joint.routers.manhattan = function() {
    "use strict";
    var config = {step: 10,perpendicular: true,mapGridSize: 100,excludeEnds: [],excludeTypes: ["basic.Text"],maximumLoops: 500,startDirections: ["left", "right", "top", "bottom"],endDirections: ["left", "right", "top", "bottom"],directionMap: {right: {x: 1,y: 0},bottom: {x: 0,y: 1},left: {x: -1,y: 0},top: {x: 0,y: -1}},maxAllowedDirectionChange: 1,paddingBox: function() {
        var step = this.step;
        return {x: -step,y: -step,width: 2 * step,height: 2 * step}
    },directions: function() {
        var step = this.step;
        return [{offsetX: step,offsetY: 0,cost: step}, {offsetX: 0,offsetY: step,cost: step}, {offsetX: -step,offsetY: 0,cost: step}, {offsetX: 0,offsetY: -step,cost: step}]
    },penalties: function() {
        return [0, this.step / 2, this.step]
    },estimateCost: function(from, to) {
        return from.manhattanDistance(to)
    },fallbackRoute: function(from, to, opts) {
        var prevDirIndexes = opts.prevDirIndexes || {};
        var point = (prevDirIndexes[from] || 0) % 2 ? g.point(from.x, to.y) : g.point(to.x, from.y);
        return [point, to]
    },draggingRoute: null};
    function reconstructRoute(parents, point) {
        var route = [];
        var prevDiff = {x: 0,y: 0};
        var current = point;
        var parent;
        while (parent = parents[current]) {
            var diff = parent.difference(current);
            if (!diff.equals(prevDiff)) {
                route.unshift(current);
                prevDiff = diff
            }
            current = parent
        }
        route.unshift(current);
        return route
    }
    function getRectPoints(bbox, directionList, opts) {
        var step = opts.step;
        var center = bbox.center();
        var startPoints = _.chain(opts.directionMap).pick(directionList).map(function(direction) {
            var x = direction.x * bbox.width / 2;
            var y = direction.y * bbox.height / 2;
            var point = g.point(center).offset(x, y).snapToGrid(step);
            if (bbox.containsPoint(point)) {
                point.offset(direction.x * step, direction.y * step)
            }
            return point
        }).value();
        return startPoints
    }
    function getDirection(start, end, dirLen) {
        var dirAngle = 360 / dirLen;
        var q = Math.floor(start.theta(end) / dirAngle);
        return dirLen - q
    }
    function findRoute(start, end, map, opt) {
        var startDirections = opt.reversed ? opt.endDirections : opt.startDirections;
        var endDirections = opt.reversed ? opt.startDirections : opt.endDirections;
        var startSet = start instanceof g.rect ? getRectPoints(start, startDirections, opt) : [start];
        var endSet = end instanceof g.rect ? getRectPoints(end, endDirections, opt) : [end];
        var startCenter = startSet.length > 1 ? start.center() : startSet[0];
        var endCenter = endSet.length > 1 ? end.center() : endSet[0];
        var endPoints = _.filter(endSet, function(point) {
            var mapKey = g.point(point).snapToGrid(opt.mapGridSize).toString();
            var accesible = _.every(map[mapKey], function(obstacle) {
                return !obstacle.containsPoint(point)
            });
            return accesible
        });
        if (endPoints.length) {
            var step = opt.step;
            var penalties = opt.penalties;
            var endPoint = _.chain(endPoints).invoke("snapToGrid", step).min(function(point) {
                return opt.estimateCost(startCenter, point)
            }).value();
            var parents = {};
            var costFromStart = {};
            var totalCost = {};
            var dirs = opt.directions;
            var dirLen = dirs.length;
            var dirHalfLen = dirLen / 2;
            var dirIndexes = opt.previousDirIndexes || {};
            var closeHash = {};
            var openHash = {};
            var openSet = _.chain(startSet).invoke("snapToGrid", step).each(function(point) {
                var key = point.toString();
                costFromStart[key] = 0;
                totalCost[key] = opt.estimateCost(point, endPoint);
                dirIndexes[key] = dirIndexes[key] || getDirection(startCenter, point, dirLen);
                openHash[key] = true
            }).map(function(point) {
                return point.toString()
            }).sortBy(function(pointKey) {
                return totalCost[pointKey]
            }).value();
            var loopCounter = opt.maximumLoops;
            var maxAllowedDirectionChange = opt.maxAllowedDirectionChange;
            while (openSet.length && loopCounter--) {
                var currentKey = openSet[0];
                var currentPoint = g.point(currentKey);
                if (endPoint.equals(currentPoint)) {
                    opt.previousDirIndexes = _.pick(dirIndexes, currentKey);
                    return reconstructRoute(parents, currentPoint)
                }
                openSet.splice(0, 1);
                openHash[neighborKey] = null;
                closeHash[neighborKey] = true;
                var currentDirIndex = dirIndexes[currentKey];
                var currentDist = costFromStart[currentKey];
                for (var dirIndex = 0; dirIndex < dirLen; dirIndex++) {
                    var dirChange = Math.abs(dirIndex - currentDirIndex);
                    if (dirChange > dirHalfLen) {
                        dirChange = dirLen - dirChange
                    }
                    if (dirChange > maxAllowedDirectionChange) {
                        continue
                    }
                    var dir = dirs[dirIndex];
                    var neighborPoint = g.point(currentPoint).offset(dir.offsetX, dir.offsetY);
                    var neighborKey = neighborPoint.toString();
                    if (closeHash[neighborKey]) {
                        continue
                    }
                    var mapKey = g.point(neighborPoint).snapToGrid(opt.mapGridSize).toString();
                    var isAccesible = _.every(map[mapKey], function(obstacle) {
                        return !obstacle.containsPoint(neighborPoint)
                    });
                    if (!isAccesible) {
                        continue
                    }
                    var inOpenSet = _.has(openHash, neighborKey);
                    var costToNeighbor = currentDist + dir.cost;
                    if (!inOpenSet || costToNeighbor < costFromStart[neighborKey]) {
                        parents[neighborKey] = currentPoint;
                        dirIndexes[neighborKey] = dirIndex;
                        costFromStart[neighborKey] = costToNeighbor;
                        totalCost[neighborKey] = costToNeighbor + opt.estimateCost(neighborPoint, endPoint) + penalties[dirChange];
                        if (!inOpenSet) {
                            var openIndex = _.sortedIndex(openSet, neighborKey, function(openKey) {
                                return totalCost[openKey]
                            });
                            openSet.splice(openIndex, 0, neighborKey);
                            openHash[neighborKey] = true
                        }
                    }
                }
            }
        }
        return opt.fallbackRoute(startCenter, endCenter, opt)
    }
    function router(oldVertices, opt) {
        opt.directions = _.result(opt, "directions");
        opt.penalties = _.result(opt, "penalties");
        opt.paddingBox = _.result(opt, "paddingBox");
        this.options.perpendicular = !!opt.perpendicular;
        var reverseRouting = opt.reversed = this.lastEndChange === "source";
        var sourceBBox = reverseRouting ? g.rect(this.targetBBox) : g.rect(this.sourceBBox);
        var targetBBox = reverseRouting ? g.rect(this.sourceBBox) : g.rect(this.targetBBox);
        sourceBBox.moveAndExpand(opt.paddingBox);
        targetBBox.moveAndExpand(opt.paddingBox);
        var link = this.model;
        var graph = this.paper.model;
        var excludedEnds = _.chain(opt.excludeEnds).map(link.get, link).pluck("id").map(graph.getCell, graph).value();
        var mapGridSize = opt.mapGridSize;
        var map = _.chain(graph.getElements()).difference(excludedEnds).reject(function(element) {
            return _.contains(opt.excludeTypes, element.get("type"))
        }).invoke("getBBox").invoke("moveAndExpand", opt.paddingBox).foldl(function(res, bbox) {
            var origin = bbox.origin().snapToGrid(mapGridSize);
            var corner = bbox.corner().snapToGrid(mapGridSize);
            for (var x = origin.x; x <= corner.x; x += mapGridSize) {
                for (var y = origin.y; y <= corner.y; y += mapGridSize) {
                    var gridKey = x + "@" + y;
                    res[gridKey] = res[gridKey] || [];
                    res[gridKey].push(bbox)
                }
            }
            return res
        }, {}).value();
        var newVertices = [];
        var points = _.map(oldVertices, g.point);
        var tailPoint = sourceBBox.center();
        for (var i = 0, len = points.length; i <= len; i++) {
            var partialRoute = null;
            var from = to || sourceBBox;
            var to = points[i];
            if (!to) {
                to = targetBBox;
                var endingAtPoint = !this.model.get("source").id || !this.model.get("target").id;
                if (endingAtPoint && _.isFunction(opt.draggingRoute)) {
                    var dragFrom = from instanceof g.rect ? from.center() : from;
                    partialRoute = opt.draggingRoute(dragFrom, to.origin(), opt)
                }
            }
            partialRoute = partialRoute || findRoute(from, to, map, opt);
            var leadPoint = _.first(partialRoute);
            if (leadPoint && leadPoint.equals(tailPoint)) {
                partialRoute.shift()
            }
            tailPoint = _.last(partialRoute) || tailPoint;
            newVertices = newVertices.concat(partialRoute)
        }
        return reverseRouting ? newVertices.reverse() : newVertices
    }
    return function(vertices, opt, linkView) {
        return router.call(linkView, vertices, _.extend({}, config, opt))
    }
}();
joint.routers.metro = function() {
    if (!_.isFunction(joint.routers.manhattan)) {
        throw "Metro requires the manhattan router."
    }
    var config = {diagonalCost: null,directions: function() {
        var step = this.step;
        var diagonalCost = this.diagonalCost || Math.ceil(Math.sqrt(step * step << 1));
        return [{offsetX: step,offsetY: 0,cost: step}, {offsetX: step,offsetY: step,cost: diagonalCost}, {offsetX: 0,offsetY: step,cost: step}, {offsetX: -step,offsetY: step,cost: diagonalCost}, {offsetX: -step,offsetY: 0,cost: step}, {offsetX: -step,offsetY: -step,cost: diagonalCost}, {offsetX: 0,offsetY: -step,cost: step}, {offsetX: step,offsetY: -step,cost: diagonalCost}]
    },fallbackRoute: function(from, to, opts) {
        var theta = from.theta(to);
        var a = {x: to.x,y: from.y};
        var b = {x: from.x,y: to.y};
        if (theta % 180 > 90) {
            var t = a;
            a = b;
            b = t
        }
        var p1 = theta % 90 < 45 ? a : b;
        var l1 = g.line(from, p1);
        var alpha = 90 * Math.ceil(theta / 90);
        var p2 = g.point.fromPolar(l1.squaredLength(), g.toRad(alpha + 135), p1);
        var l2 = g.line(to, p2);
        var point = l1.intersection(l2);
        return point ? [point.round(), to] : [to]
    }};
    return function(vertices, opts, linkView) {
        return joint.routers.manhattan(vertices, _.extend({}, config, opts), linkView)
    }
}();
joint.connectors.normal = function(sourcePoint, targetPoint, vertices) {
    var d = ["M", sourcePoint.x, sourcePoint.y];
    _.each(vertices, function(vertex) {
        d.push(vertex.x, vertex.y)
    });
    d.push(targetPoint.x, targetPoint.y);
    return d.join(" ")
};
joint.connectors.rounded = function(sourcePoint, targetPoint, vertices, opts) {
    var offset = opts.radius || 10;
    var c1, c2, d1, d2, prev, next;
    var d = ["M", sourcePoint.x, sourcePoint.y];
    _.each(vertices, function(vertex, index) {
        prev = vertices[index - 1] || sourcePoint;
        next = vertices[index + 1] || targetPoint;
        d1 = d2 || g.point(vertex).distance(prev) / 2;
        d2 = g.point(vertex).distance(next) / 2;
        c1 = g.point(vertex).move(prev, -Math.min(offset, d1)).round();
        c2 = g.point(vertex).move(next, -Math.min(offset, d2)).round();
        d.push(c1.x, c1.y, "S", vertex.x, vertex.y, c2.x, c2.y, "L")
    });
    d.push(targetPoint.x, targetPoint.y);
    return d.join(" ")
};
joint.connectors.smooth = function(sourcePoint, targetPoint, vertices) {
    var d;
    if (vertices.length) {
        d = g.bezier.curveThroughPoints([sourcePoint].concat(vertices).concat([targetPoint]))
    } else {
        var controlPointX = sourcePoint.x < targetPoint.x ? targetPoint.x - (targetPoint.x - sourcePoint.x) / 2 : sourcePoint.x - (sourcePoint.x - targetPoint.x) / 2;
        d = ["M", sourcePoint.x, sourcePoint.y, "C", controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y]
    }
    return d.join(" ")
};
if (typeof exports === "object") {
    var joint = {util: require("../src/core").util,shapes: {basic: require("./joint.shapes.basic")},dia: {ElementView: require("../src/joint.dia.element").ElementView,Link: require("../src/joint.dia.link").Link}};
    var _ = require("lodash")
}
joint.shapes.devs = {};
joint.shapes.devs.Model = joint.shapes.basic.Generic.extend(_.extend({}, joint.shapes.basic.PortsModelInterface, {markup: '<g class="rotatable"><g class="scalable"><rect class="body"/></g><text class="label"/><g class="inPorts"/><g class="outPorts"/></g>',portMarkup: '<g class="port port<%= id %>"><circle class="port-body"/><text class="port-label"/></g>',defaults: joint.util.deepSupplement({type: "devs.Model",size: {width: 1,height: 1},inPorts: [],outPorts: [],attrs: {".": {magnet: false},".body": {width: 150,height: 250,stroke: "#000000"},".port-body": {r: 10,magnet: true,stroke: "#000000"},text: {"pointer-events": "none"},".label": {text: "Model","ref-x": .5,"ref-y": 10,ref: ".body","text-anchor": "middle",fill: "#000000"},".inPorts .port-label": {x: -15,dy: 4,"text-anchor": "end",fill: "#000000"},".outPorts .port-label": {x: 15,dy: 4,fill: "#000000"}}}, joint.shapes.basic.Generic.prototype.defaults),getPortAttrs: function(portName, index, total, selector, type) {
    var attrs = {};
    var portClass = "port" + index;
    var portSelector = selector + ">." + portClass;
    var portLabelSelector = portSelector + ">.port-label";
    var portBodySelector = portSelector + ">.port-body";
    attrs[portLabelSelector] = {text: portName};
    attrs[portBodySelector] = {port: {id: portName || _.uniqueId(type),type: type}};
    attrs[portSelector] = {ref: ".body","ref-y": (index + .5) * (1 / total)};
    if (selector === ".outPorts") {
        attrs[portSelector]["ref-dx"] = 0
    }
    return attrs
}}));
joint.shapes.devs.Atomic = joint.shapes.devs.Model.extend({defaults: joint.util.deepSupplement({type: "devs.Atomic",size: {width: 80,height: 80},attrs: {".body": {fill: "salmon"},".label": {text: "Atomic"},".inPorts .port-body": {fill: "PaleGreen"},".outPorts .port-body": {fill: "Tomato"}}}, joint.shapes.devs.Model.prototype.defaults)});
joint.shapes.devs.Coupled = joint.shapes.devs.Model.extend({defaults: joint.util.deepSupplement({type: "devs.Coupled",size: {width: 200,height: 300},attrs: {".body": {fill: "seaGreen"},".label": {text: "Coupled"},".inPorts .port-body": {fill: "PaleGreen"},".outPorts .port-body": {fill: "Tomato"}}}, joint.shapes.devs.Model.prototype.defaults)});
joint.shapes.devs.Link = joint.dia.Link.extend({defaults: {type: "devs.Link",attrs: {".connection": {"stroke-width": 2}}}});
joint.shapes.devs.ModelView = joint.dia.ElementView.extend(joint.shapes.basic.PortsViewInterface);
joint.shapes.devs.AtomicView = joint.shapes.devs.ModelView;
joint.shapes.devs.CoupledView = joint.shapes.devs.ModelView;
if (typeof exports === "object") {
    module.exports = joint.shapes.devs
}
if (typeof exports === "object") {
    var joint = {util: require("../src/core").util,shapes: {basic: require("./joint.shapes.basic")},dia: {Element: require("../src/joint.dia.element").Element,Link: require("../src/joint.dia.link").Link}}
}
joint.shapes.fsa = {};
joint.shapes.fsa.State = joint.shapes.basic.Circle.extend({defaults: joint.util.deepSupplement({type: "fsa.State",attrs: {circle: {"stroke-width": 3},text: {"font-weight": "800"}}}, joint.shapes.basic.Circle.prototype.defaults)});
joint.shapes.fsa.StartState = joint.dia.Element.extend({markup: '<g class="rotatable"><g class="scalable"><circle/></g></g>',defaults: joint.util.deepSupplement({type: "fsa.StartState",size: {width: 20,height: 20},attrs: {circle: {transform: "translate(10, 10)",r: 10,fill: "#000000"}}}, joint.dia.Element.prototype.defaults)});
joint.shapes.fsa.EndState = joint.dia.Element.extend({markup: '<g class="rotatable"><g class="scalable"><circle class="outer"/><circle class="inner"/></g></g>',defaults: joint.util.deepSupplement({type: "fsa.EndState",size: {width: 20,height: 20},attrs: {".outer": {transform: "translate(10, 10)",r: 10,fill: "#ffffff",stroke: "#000000"},".inner": {transform: "translate(10, 10)",r: 6,fill: "#000000"}}}, joint.dia.Element.prototype.defaults)});
joint.shapes.fsa.Arrow = joint.dia.Link.extend({defaults: joint.util.deepSupplement({type: "fsa.Arrow",attrs: {".marker-target": {d: "M 10 0 L 0 5 L 10 10 z"}},smooth: true}, joint.dia.Link.prototype.defaults)});
if (typeof exports === "object") {
    module.exports = joint.shapes.fsa
}
if (typeof exports === "object") {
    var joint = {util: require("../src/core").util,shapes: {basic: require("./joint.shapes.basic")},dia: {ElementView: require("../src/joint.dia.element").ElementView,Link: require("../src/joint.dia.link").Link}}
}
joint.shapes.pn = {};
joint.shapes.pn.Place = joint.shapes.basic.Generic.extend({markup: '<g class="rotatable"><g class="scalable"><circle class="root"/><g class="tokens" /></g><text class="label"/></g>',defaults: joint.util.deepSupplement({type: "pn.Place",size: {width: 50,height: 50},attrs: {".root": {r: 25,fill: "#ffffff",stroke: "#000000",transform: "translate(25, 25)"},".label": {"text-anchor": "middle","ref-x": .5,"ref-y": -20,ref: ".root",fill: "#000000","font-size": 12},".tokens > circle": {fill: "#000000",r: 5},".tokens.one > circle": {transform: "translate(25, 25)"},".tokens.two > circle:nth-child(1)": {transform: "translate(19, 25)"},".tokens.two > circle:nth-child(2)": {transform: "translate(31, 25)"},".tokens.three > circle:nth-child(1)": {transform: "translate(18, 29)"},".tokens.three > circle:nth-child(2)": {transform: "translate(25, 19)"},".tokens.three > circle:nth-child(3)": {transform: "translate(32, 29)"},".tokens.alot > text": {transform: "translate(25, 18)","text-anchor": "middle",fill: "#000000"}}}, joint.shapes.basic.Generic.prototype.defaults)});
joint.shapes.pn.PlaceView = joint.dia.ElementView.extend({initialize: function() {
    joint.dia.ElementView.prototype.initialize.apply(this, arguments);
    this.model.on("change:tokens", function() {
        this.renderTokens();
        this.update()
    }, this)
},render: function() {
    joint.dia.ElementView.prototype.render.apply(this, arguments);
    this.renderTokens();
    this.update()
},renderTokens: function() {
    var $tokens = this.$(".tokens").empty();
    $tokens[0].className.baseVal = "tokens";
    var tokens = this.model.get("tokens");
    if (!tokens)
        return;
    switch (tokens) {
        case 1:
            $tokens[0].className.baseVal += " one";
            $tokens.append(V("<circle/>").node);
            break;
        case 2:
            $tokens[0].className.baseVal += " two";
            $tokens.append(V("<circle/>").node, V("<circle/>").node);
            break;
        case 3:
            $tokens[0].className.baseVal += " three";
            $tokens.append(V("<circle/>").node, V("<circle/>").node, V("<circle/>").node);
            break;
        default:
            $tokens[0].className.baseVal += " alot";
            $tokens.append(V("<text/>").text(tokens + "").node);
            break
    }
}});
joint.shapes.pn.Transition = joint.shapes.basic.Generic.extend({markup: '<g class="rotatable"><g class="scalable"><rect class="root"/></g></g><text class="label"/>',defaults: joint.util.deepSupplement({type: "pn.Transition",size: {width: 12,height: 50},attrs: {rect: {width: 12,height: 50,fill: "#000000",stroke: "#000000"},".label": {"text-anchor": "middle","ref-x": .5,"ref-y": -20,ref: "rect",fill: "#000000","font-size": 12}}}, joint.shapes.basic.Generic.prototype.defaults)});
joint.shapes.pn.Link = joint.dia.Link.extend({defaults: joint.util.deepSupplement({attrs: {".marker-target": {d: "M 10 0 L 0 5 L 10 10 z"}}}, joint.dia.Link.prototype.defaults)});
if (typeof exports === "object") {
    module.exports = joint.shapes.pn
}
if (typeof exports === "object") {
    var joint = {util: require("../src/core").util,shapes: {},dia: {Element: require("../src/joint.dia.element").Element,Link: require("../src/joint.dia.link").Link}}
}
joint.shapes.erd = {};
joint.shapes.erd.Entity = joint.dia.Element.extend({markup: '<g class="rotatable"><g class="scalable"><polygon class="outer"/><polygon class="inner"/></g><text/></g>',defaults: joint.util.deepSupplement({type: "erd.Entity",size: {width: 150,height: 60},attrs: {".outer": {fill: "#2ECC71",stroke: "#27AE60","stroke-width": 2,points: "100,0 100,60 0,60 0,0"},".inner": {fill: "#2ECC71",stroke: "#27AE60","stroke-width": 2,points: "95,5 95,55 5,55 5,5",display: "none"},text: {text: "Entity","font-family": "Arial","font-size": 14,ref: ".outer","ref-x": .5,"ref-y": .5,"x-alignment": "middle","y-alignment": "middle"}}}, joint.dia.Element.prototype.defaults)});
joint.shapes.erd.WeakEntity = joint.shapes.erd.Entity.extend({defaults: joint.util.deepSupplement({type: "erd.WeakEntity",attrs: {".inner": {display: "auto"},text: {text: "Weak Entity"}}}, joint.shapes.erd.Entity.prototype.defaults)});
joint.shapes.erd.Relationship = joint.dia.Element.extend({markup: '<g class="rotatable"><g class="scalable"><polygon class="outer"/><polygon class="inner"/></g><text/></g>',defaults: joint.util.deepSupplement({type: "erd.Relationship",size: {width: 80,height: 80},attrs: {".outer": {fill: "#3498DB",stroke: "#2980B9","stroke-width": 2,points: "40,0 80,40 40,80 0,40"},".inner": {fill: "#3498DB",stroke: "#2980B9","stroke-width": 2,points: "40,5 75,40 40,75 5,40",display: "none"},text: {text: "Relationship","font-family": "Arial","font-size": 12,ref: ".","ref-x": .5,"ref-y": .5,"x-alignment": "middle","y-alignment": "middle"}}}, joint.dia.Element.prototype.defaults)});
joint.shapes.erd.IdentifyingRelationship = joint.shapes.erd.Relationship.extend({defaults: joint.util.deepSupplement({type: "erd.IdentifyingRelationship",attrs: {".inner": {display: "auto"},text: {text: "Identifying"}}}, joint.shapes.erd.Relationship.prototype.defaults)});
joint.shapes.erd.Attribute = joint.dia.Element.extend({markup: '<g class="rotatable"><g class="scalable"><ellipse class="outer"/><ellipse class="inner"/></g><text/></g>',defaults: joint.util.deepSupplement({type: "erd.Attribute",size: {width: 100,height: 50},attrs: {ellipse: {transform: "translate(50, 25)"},".outer": {stroke: "#D35400","stroke-width": 2,cx: 0,cy: 0,rx: 50,ry: 25,fill: "#E67E22"},".inner": {stroke: "#D35400","stroke-width": 2,cx: 0,cy: 0,rx: 45,ry: 20,fill: "#E67E22",display: "none"},text: {"font-family": "Arial","font-size": 14,ref: ".","ref-x": .5,"ref-y": .5,"x-alignment": "middle","y-alignment": "middle"}}}, joint.dia.Element.prototype.defaults)});
joint.shapes.erd.Multivalued = joint.shapes.erd.Attribute.extend({defaults: joint.util.deepSupplement({type: "erd.Multivalued",attrs: {".inner": {display: "block"},text: {text: "multivalued"}}}, joint.shapes.erd.Attribute.prototype.defaults)});
joint.shapes.erd.Derived = joint.shapes.erd.Attribute.extend({defaults: joint.util.deepSupplement({type: "erd.Derived",attrs: {".outer": {"stroke-dasharray": "3,5"},text: {text: "derived"}}}, joint.shapes.erd.Attribute.prototype.defaults)});
joint.shapes.erd.Key = joint.shapes.erd.Attribute.extend({defaults: joint.util.deepSupplement({type: "erd.Key",attrs: {ellipse: {"stroke-width": 4},text: {text: "key","font-weight": "800","text-decoration": "underline"}}}, joint.shapes.erd.Attribute.prototype.defaults)});
joint.shapes.erd.Normal = joint.shapes.erd.Attribute.extend({defaults: joint.util.deepSupplement({type: "erd.Normal",attrs: {text: {text: "Normal"}}}, joint.shapes.erd.Attribute.prototype.defaults)});
joint.shapes.erd.ISA = joint.dia.Element.extend({markup: '<g class="rotatable"><g class="scalable"><polygon/></g><text/></g>',defaults: joint.util.deepSupplement({type: "erd.ISA",size: {width: 100,height: 50},attrs: {polygon: {points: "0,0 50,50 100,0",fill: "#F1C40F",stroke: "#F39C12","stroke-width": 2},text: {text: "ISA","font-size": 18,ref: "polygon","ref-x": .5,"ref-y": .3,"x-alignment": "middle","y-alignment": "middle"}}}, joint.dia.Element.prototype.defaults)});
joint.shapes.erd.Line = joint.dia.Link.extend({defaults: {type: "erd.Line"},cardinality: function(value) {
    this.set("labels", [{position: -20,attrs: {text: {dy: -8,text: value}}}])
}});
if (typeof exports === "object") {
    module.exports = joint.shapes.erd
}
if (typeof exports === "object") {
    var joint = {util: require("../src/core").util,shapes: {basic: require("./joint.shapes.basic")},dia: {ElementView: require("../src/joint.dia.element").ElementView,Link: require("../src/joint.dia.link").Link}};
    var _ = require("lodash")
}
joint.shapes.uml = {};
joint.shapes.uml.Class = joint.shapes.basic.Generic.extend({markup: ['<g class="rotatable">', '<g class="scalable">', '<rect class="uml-class-name-rect"/><rect class="uml-class-attrs-rect"/><rect class="uml-class-methods-rect"/>', "</g>", '<text class="uml-class-name-text"/><text class="uml-class-attrs-text"/><text class="uml-class-methods-text"/>', "</g>"].join(""),defaults: joint.util.deepSupplement({type: "uml.Class",attrs: {rect: {width: 200},".uml-class-name-rect": {stroke: "black","stroke-width": 2,fill: "#3498db"},".uml-class-attrs-rect": {stroke: "black","stroke-width": 2,fill: "#2980b9"},".uml-class-methods-rect": {stroke: "black","stroke-width": 2,fill: "#2980b9"},".uml-class-name-text": {ref: ".uml-class-name-rect","ref-y": .5,"ref-x": .5,"text-anchor": "middle","y-alignment": "middle","font-weight": "bold",fill: "black","font-size": 12,"font-family": "Times New Roman"},".uml-class-attrs-text": {ref: ".uml-class-attrs-rect","ref-y": 5,"ref-x": 5,fill: "black","font-size": 12,"font-family": "Times New Roman"},".uml-class-methods-text": {ref: ".uml-class-methods-rect","ref-y": 5,"ref-x": 5,fill: "black","font-size": 12,"font-family": "Times New Roman"}},name: [],attributes: [],methods: []}, joint.shapes.basic.Generic.prototype.defaults),initialize: function() {
    this.on("change:name change:attributes change:methods", function() {
        this.updateRectangles();
        this.trigger("uml-update")
    }, this);
    this.updateRectangles();
    joint.shapes.basic.Generic.prototype.initialize.apply(this, arguments)
},getClassName: function() {
    return this.get("name")
},updateRectangles: function() {
    var attrs = this.get("attrs");
    var rects = [{type: "name",text: this.getClassName()}, {type: "attrs",text: this.get("attributes")}, {type: "methods",text: this.get("methods")}];
    var offsetY = 0;
    _.each(rects, function(rect) {
        var lines = _.isArray(rect.text) ? rect.text : [rect.text];
        var rectHeight = lines.length * 20 + 20;
        attrs[".uml-class-" + rect.type + "-text"].text = lines.join("\n");
        attrs[".uml-class-" + rect.type + "-rect"].height = rectHeight;
        attrs[".uml-class-" + rect.type + "-rect"].transform = "translate(0," + offsetY + ")";
        offsetY += rectHeight
    })
}});
joint.shapes.uml.ClassView = joint.dia.ElementView.extend({initialize: function() {
    joint.dia.ElementView.prototype.initialize.apply(this, arguments);
    this.listenTo(this.model, "uml-update", function() {
        this.update();
        this.resize()
    })
}});
joint.shapes.uml.Abstract = joint.shapes.uml.Class.extend({defaults: joint.util.deepSupplement({type: "uml.Abstract",attrs: {".uml-class-name-rect": {fill: "#e74c3c"},".uml-class-attrs-rect": {fill: "#c0392b"},".uml-class-methods-rect": {fill: "#c0392b"}}}, joint.shapes.uml.Class.prototype.defaults),getClassName: function() {
    return ["<<Abstract>>", this.get("name")]
}});
joint.shapes.uml.AbstractView = joint.shapes.uml.ClassView;
joint.shapes.uml.Interface = joint.shapes.uml.Class.extend({defaults: joint.util.deepSupplement({type: "uml.Interface",attrs: {".uml-class-name-rect": {fill: "#f1c40f"},".uml-class-attrs-rect": {fill: "#f39c12"},".uml-class-methods-rect": {fill: "#f39c12"}}}, joint.shapes.uml.Class.prototype.defaults),getClassName: function() {
    return ["<<Interface>>", this.get("name")]
}});
joint.shapes.uml.InterfaceView = joint.shapes.uml.ClassView;
joint.shapes.uml.Generalization = joint.dia.Link.extend({defaults: {type: "uml.Generalization",attrs: {".marker-target": {d: "M 20 0 L 0 10 L 20 20 z",fill: "white"}}}});
joint.shapes.uml.Implementation = joint.dia.Link.extend({defaults: {type: "uml.Implementation",attrs: {".marker-target": {d: "M 20 0 L 0 10 L 20 20 z",fill: "white"},".connection": {"stroke-dasharray": "3,3"}}}});
joint.shapes.uml.Aggregation = joint.dia.Link.extend({defaults: {type: "uml.Aggregation",attrs: {".marker-target": {d: "M 40 10 L 20 20 L 0 10 L 20 0 z",fill: "white"}}}});
joint.shapes.uml.Composition = joint.dia.Link.extend({defaults: {type: "uml.Composition",attrs: {".marker-target": {d: "M 40 10 L 20 20 L 0 10 L 20 0 z",fill: "black"}}}});
joint.shapes.uml.Association = joint.dia.Link.extend({defaults: {type: "uml.Association"}});
joint.shapes.uml.State = joint.shapes.basic.Generic.extend({markup: ['<g class="rotatable">', '<g class="scalable">', '<rect class="uml-state-body"/>', "</g>", '<path class="uml-state-separator"/>', '<text class="uml-state-name"/>', '<text class="uml-state-events"/>', "</g>"].join(""),defaults: joint.util.deepSupplement({type: "uml.State",attrs: {".uml-state-body": {width: 200,height: 200,rx: 10,ry: 10,fill: "#ecf0f1",stroke: "#bdc3c7","stroke-width": 3},".uml-state-separator": {stroke: "#bdc3c7","stroke-width": 2},".uml-state-name": {ref: ".uml-state-body","ref-x": .5,"ref-y": 5,"text-anchor": "middle",fill: "#000000","font-family": "Courier New","font-size": 14},".uml-state-events": {ref: ".uml-state-separator","ref-x": 5,"ref-y": 5,fill: "#000000","font-family": "Courier New","font-size": 14}},name: "State",events: []}, joint.shapes.basic.Generic.prototype.defaults),initialize: function() {
    this.on({"change:name": this.updateName,"change:events": this.updateEvents,"change:size": this.updatePath}, this);
    this.updateName();
    this.updateEvents();
    this.updatePath();
    joint.shapes.basic.Generic.prototype.initialize.apply(this, arguments)
},updateName: function() {
    this.attr(".uml-state-name/text", this.get("name"))
},updateEvents: function() {
    this.attr(".uml-state-events/text", this.get("events").join("\n"))
},updatePath: function() {
    var d = "M 0 20 L " + this.get("size").width + " 20";
    this.attr(".uml-state-separator/d", d, {silent: true})
}});
joint.shapes.uml.StartState = joint.shapes.basic.Circle.extend({defaults: joint.util.deepSupplement({type: "uml.StartState",attrs: {circle: {fill: "#34495e",stroke: "#2c3e50","stroke-width": 2,rx: 1}}}, joint.shapes.basic.Circle.prototype.defaults)});
joint.shapes.uml.EndState = joint.shapes.basic.Generic.extend({markup: '<g class="rotatable"><g class="scalable"><circle class="outer"/><circle class="inner"/></g></g>',defaults: joint.util.deepSupplement({type: "uml.EndState",size: {width: 20,height: 20},attrs: {"circle.outer": {transform: "translate(10, 10)",r: 10,fill: "#ffffff",stroke: "#2c3e50"},"circle.inner": {transform: "translate(10, 10)",r: 6,fill: "#34495e"}}}, joint.shapes.basic.Generic.prototype.defaults)});
joint.shapes.uml.Transition = joint.dia.Link.extend({defaults: {type: "uml.Transition",attrs: {".marker-target": {d: "M 10 0 L 0 5 L 10 10 z",fill: "#34495e",stroke: "#2c3e50"},".connection": {stroke: "#2c3e50"}}}});
if (typeof exports === "object") {
    module.exports = joint.shapes.uml
}
if (typeof exports === "object") {
    var joint = {util: require("../src/core").util,shapes: {},dia: {Element: require("../src/joint.dia.element").Element,Link: require("../src/joint.dia.link").Link}}
}
joint.shapes.org = {};
joint.shapes.org.Member = joint.dia.Element.extend({markup: '<g class="rotatable"><g class="scalable"><rect class="card"/><image/></g><text class="rank"/><text class="name"/></g>',defaults: joint.util.deepSupplement({type: "org.Member",size: {width: 180,height: 70},attrs: {rect: {width: 170,height: 60},".card": {fill: "#FFFFFF",stroke: "#000000","stroke-width": 2,"pointer-events": "visiblePainted",rx: 10,ry: 10},image: {width: 48,height: 48,ref: ".card","ref-x": 10,"ref-y": 5},".rank": {"text-decoration": "underline",ref: ".card","ref-x": .9,"ref-y": .2,"font-family": "Courier New","font-size": 14,"text-anchor": "end"},".name": {"font-weight": "800",ref: ".card","ref-x": .9,"ref-y": .6,"font-family": "Courier New","font-size": 14,"text-anchor": "end"}}}, joint.dia.Element.prototype.defaults)});
joint.shapes.org.Arrow = joint.dia.Link.extend({defaults: {type: "org.Arrow",source: {selector: ".card"},target: {selector: ".card"},attrs: {".connection": {stroke: "#585858","stroke-width": 3}},z: -1}});
if (typeof exports === "object") {
    module.exports = joint.shapes.org
}
if (typeof exports === "object") {
    var joint = {util: require("../src/core").util,shapes: {basic: require("./joint.shapes.basic")},dia: {Link: require("../src/joint.dia.link").Link}}
}
joint.shapes.logic = {};
joint.shapes.logic.Gate = joint.shapes.basic.Generic.extend({defaults: joint.util.deepSupplement({type: "logic.Gate",size: {width: 80,height: 40},attrs: {".": {magnet: false},".body": {width: 100,height: 50},circle: {r: 7,stroke: "black",fill: "transparent","stroke-width": 2}}}, joint.shapes.basic.Generic.prototype.defaults),operation: function() {
    return true
}});
joint.shapes.logic.IO = joint.shapes.logic.Gate.extend({markup: '<g class="rotatable"><g class="scalable"><rect class="body"/></g><path class="wire"/><circle/><text/></g>',defaults: joint.util.deepSupplement({type: "logic.IO",size: {width: 60,height: 30},attrs: {".body": {fill: "white",stroke: "black","stroke-width": 2},".wire": {ref: ".body","ref-y": .5,stroke: "black"},text: {fill: "black",ref: ".body","ref-x": .5,"ref-y": .5,"y-alignment": "middle","text-anchor": "middle","font-weight": "bold","font-variant": "small-caps","text-transform": "capitalize","font-size": "14px"}}}, joint.shapes.logic.Gate.prototype.defaults)});
joint.shapes.logic.Input = joint.shapes.logic.IO.extend({defaults: joint.util.deepSupplement({type: "logic.Input",attrs: {".wire": {"ref-dx": 0,d: "M 0 0 L 23 0"},circle: {ref: ".body","ref-dx": 30,"ref-y": .5,magnet: true,"class": "output",port: "out"},text: {text: "input"}}}, joint.shapes.logic.IO.prototype.defaults)});
joint.shapes.logic.Output = joint.shapes.logic.IO.extend({defaults: joint.util.deepSupplement({type: "logic.Output",attrs: {".wire": {"ref-x": 0,d: "M 0 0 L -23 0"},circle: {ref: ".body","ref-x": -30,"ref-y": .5,magnet: "passive","class": "input",port: "in"},text: {text: "output"}}}, joint.shapes.logic.IO.prototype.defaults)});
joint.shapes.logic.Gate11 = joint.shapes.logic.Gate.extend({markup: '<g class="rotatable"><g class="scalable"><image class="body"/></g><circle class="input"/><circle class="output"/></g>',defaults: joint.util.deepSupplement({type: "logic.Gate11",attrs: {".input": {ref: ".body","ref-x": -2,"ref-y": .5,magnet: "passive",port: "in"},".output": {ref: ".body","ref-dx": 2,"ref-y": .5,magnet: true,port: "out"}}}, joint.shapes.logic.Gate.prototype.defaults)});
joint.shapes.logic.Gate21 = joint.shapes.logic.Gate.extend({markup: '<g class="rotatable"><g class="scalable"><image class="body"/></g><circle class="input input1"/><circle  class="input input2"/><circle class="output"/></g>',defaults: joint.util.deepSupplement({type: "logic.Gate21",attrs: {".input1": {ref: ".body","ref-x": -2,"ref-y": .3,magnet: "passive",port: "in1"},".input2": {ref: ".body","ref-x": -2,"ref-y": .7,magnet: "passive",port: "in2"},".output": {ref: ".body","ref-dx": 2,"ref-y": .5,magnet: true,port: "out"}}}, joint.shapes.logic.Gate.prototype.defaults)});
joint.shapes.logic.Repeater = joint.shapes.logic.Gate11.extend({defaults: joint.util.deepSupplement({type: "logic.Repeater",attrs: {image: {"xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PVCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjgiCiAgICAgaW5rc2NhcGU6Y3g9Ijg0LjY4NTM1MiIKICAgICBpbmtzY2FwZTpjeT0iMTUuMjg4NjI4IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzIuMTU2OTEsMjUgTCA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAyOS4wNDM0NzgsMjUgTCA1LjA0MzQ3ODEsMjUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgZD0iTSAyOC45Njg3NSwyLjU5Mzc1IEwgMjguOTY4NzUsNSBMIDI4Ljk2ODc1LDQ1IEwgMjguOTY4NzUsNDcuNDA2MjUgTCAzMS4xMjUsNDYuMzQzNzUgTCA3Mi4xNTYyNSwyNi4zNDM3NSBMIDcyLjE1NjI1LDIzLjY1NjI1IEwgMzEuMTI1LDMuNjU2MjUgTCAyOC45Njg3NSwyLjU5Mzc1IHogTSAzMS45Njg3NSw3LjQwNjI1IEwgNjguMDkzNzUsMjUgTCAzMS45Njg3NSw0Mi41OTM3NSBMIDMxLjk2ODc1LDcuNDA2MjUgeiIKICAgICAgIGlkPSJwYXRoMjYzOCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjY2NjY2NjYyIgLz4KICA8L2c+Cjwvc3ZnPgo="}}}, joint.shapes.logic.Gate11.prototype.defaults),operation: function(input) {
    return input
}});
joint.shapes.logic.Not = joint.shapes.logic.Gate11.extend({defaults: joint.util.deepSupplement({type: "logic.Not",attrs: {image: {"xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PVCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjgiCiAgICAgaW5rc2NhcGU6Y3g9Ijg0LjY4NTM1MiIKICAgICBpbmtzY2FwZTpjeT0iMTUuMjg4NjI4IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzkuMTU2OTEsMjUgTCA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAyOS4wNDM0NzgsMjUgTCA1LjA0MzQ3ODEsMjUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgZD0iTSAyOC45Njg3NSwyLjU5Mzc1IEwgMjguOTY4NzUsNSBMIDI4Ljk2ODc1LDQ1IEwgMjguOTY4NzUsNDcuNDA2MjUgTCAzMS4xMjUsNDYuMzQzNzUgTCA3Mi4xNTYyNSwyNi4zNDM3NSBMIDcyLjE1NjI1LDIzLjY1NjI1IEwgMzEuMTI1LDMuNjU2MjUgTCAyOC45Njg3NSwyLjU5Mzc1IHogTSAzMS45Njg3NSw3LjQwNjI1IEwgNjguMDkzNzUsMjUgTCAzMS45Njg3NSw0Mi41OTM3NSBMIDMxLjk2ODc1LDcuNDA2MjUgeiIKICAgICAgIGlkPSJwYXRoMjYzOCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjY2NjY2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDI2NzEiCiAgICAgICBzb2RpcG9kaTpjeD0iNzYiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA4MCwyNSBBIDQsNCAwIDEgMSA3MiwyNSBBIDQsNCAwIDEgMSA4MCwyNSB6IgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEsMCkiIC8+CiAgPC9nPgo8L3N2Zz4K"}}}, joint.shapes.logic.Gate11.prototype.defaults),operation: function(input) {
    return !input
}});
joint.shapes.logic.Or = joint.shapes.logic.Gate21.extend({defaults: joint.util.deepSupplement({type: "logic.Or",attrs: {image: {"xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik9SIEFOU0kuc3ZnIgogICBpbmtzY2FwZTpvdXRwdXRfZXh0ZW5zaW9uPSJvcmcuaW5rc2NhcGUub3V0cHV0LnN2Zy5pbmtzY2FwZSI+CiAgPGRlZnMKICAgICBpZD0iZGVmczQiPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjUwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjI1IDogMTAgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjcxNCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iMSA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMC41IDogMC4zMzMzMzMzMyA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyODA2IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyODE5IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjM3Mi4wNDcyNCA6IDM1MC43ODczOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI3NDQuMDk0NDggOiA1MjYuMTgxMDkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzc3IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49Ijc1IDogNDAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iMTUwIDogNjAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDYwIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTMyNzUiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNTAgOiAzMy4zMzMzMzMgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iMTAwIDogNTAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDUwIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTU1MzMiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzIgOiAyMS4zMzMzMzMgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNjQgOiAzMiA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMzIgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjU1NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDE2LjY2NjY2NyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDI1IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAyNSA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iNCIKICAgICBpbmtzY2FwZTpjeD0iMTEzLjAwMDM5IgogICAgIGlua3NjYXBlOmN5PSIxMi44OTM3MzEiCiAgICAgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9InB4IgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImcyNTYwIgogICAgIHNob3dncmlkPSJmYWxzZSIKICAgICBpbmtzY2FwZTpncmlkLWJib3g9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1wb2ludHM9InRydWUiCiAgICAgZ3JpZHRvbGVyYW5jZT0iMTAwMDAiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxMzk5IgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9Ijg3NCIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iMzciCiAgICAgaW5rc2NhcGU6d2luZG93LXk9Ii00IgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNzAsMjUgYyAyMCwwIDI1LDAgMjUsMCIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMSwxNSA1LDE1IgogICAgICAgaWQ9InBhdGgzMDYxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzIsMzUgNSwzNSIKICAgICAgIGlkPSJwYXRoMzk0NCIgLz4KICAgIDxnCiAgICAgICBpZD0iZzI1NjAiCiAgICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI2LjUsLTM5LjUpIj4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjQwNjI1LDQ0LjUgTCAtMC40MDYyNSw0Ni45Mzc1IEMgLTAuNDA2MjUsNDYuOTM3NSA1LjI1LDUzLjkzNzU0OSA1LjI1LDY0LjUgQyA1LjI1LDc1LjA2MjQ1MSAtMC40MDYyNSw4Mi4wNjI1IC0wLjQwNjI1LDgyLjA2MjUgTCAtMi40MDYyNSw4NC41IEwgMC43NSw4NC41IEwgMTQuNzUsODQuNSBDIDE3LjE1ODA3Niw4NC41MDAwMDEgMjIuNDM5Njk5LDg0LjUyNDUxNCAyOC4zNzUsODIuMDkzNzUgQyAzNC4zMTAzMDEsNzkuNjYyOTg2IDQwLjkxMTUzNiw3NC43NTA0ODQgNDYuMDYyNSw2NS4yMTg3NSBMIDQ0Ljc1LDY0LjUgTCA0Ni4wNjI1LDYzLjc4MTI1IEMgMzUuNzU5Mzg3LDQ0LjcxNTU5IDE5LjUwNjU3NCw0NC41IDE0Ljc1LDQ0LjUgTCAwLjc1LDQ0LjUgTCAtMi40MDYyNSw0NC41IHogTSAzLjQ2ODc1LDQ3LjUgTCAxNC43NSw0Ny41IEMgMTkuNDM0MTczLDQ3LjUgMzMuMDM2ODUsNDcuMzY5NzkzIDQyLjcxODc1LDY0LjUgQyAzNy45NTE5NjQsNzIuOTI5MDc1IDMyLjE5NzQ2OSw3Ny4xODM5MSAyNyw3OS4zMTI1IEMgMjEuNjM5MzM5LDgxLjUwNzkyNCAxNy4xNTgwNzUsODEuNTAwMDAxIDE0Ljc1LDgxLjUgTCAzLjUsODEuNSBDIDUuMzczNTg4NCw3OC4zOTE1NjYgOC4yNSw3Mi40NTA2NSA4LjI1LDY0LjUgQyA4LjI1LDU2LjUyNjY0NiA1LjM0MTQ2ODYsNTAuNTk5ODE1IDMuNDY4NzUsNDcuNSB6IgogICAgICAgICBpZD0icGF0aDQ5NzMiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NzY2NjY3NjY2NjY2NjY2NzY2NzYyIgLz4KICAgIDwvZz4KICA8L2c+Cjwvc3ZnPgo="}}}, joint.shapes.logic.Gate21.prototype.defaults),operation: function(input1, input2) {
    return input1 || input2
}});
joint.shapes.logic.And = joint.shapes.logic.Gate21.extend({defaults: joint.util.deepSupplement({type: "logic.And",attrs: {image: {"xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IkFORCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSI4IgogICAgIGlua3NjYXBlOmN4PSI1Ni42OTgzNDgiCiAgICAgaW5rc2NhcGU6Y3k9IjI1LjMyNjg5OSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDcwLDI1IGMgMjAsMCAyNSwwIDI1LDAiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEsMTUgNSwxNSIKICAgICAgIGlkPSJwYXRoMzA2MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjk5OTk5OTg4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMyLDM1IDUsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZvbnQtc2l6ZTptZWRpdW07Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zdHJldGNoOm5vcm1hbDt0ZXh0LWluZGVudDowO3RleHQtYWxpZ246c3RhcnQ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7bGluZS1oZWlnaHQ6bm9ybWFsO2xldHRlci1zcGFjaW5nOm5vcm1hbDt3b3JkLXNwYWNpbmc6bm9ybWFsO3RleHQtdHJhbnNmb3JtOm5vbmU7ZGlyZWN0aW9uOmx0cjtibG9jay1wcm9ncmVzc2lvbjp0Yjt3cml0aW5nLW1vZGU6bHItdGI7dGV4dC1hbmNob3I6c3RhcnQ7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDozO21hcmtlcjpub25lO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGU7Zm9udC1mYW1pbHk6Qml0c3RyZWFtIFZlcmEgU2FuczstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkJpdHN0cmVhbSBWZXJhIFNhbnMiCiAgICAgICBkPSJNIDMwLDUgTCAzMCw2LjQyODU3MTQgTCAzMCw0My41NzE0MjkgTCAzMCw0NSBMIDMxLjQyODU3MSw0NSBMIDUwLjQ3NjE5LDQ1IEMgNjEuNzQ0MDk4LDQ1IDcwLjQ3NjE5LDM1Ljk5OTk1NSA3MC40NzYxOSwyNSBDIDcwLjQ3NjE5LDE0LjAwMDA0NSA2MS43NDQwOTksNS4wMDAwMDAyIDUwLjQ3NjE5LDUgQyA1MC40NzYxOSw1IDUwLjQ3NjE5LDUgMzEuNDI4NTcxLDUgTCAzMCw1IHogTSAzMi44NTcxNDMsNy44NTcxNDI5IEMgNDAuODM0MjY0LDcuODU3MTQyOSA0NS45MTgzNjgsNy44NTcxNDI5IDQ4LjA5NTIzOCw3Ljg1NzE0MjkgQyA0OS4yODU3MTQsNy44NTcxNDI5IDQ5Ljg4MDk1Miw3Ljg1NzE0MjkgNTAuMTc4NTcxLDcuODU3MTQyOSBDIDUwLjMyNzM4MSw3Ljg1NzE0MjkgNTAuNDA5MjI3LDcuODU3MTQyOSA1MC40NDY0MjksNy44NTcxNDI5IEMgNTAuNDY1MDI5LDcuODU3MTQyOSA1MC40NzE1NDMsNy44NTcxNDI5IDUwLjQ3NjE5LDcuODU3MTQyOSBDIDYwLjIzNjg1Myw3Ljg1NzE0MyA2Ny4xNDI4NTcsMTUuNDk3MDk4IDY3LjE0Mjg1NywyNSBDIDY3LjE0Mjg1NywzNC41MDI5MDIgNTkuNzYwNjYyLDQyLjE0Mjg1NyA1MCw0Mi4xNDI4NTcgTCAzMi44NTcxNDMsNDIuMTQyODU3IEwgMzIuODU3MTQzLDcuODU3MTQyOSB6IgogICAgICAgaWQ9InBhdGgyODg0IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2NjY2NzY2NjY3Nzc3NzY2NjIiAvPgogIDwvZz4KPC9zdmc+Cg=="}}}, joint.shapes.logic.Gate21.prototype.defaults),operation: function(input1, input2) {
    return input1 && input2
}});
joint.shapes.logic.Nor = joint.shapes.logic.Gate21.extend({defaults: joint.util.deepSupplement({type: "logic.Nor",attrs: {image: {"xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PUiBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjEiCiAgICAgaW5rc2NhcGU6Y3g9Ijc4LjY3NzY0NCIKICAgICBpbmtzY2FwZTpjeT0iMjIuMTAyMzQ0IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjM3IgogICAgIGlua3NjYXBlOndpbmRvdy15PSItNCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDc5LDI1IEMgOTksMjUgOTUsMjUgOTUsMjUiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEsMTUgNSwxNSIKICAgICAgIGlkPSJwYXRoMzA2MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjk5OTk5OTg4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMyLDM1IDUsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8ZwogICAgICAgaWQ9ImcyNTYwIgogICAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi41LC0zOS41KSI+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi40MDYyNSw0NC41IEwgLTAuNDA2MjUsNDYuOTM3NSBDIC0wLjQwNjI1LDQ2LjkzNzUgNS4yNSw1My45Mzc1NDkgNS4yNSw2NC41IEMgNS4yNSw3NS4wNjI0NTEgLTAuNDA2MjUsODIuMDYyNSAtMC40MDYyNSw4Mi4wNjI1IEwgLTIuNDA2MjUsODQuNSBMIDAuNzUsODQuNSBMIDE0Ljc1LDg0LjUgQyAxNy4xNTgwNzYsODQuNTAwMDAxIDIyLjQzOTY5OSw4NC41MjQ1MTQgMjguMzc1LDgyLjA5Mzc1IEMgMzQuMzEwMzAxLDc5LjY2Mjk4NiA0MC45MTE1MzYsNzQuNzUwNDg0IDQ2LjA2MjUsNjUuMjE4NzUgTCA0NC43NSw2NC41IEwgNDYuMDYyNSw2My43ODEyNSBDIDM1Ljc1OTM4Nyw0NC43MTU1OSAxOS41MDY1NzQsNDQuNSAxNC43NSw0NC41IEwgMC43NSw0NC41IEwgLTIuNDA2MjUsNDQuNSB6IE0gMy40Njg3NSw0Ny41IEwgMTQuNzUsNDcuNSBDIDE5LjQzNDE3Myw0Ny41IDMzLjAzNjg1LDQ3LjM2OTc5MyA0Mi43MTg3NSw2NC41IEMgMzcuOTUxOTY0LDcyLjkyOTA3NSAzMi4xOTc0NjksNzcuMTgzOTEgMjcsNzkuMzEyNSBDIDIxLjYzOTMzOSw4MS41MDc5MjQgMTcuMTU4MDc1LDgxLjUwMDAwMSAxNC43NSw4MS41IEwgMy41LDgxLjUgQyA1LjM3MzU4ODQsNzguMzkxNTY2IDguMjUsNzIuNDUwNjUgOC4yNSw2NC41IEMgOC4yNSw1Ni41MjY2NDYgNS4zNDE0Njg2LDUwLjU5OTgxNSAzLjQ2ODc1LDQ3LjUgeiIKICAgICAgICAgaWQ9InBhdGg0OTczIgogICAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjc2NjY2NzY2NjY2NjY2Njc2Njc2MiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIHNvZGlwb2RpOnR5cGU9ImFyYyIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgICBpZD0icGF0aDI2MDQiCiAgICAgICAgIHNvZGlwb2RpOmN4PSI3NSIKICAgICAgICAgc29kaXBvZGk6Y3k9IjI1IgogICAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgICAgc29kaXBvZGk6cnk9IjQiCiAgICAgICAgIGQ9Ik0gNzksMjUgQSA0LDQgMCAxIDEgNzEsMjUgQSA0LDQgMCAxIDEgNzksMjUgeiIKICAgICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTI2LjUsMzkuNSkiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K"}}}, joint.shapes.logic.Gate21.prototype.defaults),operation: function(input1, input2) {
    return !(input1 || input2)
}});
joint.shapes.logic.Nand = joint.shapes.logic.Gate21.extend({defaults: joint.util.deepSupplement({type: "logic.Nand",attrs: {image: {"xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5BTkQgQU5TSS5zdmciCiAgIGlua3NjYXBlOm91dHB1dF9leHRlbnNpb249Im9yZy5pbmtzY2FwZS5vdXRwdXQuc3ZnLmlua3NjYXBlIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCI+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxMCA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzE0IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIwLjUgOiAwLjMzMzMzMzMzIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MDYiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MTkiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzcyLjA0NzI0IDogMzUwLjc4NzM5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9Ijc0NC4wOTQ0OCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTI2LjE4MTA5IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3NzciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNzUgOiA0MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxNTAgOiA2MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNjAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMzI3NSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI1MCA6IDMzLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxMDAgOiA1MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlNTUzMyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzMiA6IDIxLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI2NCA6IDMyIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAzMiA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iMTYiCiAgICAgaW5rc2NhcGU6Y3g9Ijc4LjI4MzMwNyIKICAgICBpbmtzY2FwZTpjeT0iMTYuNDQyODQzIgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzksMjUgQyA5MS44LDI1IDk1LDI1IDk1LDI1IgogICAgICAgaWQ9InBhdGgzMDU5IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMxLDE1IDUsMTUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk4ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMiwzNSA1LDM1IgogICAgICAgaWQ9InBhdGgzOTQ0IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmb250LXNpemU6bWVkaXVtO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1pbmRlbnQ6MDt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbjpub25lO2xpbmUtaGVpZ2h0Om5vcm1hbDtsZXR0ZXItc3BhY2luZzpub3JtYWw7d29yZC1zcGFjaW5nOm5vcm1hbDt0ZXh0LXRyYW5zZm9ybTpub25lO2RpcmVjdGlvbjpsdHI7YmxvY2stcHJvZ3Jlc3Npb246dGI7d3JpdGluZy1tb2RlOmxyLXRiO3RleHQtYW5jaG9yOnN0YXJ0O2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MzttYXJrZXI6bm9uZTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlO2ZvbnQtZmFtaWx5OkJpdHN0cmVhbSBWZXJhIFNhbnM7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpCaXRzdHJlYW0gVmVyYSBTYW5zIgogICAgICAgZD0iTSAzMCw1IEwgMzAsNi40Mjg1NzE0IEwgMzAsNDMuNTcxNDI5IEwgMzAsNDUgTCAzMS40Mjg1NzEsNDUgTCA1MC40NzYxOSw0NSBDIDYxLjc0NDA5OCw0NSA3MC40NzYxOSwzNS45OTk5NTUgNzAuNDc2MTksMjUgQyA3MC40NzYxOSwxNC4wMDAwNDUgNjEuNzQ0MDk5LDUuMDAwMDAwMiA1MC40NzYxOSw1IEMgNTAuNDc2MTksNSA1MC40NzYxOSw1IDMxLjQyODU3MSw1IEwgMzAsNSB6IE0gMzIuODU3MTQzLDcuODU3MTQyOSBDIDQwLjgzNDI2NCw3Ljg1NzE0MjkgNDUuOTE4MzY4LDcuODU3MTQyOSA0OC4wOTUyMzgsNy44NTcxNDI5IEMgNDkuMjg1NzE0LDcuODU3MTQyOSA0OS44ODA5NTIsNy44NTcxNDI5IDUwLjE3ODU3MSw3Ljg1NzE0MjkgQyA1MC4zMjczODEsNy44NTcxNDI5IDUwLjQwOTIyNyw3Ljg1NzE0MjkgNTAuNDQ2NDI5LDcuODU3MTQyOSBDIDUwLjQ2NTAyOSw3Ljg1NzE0MjkgNTAuNDcxNTQzLDcuODU3MTQyOSA1MC40NzYxOSw3Ljg1NzE0MjkgQyA2MC4yMzY4NTMsNy44NTcxNDMgNjcuMTQyODU3LDE1LjQ5NzA5OCA2Ny4xNDI4NTcsMjUgQyA2Ny4xNDI4NTcsMzQuNTAyOTAyIDU5Ljc2MDY2Miw0Mi4xNDI4NTcgNTAsNDIuMTQyODU3IEwgMzIuODU3MTQzLDQyLjE0Mjg1NyBMIDMyLjg1NzE0Myw3Ljg1NzE0MjkgeiIKICAgICAgIGlkPSJwYXRoMjg4NCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2Njc2NjY2Nzc3Nzc2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDQwMDgiCiAgICAgICBzb2RpcG9kaTpjeD0iNzUiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA3OSwyNSBBIDQsNCAwIDEgMSA3MSwyNSBBIDQsNCAwIDEgMSA3OSwyNSB6IiAvPgogIDwvZz4KPC9zdmc+Cg=="}}}, joint.shapes.logic.Gate21.prototype.defaults),operation: function(input1, input2) {
    return !(input1 && input2)
}});
joint.shapes.logic.Xor = joint.shapes.logic.Gate21.extend({defaults: joint.util.deepSupplement({type: "logic.Xor",attrs: {image: {"xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IlhPUiBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjUuNjU2ODU0MiIKICAgICBpbmtzY2FwZTpjeD0iMjUuOTM4MTE2IgogICAgIGlua3NjYXBlOmN5PSIxNy4yMzAwNSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDcwLDI1IGMgMjAsMCAyNSwwIDI1LDAiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzAuMzg1NzE3LDE1IEwgNC45OTk5OTk4LDE1IgogICAgICAgaWQ9InBhdGgzMDYxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5NzY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEuMzYyMDkxLDM1IEwgNC45OTk5OTk4LDM1IgogICAgICAgaWQ9InBhdGgzOTQ0IiAvPgogICAgPGcKICAgICAgIGlkPSJnMjU2MCIKICAgICAgIGlua3NjYXBlOmxhYmVsPSJMYXllciAxIgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjYuNSwtMzkuNSkiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDM1MTYiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi4yNSw4MS41MDAwMDUgQyAtMy44NDczNzQsODQuMTQ0NDA1IC00LjUsODQuNTAwMDA1IC00LjUsODQuNTAwMDA1IEwgLTguMTU2MjUsODQuNTAwMDA1IEwgLTYuMTU2MjUsODIuMDYyNTA1IEMgLTYuMTU2MjUsODIuMDYyNTA1IC0wLjUsNzUuMDYyNDUxIC0wLjUsNjQuNSBDIC0wLjUsNTMuOTM3NTQ5IC02LjE1NjI1LDQ2LjkzNzUgLTYuMTU2MjUsNDYuOTM3NSBMIC04LjE1NjI1LDQ0LjUgTCAtNC41LDQ0LjUgQyAtMy43MTg3NSw0NS40Mzc1IC0zLjA3ODEyNSw0Ni4xNTYyNSAtMi4yODEyNSw0Ny41IEMgLTAuNDA4NTMxLDUwLjU5OTgxNSAyLjUsNTYuNTI2NjQ2IDIuNSw2NC41IEMgMi41LDcyLjQ1MDY1IC0wLjM5NjY5Nyw3OC4zNzk0MjUgLTIuMjUsODEuNTAwMDA1IHoiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY3NjY2Njc2MiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi40MDYyNSw0NC41IEwgLTAuNDA2MjUsNDYuOTM3NSBDIC0wLjQwNjI1LDQ2LjkzNzUgNS4yNSw1My45Mzc1NDkgNS4yNSw2NC41IEMgNS4yNSw3NS4wNjI0NTEgLTAuNDA2MjUsODIuMDYyNSAtMC40MDYyNSw4Mi4wNjI1IEwgLTIuNDA2MjUsODQuNSBMIDAuNzUsODQuNSBMIDE0Ljc1LDg0LjUgQyAxNy4xNTgwNzYsODQuNTAwMDAxIDIyLjQzOTY5OSw4NC41MjQ1MTQgMjguMzc1LDgyLjA5Mzc1IEMgMzQuMzEwMzAxLDc5LjY2Mjk4NiA0MC45MTE1MzYsNzQuNzUwNDg0IDQ2LjA2MjUsNjUuMjE4NzUgTCA0NC43NSw2NC41IEwgNDYuMDYyNSw2My43ODEyNSBDIDM1Ljc1OTM4Nyw0NC43MTU1OSAxOS41MDY1NzQsNDQuNSAxNC43NSw0NC41IEwgMC43NSw0NC41IEwgLTIuNDA2MjUsNDQuNSB6IE0gMy40Njg3NSw0Ny41IEwgMTQuNzUsNDcuNSBDIDE5LjQzNDE3Myw0Ny41IDMzLjAzNjg1LDQ3LjM2OTc5MyA0Mi43MTg3NSw2NC41IEMgMzcuOTUxOTY0LDcyLjkyOTA3NSAzMi4xOTc0NjksNzcuMTgzOTEgMjcsNzkuMzEyNSBDIDIxLjYzOTMzOSw4MS41MDc5MjQgMTcuMTU4MDc1LDgxLjUwMDAwMSAxNC43NSw4MS41IEwgMy41LDgxLjUgQyA1LjM3MzU4ODQsNzguMzkxNTY2IDguMjUsNzIuNDUwNjUgOC4yNSw2NC41IEMgOC4yNSw1Ni41MjY2NDYgNS4zNDE0Njg2LDUwLjU5OTgxNSAzLjQ2ODc1LDQ3LjUgeiIKICAgICAgICAgaWQ9InBhdGg0OTczIgogICAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjc2NjY2NzY2NjY2NjY2Njc2Njc2MiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K"}}}, joint.shapes.logic.Gate21.prototype.defaults),operation: function(input1, input2) {
    return (!input1 || input2) && (input1 || !input2)
}});
joint.shapes.logic.Xnor = joint.shapes.logic.Gate21.extend({defaults: joint.util.deepSupplement({type: "logic.Xnor",attrs: {image: {"xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IlhOT1IgQU5TSS5zdmciCiAgIGlua3NjYXBlOm91dHB1dF9leHRlbnNpb249Im9yZy5pbmtzY2FwZS5vdXRwdXQuc3ZnLmlua3NjYXBlIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCI+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxMCA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzE0IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIwLjUgOiAwLjMzMzMzMzMzIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MDYiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MTkiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzcyLjA0NzI0IDogMzUwLjc4NzM5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9Ijc0NC4wOTQ0OCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTI2LjE4MTA5IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3NzciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNzUgOiA0MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxNTAgOiA2MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNjAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMzI3NSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI1MCA6IDMzLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxMDAgOiA1MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlNTUzMyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzMiA6IDIxLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI2NCA6IDMyIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAzMiA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNTU3IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjI1IDogMTYuNjY2NjY3IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjUwIDogMjUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDI1IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSI0IgogICAgIGlua3NjYXBlOmN4PSI5NS43MjM2NiIKICAgICBpbmtzY2FwZTpjeT0iLTI2Ljc3NTAyMyIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjAwMDAwMDI0O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDc4LjMzMzMzMiwyNSBDIDkxLjY2NjY2NiwyNSA5NSwyNSA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk4ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMC4zODU3MTcsMTUgTCA0Ljk5OTk5OTgsMTUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk3NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMS4zNjIwOTEsMzUgTCA0Ljk5OTk5OTgsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8ZwogICAgICAgaWQ9ImcyNTYwIgogICAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi41LC0zOS41KSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlkPSJwYXRoMzUxNiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjI1LDgxLjUwMDAwNSBDIC0zLjg0NzM3NCw4NC4xNDQ0MDUgLTQuNSw4NC41MDAwMDUgLTQuNSw4NC41MDAwMDUgTCAtOC4xNTYyNSw4NC41MDAwMDUgTCAtNi4xNTYyNSw4Mi4wNjI1MDUgQyAtNi4xNTYyNSw4Mi4wNjI1MDUgLTAuNSw3NS4wNjI0NTEgLTAuNSw2NC41IEMgLTAuNSw1My45Mzc1NDkgLTYuMTU2MjUsNDYuOTM3NSAtNi4xNTYyNSw0Ni45Mzc1IEwgLTguMTU2MjUsNDQuNSBMIC00LjUsNDQuNSBDIC0zLjcxODc1LDQ1LjQzNzUgLTMuMDc4MTI1LDQ2LjE1NjI1IC0yLjI4MTI1LDQ3LjUgQyAtMC40MDg1MzEsNTAuNTk5ODE1IDIuNSw1Ni41MjY2NDYgMi41LDY0LjUgQyAyLjUsNzIuNDUwNjUgLTAuMzk2Njk3LDc4LjM3OTQyNSAtMi4yNSw4MS41MDAwMDUgeiIKICAgICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2Njc2NjY2NzYyIgLz4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjQwNjI1LDQ0LjUgTCAtMC40MDYyNSw0Ni45Mzc1IEMgLTAuNDA2MjUsNDYuOTM3NSA1LjI1LDUzLjkzNzU0OSA1LjI1LDY0LjUgQyA1LjI1LDc1LjA2MjQ1MSAtMC40MDYyNSw4Mi4wNjI1IC0wLjQwNjI1LDgyLjA2MjUgTCAtMi40MDYyNSw4NC41IEwgMC43NSw4NC41IEwgMTQuNzUsODQuNSBDIDE3LjE1ODA3Niw4NC41MDAwMDEgMjIuNDM5Njk5LDg0LjUyNDUxNCAyOC4zNzUsODIuMDkzNzUgQyAzNC4zMTAzMDEsNzkuNjYyOTg2IDQwLjkxMTUzNiw3NC43NTA0ODQgNDYuMDYyNSw2NS4yMTg3NSBMIDQ0Ljc1LDY0LjUgTCA0Ni4wNjI1LDYzLjc4MTI1IEMgMzUuNzU5Mzg3LDQ0LjcxNTU5IDE5LjUwNjU3NCw0NC41IDE0Ljc1LDQ0LjUgTCAwLjc1LDQ0LjUgTCAtMi40MDYyNSw0NC41IHogTSAzLjQ2ODc1LDQ3LjUgTCAxNC43NSw0Ny41IEMgMTkuNDM0MTczLDQ3LjUgMzMuMDM2ODUsNDcuMzY5NzkzIDQyLjcxODc1LDY0LjUgQyAzNy45NTE5NjQsNzIuOTI5MDc1IDMyLjE5NzQ2OSw3Ny4xODM5MSAyNyw3OS4zMTI1IEMgMjEuNjM5MzM5LDgxLjUwNzkyNCAxNy4xNTgwNzUsODEuNTAwMDAxIDE0Ljc1LDgxLjUgTCAzLjUsODEuNSBDIDUuMzczNTg4NCw3OC4zOTE1NjYgOC4yNSw3Mi40NTA2NSA4LjI1LDY0LjUgQyA4LjI1LDU2LjUyNjY0NiA1LjM0MTQ2ODYsNTAuNTk5ODE1IDMuNDY4NzUsNDcuNSB6IgogICAgICAgICBpZD0icGF0aDQ5NzMiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NzY2NjY3NjY2NjY2NjY2NzY2NzYyIgLz4KICAgIDwvZz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDM1NTEiCiAgICAgICBzb2RpcG9kaTpjeD0iNzUiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA3OSwyNSBBIDQsNCAwIDEgMSA3MSwyNSBBIDQsNCAwIDEgMSA3OSwyNSB6IiAvPgogIDwvZz4KPC9zdmc+Cg=="}}}, joint.shapes.logic.Gate21.prototype.defaults),operation: function(input1, input2) {
    return (!input1 || !input2) && (input1 || input2)
}});
joint.shapes.logic.Wire = joint.dia.Link.extend({arrowheadMarkup: ['<g class="marker-arrowhead-group marker-arrowhead-group-<%= end %>">', '<circle class="marker-arrowhead" end="<%= end %>" r="7"/>', "</g>"].join(""),vertexMarkup: ['<g class="marker-vertex-group" transform="translate(<%= x %>, <%= y %>)">', '<circle class="marker-vertex" idx="<%= idx %>" r="10" />', '<g class="marker-vertex-remove-group">', '<path class="marker-vertex-remove-area" idx="<%= idx %>" d="M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z" transform="translate(5, -33)"/>', '<path class="marker-vertex-remove" idx="<%= idx %>" transform="scale(.8) translate(9.5, -37)" d="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z">', "<title>Remove vertex.</title>", "</path>", "</g>", "</g>"].join(""),defaults: joint.util.deepSupplement({type: "logic.Wire",attrs: {".connection": {"stroke-width": 2},".marker-vertex": {r: 7}},router: {name: "orthogonal"},connector: {name: "rounded",args: {radius: 10}}}, joint.dia.Link.prototype.defaults)});
if (typeof exports === "object") {
    module.exports = joint.shapes.logic
}
if (typeof exports === "object") {
    var joint = {util: require("../src/core").util,shapes: {},dia: {Element: require("../src/joint.dia.element").Element,Link: require("../src/joint.dia.link").Link}}
}
joint.shapes.bpmn = {};
joint.shapes.bpmn.icons = {none: "",message: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjwhRE9DVFlQRSBzdmcgIFBVQkxJQyAnLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4nICAnaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkJz48c3ZnIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIGhlaWdodD0iNTEycHgiIGlkPSJMYXllcl8xIiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiB3aWR0aD0iNTEycHgiIHhtbDpzcGFjZT0icHJlc2VydmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxwYXRoIGQ9Ik00NzkuOTk4LDY0SDMyQzE0LjMyOSw2NCwwLDc4LjMxMiwwLDk2djMyMGMwLDE3LjY4OCwxNC4zMjksMzIsMzIsMzJoNDQ3Ljk5OEM0OTcuNjcxLDQ0OCw1MTIsNDMzLjY4OCw1MTIsNDE2Vjk2ICBDNTEyLDc4LjMxMiw0OTcuNjcxLDY0LDQ3OS45OTgsNjR6IE00MTYsMTI4TDI1NiwyNTZMOTYsMTI4SDQxNnogTTQ0OCwzODRINjRWMTYwbDE5MiwxNjBsMTkyLTE2MFYzODR6Ii8+PC9zdmc+",plus: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjwhRE9DVFlQRSBzdmcgIFBVQkxJQyAnLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4nICAnaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkJz48c3ZnIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDI0IDI0IiBoZWlnaHQ9IjI0cHgiIGlkPSJMYXllcl8xIiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0cHgiIHhtbDpzcGFjZT0icHJlc2VydmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxwYXRoIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTIyLjUsMTRIMTR2OC41YzAsMC4yNzYtMC4yMjQsMC41LTAuNSwwLjVoLTRDOS4yMjQsMjMsOSwyMi43NzYsOSwyMi41VjE0SDAuNSAgQzAuMjI0LDE0LDAsMTMuNzc2LDAsMTMuNXYtNEMwLDkuMjI0LDAuMjI0LDksMC41LDlIOVYwLjVDOSwwLjIyNCw5LjIyNCwwLDkuNSwwaDRDMTMuNzc2LDAsMTQsMC4yMjQsMTQsMC41VjloOC41ICBDMjIuNzc2LDksMjMsOS4yMjQsMjMsOS41djRDMjMsMTMuNzc2LDIyLjc3NiwxNCwyMi41LDE0eiIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9zdmc+",cross: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjwhRE9DVFlQRSBzdmcgIFBVQkxJQyAnLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4nICAnaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkJz48c3ZnIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDI0IDI0IiBoZWlnaHQ9IjI0cHgiIGlkPSJMYXllcl8xIiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0cHgiIHhtbDpzcGFjZT0icHJlc2VydmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxwYXRoIGQ9Ik0yMi4yNDUsNC4wMTVjMC4zMTMsMC4zMTMsMC4zMTMsMC44MjYsMCwxLjEzOWwtNi4yNzYsNi4yN2MtMC4zMTMsMC4zMTItMC4zMTMsMC44MjYsMCwxLjE0bDYuMjczLDYuMjcyICBjMC4zMTMsMC4zMTMsMC4zMTMsMC44MjYsMCwxLjE0bC0yLjI4NSwyLjI3N2MtMC4zMTQsMC4zMTItMC44MjgsMC4zMTItMS4xNDIsMGwtNi4yNzEtNi4yNzFjLTAuMzEzLTAuMzEzLTAuODI4LTAuMzEzLTEuMTQxLDAgIGwtNi4yNzYsNi4yNjdjLTAuMzEzLDAuMzEzLTAuODI4LDAuMzEzLTEuMTQxLDBsLTIuMjgyLTIuMjhjLTAuMzEzLTAuMzEzLTAuMzEzLTAuODI2LDAtMS4xNGw2LjI3OC02LjI2OSAgYzAuMzEzLTAuMzEyLDAuMzEzLTAuODI2LDAtMS4xNEwxLjcwOSw1LjE0N2MtMC4zMTQtMC4zMTMtMC4zMTQtMC44MjcsMC0xLjE0bDIuMjg0LTIuMjc4QzQuMzA4LDEuNDE3LDQuODIxLDEuNDE3LDUuMTM1LDEuNzMgIEwxMS40MDUsOGMwLjMxNCwwLjMxNCwwLjgyOCwwLjMxNCwxLjE0MSwwLjAwMWw2LjI3Ni02LjI2N2MwLjMxMi0wLjMxMiwwLjgyNi0wLjMxMiwxLjE0MSwwTDIyLjI0NSw0LjAxNXoiLz48L3N2Zz4=",user: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjwhRE9DVFlQRSBzdmcgIFBVQkxJQyAnLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4nICAnaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkJz48c3ZnIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDI0IDI0IiBoZWlnaHQ9IjI0cHgiIGlkPSJMYXllcl8xIiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0cHgiIHhtbDpzcGFjZT0icHJlc2VydmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxwYXRoIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTIyLDIwLjk5OGgtMWMwLDAtMSwwLTEtMVYxNy41YzAtMC4yNzctMC4yMjQtMC41LTAuNS0wLjVTMTksMTcuMjIzLDE5LDE3LjUgIGwtMC4wMDgsNC4yOTVjMCwwLjYwOS0yLjAxLDIuMjA1LTYuNDkyLDIuMjA1cy02LjQ5Mi0xLjU5Ni02LjQ5Mi0yLjIwNUw2LDE3LjVDNiwxNy4yMjMsNS43NzYsMTcsNS41LDE3UzUsMTcuMjIzLDUsMTcuNXYyLjQ5OCAgYzAsMS0xLDEtMSwxSDNjMCwwLTEsMC0xLTFWMTUuNzVjMC0yLjkyMiwyLjg5Mi01LjQwMSw2LjkzLTYuMzQxYzAsMCwxLjIzNCwxLjEwNywzLjU3LDEuMTA3czMuNTctMS4xMDcsMy41Ny0xLjEwNyAgYzQuMDM4LDAuOTQsNi45MywzLjQxOSw2LjkzLDYuMzQxdjQuMjQ4QzIzLDIwLjk5OCwyMiwyMC45OTgsMjIsMjAuOTk4eiBNMTIuNDc3LDljLTIuNDg1LDAtNC41LTIuMDE1LTQuNS00LjVTOS45OTEsMCwxMi40NzcsMCAgczQuNSwyLjAxNSw0LjUsNC41UzE0Ljk2Miw5LDEyLjQ3Nyw5eiIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9zdmc+",circle: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3gULEBE3DEP64QAAAwlJREFUaN7dmktrU0EUx38ZmmBbfEIL2hSjkYKC1EW6EDFudC+404/gE6WKSvGxERQfIH4AX1T9EOKrCrYurVrbgsZWoaBVixDbpC6ci+Fyz9ybZG478cBs7syc+Z+5c86c+c8ksCPrgW1ADtgEbARafG1+AW+AYWAIGADGWUTZAJwHxoD5GssocA7ILiTwLcADoFQHcH8pAfeB7jiBtwO3gLJF4P5S1mO02wa/C5iMEbi/TAI7bYE/Y3m5VLOs+sLAJULqrgKHIxhZBp4DT4FX2jkLGoinq1M7fg7YDmwFVATd14CjFboiy5UIs/QBOAmka/izaeCU1hE2zuVqlZ8IUfgVOAA0WViiTcBBrdM0Zm9UhTuAOYOiRzXOeJh0Ak8M484B+TAlK4BPBiU3gWSMoTqpw6g0fgFYblJww9D5dojT25IEcMeA47rUsdsQLp9FmPmURSNSOqpJS2lzUKd+ocN3IBNx5mz+oXXADwHTXX/jjMFxjy1iwtgrYJoF1lY27BMafozZaaMspYKA7XRlw7f1xt4Y5biA7bXXIGv4TW0OGNCmsQRhzCidlwTJADDlgAFTwAuhLq+AHqHyMe6IhKVHAV1C5ZBDBkhYupThPPreIQNGJTJBGXKLLw4Z8NmQu/Fb8PCkQwakBIxFRWPLvAJmhMpWh4AuFb7PKGBaqFzjkAGrhe/TSjNrQZJ1yAAJy5gCRoTKnEMGSFhGFDBoOBu7IhKWQe8wLRFLHQ6A7zCcFNNK59vvAjoqYK8DBuwTCLBhTUD8Hweahj9S2jjU297VqzrU26BVmi2yEjXRKg1PbHnpqYla7AeWxAi+GbhHHdSit2mYyN2XQQ5kQTJ6Y6qL3PUkCr2+H7v0+jcs0eueRLngGNeKa9mxY73g8JzpEtHusorAQ/7e+e7WUWIl//jSVTrK7QEu6KgW9d7tYr3B44iBWPJfkZZ8pZ4r2VngkC0HywMTLNwN5YSBcKtZWoGzernEBbyox2iJc6Np2KcGfnHisYet1CDouc2yCjbhp07MrD+3+QNxi4JkAscRswAAAABJRU5ErkJggg=="};
joint.shapes.bpmn.IconInterface = {initialize: function() {
    this._parent = (this._parent || this).constructor.__super__;
    this._parent.initialize.apply(this, arguments);
    this.listenTo(this, "change:icon", this._onIconChange);
    this._onIconChange(this, this.get("icon") || "none")
},_onIconChange: function(cell, icon) {
    var icons = joint.shapes.bpmn.icons;
    if (_.has(icons, icon)) {
        cell.attr("image/xlink:href", icons[icon])
    } else {
        throw "BPMN: Unknown icon: " + icon
    }
}};
joint.shapes.bpmn.SubProcessInterface = {initialize: function() {
    this._parent = (this._parent || this).constructor.__super__;
    this._parent.initialize.apply(this, arguments);
    this.listenTo(this, "change:subProcess", this._onSubProcessChange);
    this._onSubProcessChange(this, this.get("subProcess") || null)
},_onSubProcessChange: function(cell, subProcess) {
    cell.attr({".sub-process": {visibility: subProcess ? "visible" : "hidden","data-sub-process": subProcess || ""}})
}};
joint.shapes.bpmn.ActivityView = joint.shapes.basic.TextBlockView;
joint.shapes.bpmn.Activity = joint.shapes.basic.TextBlock.extend({markup: ['<g class="rotatable">', '<g class="scalable"><rect class="body outer"/><rect class="body inner"/></g>', "<switch>", '<foreignObject requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" class="fobj">', '<body xmlns="http://www.w3.org/1999/xhtml"><div/></body>', "</foreignObject>", '<text class="content"/>', '</switch><path class="sub-process"/><image class="icon"/></g>'].join(""),defaults: joint.util.deepSupplement({size: {width: 100,height: 100},type: "bpmn.Activity",attrs: {rect: {rx: 8,ry: 8,width: 100,height: 100},".body": {fill: "#ffffff",stroke: "#000000"},".inner": {transform: "scale(0.9,0.9) translate(5,5)"},path: {d: "M 0 0 L 30 0 30 30 0 30 z M 15 4 L 15 26 M 4 15 L 26 15",ref: ".inner","ref-x": .5,"ref-dy": -30,"x-alignment": "middle",stroke: "#000000",fill: "transparent"},image: {ref: ".inner","ref-x": 5,width: 20,height: 20}},activityType: "task",subProcess: null}, joint.shapes.basic.TextBlock.prototype.defaults),initialize: function() {
    joint.shapes.basic.TextBlock.prototype.initialize.apply(this, arguments);
    this.listenTo(this, "change:activityType", this.onActivityTypeChange);
    this.listenTo(this, "change:subProcess", this.onSubProcessChange);
    this.onSubProcessChange(this, this.get("subProcess"));
    this.onActivityTypeChange(this, this.get("activityType"))
},onActivityTypeChange: function(cell, type) {
    switch (type) {
        case "task":
            cell.attr({".inner": {visibility: "hidden"},".outer": {"stroke-width": 1,"stroke-dasharray": "none"},path: {ref: ".outer"},image: {ref: ".outer"}});
            break;
        case "transaction":
            cell.attr({".inner": {visibility: "visible"},".outer": {"stroke-width": 1,"stroke-dasharray": "none"},path: {ref: ".inner"},image: {ref: ".inner"}});
            break;
        case "event-sub-process":
            cell.attr({".inner": {visibility: "hidden"},".outer": {"stroke-width": 1,"stroke-dasharray": "1,2"},path: {ref: ".outer"},image: {ref: ".outer"}});
            break;
        case "call-activity":
            cell.attr({".inner": {visibility: "hidden"},".outer": {"stroke-width": 5,"stroke-dasharray": "none"},path: {ref: ".outer"},image: {ref: ".outer"}});
            break;
        default:
            throw "BPMN: Unknown Activity Type: " + type;
            break
    }
},onSubProcessChange: function(cell, subProcess) {
    if (subProcess) {
        cell.attr({".fobj div": {style: {verticalAlign: "baseline",paddingTop: 10}},image: {"ref-dy": -25,"ref-y": ""},text: {"ref-y": 25}})
    } else {
        cell.attr({".fobj div": {style: {verticalAlign: "middle",paddingTop: 0}},image: {"ref-dy": "","ref-y": 5},text: {"ref-y": .5}})
    }
}}).extend(joint.shapes.bpmn.IconInterface).extend(joint.shapes.bpmn.SubProcessInterface);
joint.shapes.bpmn.AnnotationView = joint.shapes.basic.TextBlockView;
joint.shapes.bpmn.Annotation = joint.shapes.basic.TextBlock.extend({markup: ['<g class="rotatable">', '<g class="scalable"><rect class="body"/></g>', "<switch>", '<foreignObject requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" class="fobj">', '<body xmlns="http://www.w3.org/1999/xhtml"><div/></body>', "</foreignObject>", '<text class="content"/>', '</switch><path class="stroke"/></g>'].join(""),defaults: joint.util.deepSupplement({size: {width: 100,height: 100},type: "bpmn.Annotation",attrs: {rect: {width: 100,height: 100},".body": {"fill-opacity": .1,fill: "#ffffff",stroke: "none"},".fobj div": {style: {textAlign: "left",paddingLeft: 10}},".stroke": {stroke: "#000000",fill: "none","stroke-width": 3}},wingLength: 20}, joint.shapes.basic.TextBlock.prototype.defaults),initialize: function() {
    joint.shapes.basic.TextBlock.prototype.initialize.apply(this, arguments);
    this.listenTo(this, "change:size", this.onSizeChange);
    this.onSizeChange(this, this.get("size"))
},onSizeChange: function(cell, size) {
    cell.attr(".stroke", {d: cell.getStrokePathData(size.width, size.height, cell.get("wingLength"))})
},getStrokePathData: function(width, height, wingLength) {
    wingLength = Math.min(wingLength, width);
    return ["M", wingLength, "0 L 0 0 0", height, wingLength, height].join(" ")
}});
joint.shapes.bpmn.Gateway = joint.dia.Element.extend({markup: '<g class="rotatable"><g class="scalable"><polygon class="body"/><image/></g></g><text class="label"/>',defaults: joint.util.deepSupplement({type: "bpmn.Gateway",size: {width: 80,height: 80},attrs: {".body": {points: "40,0 80,40 40,80 0,40",fill: "#ffffff",stroke: "#000000"},".label": {text: "",ref: ".body","ref-x": .5,"ref-dy": 20,"y-alignment": "middle","x-alignment": "middle","font-size": 14,"font-family": "Arial, helvetica, sans-serif",fill: "#000000"},image: {width: 40,height: 40,"xlink:href": "",transform: "translate(20,20)"}}}, joint.dia.Element.prototype.defaults)}).extend(joint.shapes.bpmn.IconInterface);
joint.shapes.bpmn.Event = joint.dia.Element.extend({markup: '<g class="rotatable"><g class="scalable"><circle class="body outer"/><circle class="body inner"/><image/></g><text class="label"/></g>',defaults: joint.util.deepSupplement({type: "bpmn.Event",size: {width: 60,height: 60},attrs: {".body": {fill: "#ffffff",stroke: "#000000"},".outer": {"stroke-width": 1,r: 30,transform: "translate(30,30)"},".inner": {"stroke-width": 1,r: 26,transform: "translate(30,30)"},image: {width: 40,height: 40,"xlink:href": "",transform: "translate(10,10)"},".label": {text: "",fill: "#000000","font-family": "Arial","font-size": 14,ref: ".outer","ref-x": .5,"ref-dy": 20,"x-alignment": "middle","y-alignment": "middle"}},eventType: "start"}, joint.dia.Element.prototype.defaults),initialize: function() {
    joint.dia.Element.prototype.initialize.apply(this, arguments);
    this.listenTo(this, "change:eventType", this.onEventTypeChange);
    this.onEventTypeChange(this, this.get("eventType"))
},onEventTypeChange: function(cell, type) {
    switch (type) {
        case "start":
            cell.attr({".inner": {visibility: "hidden"},".outer": {"stroke-width": 1}});
            break;
        case "end":
            cell.attr({".inner": {visibility: "hidden"},".outer": {"stroke-width": 5}});
            break;
        case "intermediate":
            cell.attr({".inner": {visibility: "visible"},".outer": {"stroke-width": 1}});
            break;
        default:
            throw "BPMN: Unknown Event Type: " + type;
            break
    }
}}).extend(joint.shapes.bpmn.IconInterface);
joint.shapes.bpmn.Pool = joint.dia.Element.extend({markup: ['<g class="rotatable">', '<g class="scalable"><rect class="body"/></g>', '<svg overflow="hidden" class="blackbox-wrap"><text class="blackbox-label"/></svg>', '<rect class="header"/><text class="label"/>', '<g class="lanes"/>', "</g>"].join(""),laneMarkup: '<g class="lane"><rect class="lane-body"/><rect class="lane-header"/><text class="lane-label"/></g>',defaults: joint.util.deepSupplement({type: "bpmn.Pool",size: {width: 600,height: 300},attrs: {".body": {fill: "#ffffff",stroke: "#000000",width: 500,height: 200,"pointer-events": "stroke"},".header": {fill: "#ffffff",stroke: "#000000",width: 20,ref: ".body","ref-height": 1,"pointer-events": "visiblePainted"},".label": {transform: "rotate(-90)",ref: ".header","ref-x": 10,"ref-y": .5,"font-family": "Arial","font-size": 14,"x-alignment": "middle","text-anchor": "middle"},".lane-body": {fill: "#ffffff",stroke: "#000000","pointer-events": "stroke"},".lane-header": {fill: "#ffffff",stroke: "#000000","pointer-events": "visiblePainted"},".lane-label": {transform: "rotate(-90)","text-anchor": "middle","font-family": "Arial","font-size": 13},".blackbox-wrap": {ref: ".body","ref-width": 1,"ref-height": 1},".blackbox-label": {text: "Black Box",dx: "50%",dy: "50%","text-anchor": "middle",transform: "translate(0,-7)"}}}, joint.dia.Element.prototype.defaults)});
joint.shapes.bpmn.PoolView = joint.dia.ElementView.extend({options: {headerWidth: 20},initialize: function() {
    this.listenTo(this.model, "change:lanes", function(cell, lanes) {
        this.renderLanes(lanes)
    });
    joint.dia.ElementView.prototype.initialize.apply(this, arguments)
},update: function() {
    if (_.isUndefined(this.lanesAttrs)) {
        return this.renderLanes(this.model.get("lanes"))
    }
    return joint.dia.ElementView.prototype.update.call(this, this.model, _.merge({}, this.model.get("attrs"), this.lanesAttrs || {}))
},renderMarkup: function() {
    joint.dia.ElementView.prototype.renderMarkup.apply(this, arguments);
    this.$lanes = this.$(".lanes");
    this.laneMarkup = V(this.model.laneMarkup)
},renderLanes: function(lanes) {
    lanes = lanes || {};
    this.index = 0;
    this.lanesAttrs = {".header": {width: this.options.headerWidth},".label": {text: lanes.label || ""}};
    this.$lanes.empty();
    if (lanes.sublanes) {
        this.renderSublanes(lanes.sublanes, 0, 0, 1)
    }
    this.update(this.model, _.merge({}, this.model.get("attrs"), this.lanesAttrs))
},renderSublanes: function(lanes, prevX, prevY, prevRatio) {
    var headerWidth = this.options.headerWidth;
    var ratio = 1 / lanes.length * prevRatio;
    _.each(lanes, function(lane, index) {
        var className = "lane" + this.index;
        var bodySelector = "." + className + " .lane-body";
        var headerSelector = "." + className + " .lane-header";
        var labelSelector = "." + className + " .lane-label";
        if (lane.name) {
            className += " " + lane.name
        }
        this.$lanes.append(this.laneMarkup.clone().addClass(className).node);
        var x = prevX + headerWidth;
        var y = prevY + ratio * index;
        this.lanesAttrs[bodySelector] = {ref: ".body","ref-height": ratio,"ref-width": -x,"ref-x": x,"ref-y": y};
        this.lanesAttrs[headerSelector] = {width: headerWidth,ref: ".body","ref-height": ratio,"ref-x": x,"ref-y": y};
        this.lanesAttrs[labelSelector] = {text: lane.label,ref: headerSelector,"ref-x": 10,"ref-y": .5,"x-alignment": "middle"};
        this.index++;
        if (lane.sublanes) {
            this.renderSublanes(lane.sublanes, x, y, ratio)
        }
    }, this)
}});
joint.shapes.bpmn.Group = joint.dia.Element.extend({markup: '<g class="rotatable"><g class="scalable"><rect class="body"/></g><rect class="label-rect"/><g class="label-group"><svg overflow="hidden" class="label-wrap"><text class="label"/></svg></g></g>',defaults: joint.util.deepSupplement({type: "bpmn.Group",size: {width: 200,height: 200},attrs: {".body": {width: 200,height: 200,stroke: "#000000","stroke-dasharray": "6,6","stroke-width": 2,fill: "transparent",rx: 15,ry: 15,"pointer-events": "stroke"},".label-rect": {ref: ".body","ref-width": .6,"ref-x": .4,"ref-y": -30,height: 25,fill: "#ffffff",stroke: "#000000"},".label-group": {ref: ".label-rect","ref-x": 0,"ref-y": 0},".label-wrap": {ref: ".label-rect","ref-width": 1,"ref-height": 1},".label": {text: "",x: "50%",dy: 5,"text-anchor": "middle","font-family": "Arial","font-size": 14,fill: "#000000"}}}, joint.dia.Element.prototype.defaults)});
joint.shapes.bpmn.DataObject = joint.dia.Element.extend({markup: '<g class="rotatable"><g class="scalable"><polygon class="body"/></g><text class="label"/></g>',defaults: joint.util.deepSupplement({type: "bpmn.DataObject",size: {width: 60,height: 80},attrs: {".body": {points: "20,0 60,0 60,80 0,80 0,20 20,0 20,20 0,20",stroke: "#000000",fill: "#ffffff"},".label": {ref: ".body","ref-x": .5,"ref-dy": 5,text: "","text-anchor": "middle"}}}, joint.dia.Element.prototype.defaults)});
joint.shapes.bpmn.Conversation = joint.dia.Element.extend({markup: '<g class="rotatable"><g class="scalable"><polygon class="body"/></g><text class="label"/><path class="sub-process"/></g>',defaults: joint.util.deepSupplement({type: "bpmn.Conversation",size: {width: 100,height: 100},attrs: {".body": {points: "25,0 75,0 100,50 75,100 25,100 0,50",stroke: "#000000",fill: "#ffffff"},".label": {text: "",ref: ".body","ref-x": .5,"ref-dy": 5,"text-anchor": "middle"},path: {d: "M 0 0 L 30 0 30 30 0 30 z M 15 4 L 15 26 M 4 15 L 26 15",ref: ".body","ref-x": .5,"ref-dy": -30,"x-alignment": "middle",fill: "#ffffff",stroke: "#000000","fill-opacity": 0}},conversationType: "conversation"}, joint.dia.Element.prototype.defaults),initialize: function() {
    joint.dia.Element.prototype.initialize.apply(this, arguments);
    this.listenTo(this, "change:conversationType", this.onConversationTypeChange);
    this.onConversationTypeChange(this, this.get("conversationType"))
},onConversationTypeChange: function(cell, type) {
    switch (type) {
        case "conversation":
            cell.attr("polygon/stroke-width", 1);
            break;
        case "call-conversation":
            cell.attr("polygon/stroke-width", 4);
            break;
        default:
            throw "BPMN: Unknown Conversation Type: " + type;
            break
    }
}}).extend(joint.shapes.bpmn.SubProcessInterface);
joint.shapes.bpmn.Choreography = joint.shapes.basic.TextBlock.extend({markup: ['<g class="rotatable">', '<g class="scalable"><rect class="body"/></g>', "<switch>", '<foreignObject requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" class="fobj">', '<body xmlns="http://www.w3.org/1999/xhtml"><div/></body>', "</foreignObject>", '<text class="content"/>', "</switch>", '<text class="label"/><path class="sub-process"/><g class="participants"/>', "</g>"].join(""),participantMarkup: '<g class="participant"><rect class="participant-rect"/><text class="participant-label"/></g>',defaults: joint.util.deepSupplement({type: "bpmn.Choreography",size: {width: 60,height: 80},attrs: {rect: {},".body": {width: 60,height: 80,stroke: "#000000",fill: "#ffffff"},".label": {ref: ".body","ref-x": .5,"ref-dy": 5,text: "","text-anchor": "middle"},".participant-rect": {stroke: "#000000",fill: "#aaaaaa",ref: ".body","ref-width": 1},".participant-label": {"text-anchor": "middle",ref: ".participant_0 .participant-rect","ref-x": .5,"ref-y": .5,"y-alignment": "middle"},".sub-process": {d: "M 0 0 L 30 0 30 30 0 30 z M 15 4 L 15 26 M 4 15 L 26 15",ref: ".body","ref-x": .5,"ref-dy": -30,"x-alignment": "middle",fill: "transparent",stroke: "#000000"}},participants: [],initiatingParticipant: 0}, joint.shapes.basic.TextBlock.prototype.defaults)}).extend(joint.shapes.bpmn.SubProcessInterface);
joint.shapes.bpmn.ChoreographyView = joint.shapes.basic.TextBlockView.extend({options: {participantHeight: 20},initialize: function() {
    this.listenTo(this.model, "change:participants", function(cell, participants) {
        this.renderParticipants(participants)
    });
    this.listenTo(this.model, "change:initiatingParticipant", this.layoutAndUpdate);
    joint.shapes.basic.TextBlockView.prototype.initialize.apply(this, arguments);
    if (this.noSVGForeignObjectElement) {
        this.off(null, "change:content").listenTo(this.model, "change:content", function(cell) {
            this.updateContent(cell, this.participantsAttrs)
        })
    }
},update: function() {
    if (_.isUndefined(this.participantsAttrs)) {
        return this.renderParticipants(this.model.get("participants"))
    }
    this.layoutAndUpdate();
    return this
},renderMarkup: function() {
    joint.dia.ElementView.prototype.renderMarkup.apply(this, arguments);
    this.$participants = this.$(".participants");
    this.participantMarkup = V(this.model.participantMarkup)
},renderParticipants: function(participants) {
    this.$participants.empty();
    this.participantsAttrs = {};
    _.each(participants, function(participant, index) {
        var className = "participant_" + index;
        var selector = "." + className;
        this.participantsAttrs[selector + " .participant-rect"] = {height: this.options.participantHeight};
        this.participantsAttrs[selector + " .participant-label"] = {text: participant};
        this.$participants.append(this.participantMarkup.clone().addClass(className).node)
    }, this);
    this.layoutAndUpdate()
},layoutAndUpdate: function() {
    var participants = this.model.get("participants") || [];
    var count = participants.length;
    var pHeight = this.options.participantHeight;
    var eHeight = this.model.get("size").height;
    var bHeight = Math.max(0, eHeight - pHeight * count);
    var offsetY = 0;
    var initiator = this.model.get("initiatingParticipant");
    var i = Math.max(_.isNumber(initiator) ? Math.abs(initiator) : participants.indexOf(initiator), 0);
    var b = Math.min(i, count - 2);
    _.each(participants, function(participant, index) {
        var selector = ".participant_" + index;
        this.participantsAttrs[selector] = {transform: "translate(0," + offsetY + ")"};
        this.participantsAttrs[selector + " .participant-rect"].fill = i == index ? this.model.attr(".body/fill") : this.model.attr(".participant-rect/fill");
        this.participantsAttrs[selector + " .participant-rect"].stroke = i == index ? this.model.attr(".body/stroke") : this.model.attr(".participant-rect/stroke");
        offsetY += pHeight + (b == index ? bHeight : 0)
    }, this);
    var sp = count < 2 ? 0 : b - count + 1;
    this.participantsAttrs[".sub-process"] = {"ref-dy": Math.max(-eHeight, sp * pHeight - 30)};
    var c = count < 2 ? 0 : b + 1;
    this.participantsAttrs[".fobj div"] = {style: {height: bHeight,paddingTop: pHeight * c}};
    this.participantsAttrs[".content"] = {"ref-y": pHeight * c + bHeight / 2};
    var attrs = _.merge({}, this.model.get("attrs"), this.participantsAttrs || {});
    joint.shapes.basic.TextBlockView.prototype.update.call(this, this.model, attrs)
}});
joint.shapes.bpmn.Message = joint.dia.Element.extend({markup: '<g class="rotatable"><g class="scalable"><polygon class="body"/></g><text class="label"/></g>',defaults: joint.util.deepSupplement({type: "bpmn.Message",size: {width: 60,height: 40},attrs: {".body": {points: "0,0 60,0 60,40 0,40 0,0 60,0 30,20 0,0",stroke: "#000000",fill: "#ffffff"},".label": {ref: ".body","ref-x": .5,"ref-dy": 5,text: "","text-anchor": "middle"}}}, joint.dia.Element.prototype.defaults)});
joint.shapes.bpmn.Flow = joint.dia.Link.extend({defaults: {type: "bpmn.Flow",attrs: {".marker-source": {d: "M 0 0"},".marker-target": {d: "M 10 0 L 0 5 L 10 10 z",fill: "#000000"},".connection": {"stroke-dasharray": " ","stroke-width": 1},".connection-wrap": {style: "",onMouseOver: "",onMouseOut: ""}},flowType: "normal"},initialize: function() {
    joint.dia.Link.prototype.initialize.apply(this, arguments);
    this.listenTo(this, "change:flowType", this.onFlowTypeChange);
    this.onFlowTypeChange(this, this.get("flowType"))
},onFlowTypeChange: function(cell, type) {
    var attrs;
    switch (type) {
        case "default":
            attrs = {".marker-source": {d: "M 0 5 L 20 5 M 20 0 L 10 10",fill: "none"}};
            break;
        case "conditional":
            attrs = {".marker-source": {d: "M 20 8 L 10 0 L 0 8 L 10 16 z",fill: "#FFF"}};
            break;
        case "normal":
            attrs = {};
            break;
        case "message":
            attrs = {".marker-target": {fill: "#FFF"},".connection": {"stroke-dasharray": "4,4"}};
            break;
        case "association":
            attrs = {".marker-target": {d: "M 0 0"},".connection": {"stroke-dasharray": "4,4"}};
            break;
        case "conversation":
            attrs = {".marker-target": {d: "M 0 0"},".connection": {"stroke-width": "7px"},".connection-wrap": {style: "stroke: #fff; stroke-width: 5px; opacity: 1;",onMouseOver: "var s=this.style;s.stroke='#000';s.strokeWidth=15;s.opacity=.4",onMouseOut: "var s=this.style;s.stroke='#fff';s.strokeWidth=5;s.opacity=1"}};
            break;
        default:
            throw "BPMN: Unknown Flow Type: " + type
    }
    cell.attr(_.merge({}, this.defaults.attrs, attrs))
}});
if (typeof exports === "object") {
    var joint = {util: require("../src/core").util,shapes: {},dia: {Element: require("../src/joint.dia.element").Element}};
    var _ = require("lodash")
}
joint.shapes.chart = {};
joint.shapes.chart.Plot = joint.shapes.basic.Generic.extend({markup: ['<clipPath class="clip"><rect/></clipPath>', '<g class="rotatable">', '<g class="scalable"></g>', '<g class="background"><rect/><text/></g>', '<g class="axis">', '<g class="y-axis"><path/><g class="ticks"></g></g>', '<g class="x-axis"><path/><g class="ticks"></g></g>', '<g class="markings"></g>', "</g>", '<g class="data"><g class="series"></g></g>', '<g class="foreground">', '<rect/><text class="caption"/><text class="subcaption"/>', '<g class="legend"><g class="legend-items"></g></g>', '<line class="guideline x-guideline" /><line class="guideline y-guideline" />', "</g>", "</g>"].join(""),tickMarkup: '<g class="tick"><line/><text/></g>',pointMarkup: '<g class="point"><circle/><text/></g>',barMarkup: '<path class="bar"/>',markingMarkup: '<g class="marking"><rect/><text/></g>',serieMarkup: '<g><clipPath class="serie-clip"><rect/></clipPath><path/><g class="bars"></g><g class="points"></g></g>',legendItemMarkup: '<g class="legend-item"><circle/><text/></g>',defaults: joint.util.deepSupplement({type: "chart.Plot",attrs: {".data path": {fill: "none",stroke: "black"},".data .bars rect": {fill: "none",stroke: "black"},".background rect": {fill: "white",stroke: "#e5e5e5",opacity: 1},".background text": {fill: "black",text: "No data available.",ref: ".","ref-x": .5,"ref-y": .5,"text-anchor": "middle","y-alignment": "middle",display: "none"},".foreground > rect": {fill: "white",stroke: "#e5e5e5",opacity: 0,"pointer-events": "none"},".foreground .caption": {fill: "black",text: "",ref: ".foreground > rect","ref-x": .5,"ref-y": 10,"text-anchor": "middle","y-alignment": "middle","font-size": 14},".foreground .subcaption": {fill: "black",text: "",ref: ".foreground > rect","ref-x": .5,"ref-y": 23,"text-anchor": "middle","y-alignment": "middle","font-size": 10},".point": {display: "inline-block"},".point circle": {r: 2,stroke: "black",fill: "black",opacity: .3},".point text": {fill: "black","font-size": 8,"text-anchor": "middle",display: "none"},".axis path": {fill: "none",stroke: "black"},".axis .tick": {fill: "none",stroke: "black"},".y-axis .tick line": {fill: "none",stroke: "black",x2: 2,y2: 0,opacity: 1},".x-axis .tick line": {fill: "none",stroke: "black",x2: 0,y2: -3,opacity: 1},".y-axis .tick text": {fill: "black",stroke: "none","font-size": 10,dy: "-.5em",x: -5,"text-anchor": "end"},".x-axis .tick text": {fill: "black",stroke: "none","font-size": 10,dy: ".5em",x: 0,"text-anchor": "middle"},".axis .markings": {fill: "black",stroke: "none","fill-opacity": 1},".axis .markings text": {fill: "black","text-anchor": "end","font-size": 10,dy: -5,dx: -5},".guideline": {"pointer-events": "none",display: "none"},".x-guideline": {stroke: "black",visibility: "hidden"},".y-guideline": {stroke: "black",visibility: "hidden"},".legend": {ref: ".background","ref-x": 10,"ref-y": 10},".legend-item text": {fill: "black",transform: "translate(14, 0)","font-size": 11},".legend-item circle": {r: 5,transform: "translate(5,5)"},".legend-item": {cursor: "pointer"},".legend-item.disabled circle": {fill: "gray"},".legend-item.disabled text": {opacity: .5}}}, joint.shapes.basic.Generic.prototype.defaults),legendPosition: function(pos, opt) {
    opt = opt || {};
    this.trigger("batch:start");
    this.removeAttr([".legend/ref-x", ".legend/ref-y", ".legend/ref-dx", ".legend/ref-dy", ".legend/x-alignment", ".legend/y-alignment"], {silent: true});
    var padding = opt.padding || 10;
    var attrs = {n: {".legend": {"ref-x": .5,"x-alignment": -.5,"ref-y": padding}},ne: {".legend": {"ref-dx": -padding,"x-alignment": -.999,"ref-y": padding}},e: {".legend": {"ref-dx": -padding,"x-alignment": -.999,"ref-y": .5,"y-alignment": -.5}},se: {".legend": {"ref-dx": -padding,"ref-dy": -padding,"x-alignment": -.999,"y-alignment": -.999}},s: {".legend": {"ref-x": .5,"ref-dy": -padding,"x-alignment": -.5,"y-alignment": -.999}},sw: {".legend": {"ref-x": padding,"ref-dy": -padding,"y-alignment": -.999}},w: {".legend": {"ref-x": padding,"ref-y": .5,"y-alignment": -.5}},nw: {".legend": {"ref-x": padding,"ref-y": padding}},nnw: {".legend": {"ref-x": padding,"ref-y": -padding,"y-alignment": -.999}},nn: {".legend": {"ref-x": .5,"ref-y": -padding,"x-alignment": -.5,"y-alignment": -.999}},nne: {".legend": {"ref-dx": -padding,"ref-y": -padding,"x-alignment": -.999,"y-alignment": -.999}},nnee: {".legend": {"ref-dx": padding,"ref-y": -padding,"y-alignment": -.999}},nee: {".legend": {"ref-y": padding,"ref-dx": padding}},ee: {".legend": {"ref-dx": padding,"ref-y": .5,"y-alignment": -.5}},see: {".legend": {"ref-dx": padding,"ref-dy": -padding,"y-alignment": -.999}},ssee: {".legend": {"ref-dx": padding,"ref-dy": padding}},sse: {".legend": {"ref-dx": -padding,"ref-dy": padding,"x-alignment": -.999}},ss: {".legend": {"ref-x": .5,"ref-dy": padding,"x-alignment": -.5}},ssw: {".legend": {"ref-x": padding,"ref-dy": padding}},ssww: {".legend": {"ref-x": -padding,"ref-dy": padding,"x-alignment": -.999}},sww: {".legend": {"ref-x": -padding,"ref-dy": -padding,"x-alignment": -.999,"y-alignment": -.999}},ww: {".legend": {"ref-x": -padding,"ref-y": .5,"x-alignment": -.999,"y-alignment": -.5}},nww: {".legend": {"ref-x": -padding,"ref-y": padding,"x-alignment": -.999}},nnww: {".legend": {"ref-x": -padding,"ref-y": -padding,"x-alignment": -.999,"y-alignment": -.999}}};
    if (attrs[pos]) {
        this.attr(attrs[pos])
    }
    this.trigger("batch:stop")
},addPoint: function(p, serieName, opt) {
    opt = opt || {};
    var series = this.get("series");
    var serieIndex = _.findIndex(series, {name: serieName});
    if (serieIndex === -1) {
        throw new Error("Serie " + serieName + " was not found.")
    }
    var serie = _.cloneDeep(series[serieIndex]);
    serie.data.push(p);
    if (_.isFinite(opt.maxLen) && serie.data.length > opt.maxLen) {
        serie.data.shift()
    }
    series = series.slice();
    series[serieIndex] = serie;
    this.set("series", series, opt)
},lastPoint: function(serieName) {
    return _.last(_.findWhere(this.get("series"), {name: serieName}).data)
},firstPoint: function(serieName) {
    return _.first(_.findWhere(this.get("series"), {name: serieName}).data)
}});
joint.shapes.chart.PlotView = joint.dia.ElementView.extend({events: {mousemove: "onMouseMove",mouseout: "onMouseOut"},initialize: function() {
    joint.dia.ElementView.prototype.initialize.apply(this, arguments);
    this.listenTo(this.model, "change:series change:interpolate change:padding change:canvas change:markings change:axis", _.bind(function() {
        this.update()
    }, this));
    this.on("cell:pointerdown", this.onPointerDown, this);
    this._disabledSeries = []
},renderMarkup: function() {
    joint.dia.ElementView.prototype.renderMarkup.apply(this, arguments);
    this.elDataClipPath = this.$(".clip")[0];
    this.elDataClipPathRect = this.elDataClipPath.firstChild;
    this.elBackgroundRect = this.$(".background rect")[0];
    this.elBackgroundText = this.$(".background text")[0];
    this.elForeground = this.$(".foreground")[0];
    this.elForegroundRect = this.$(".foreground rect")[0];
    this.elDataSeries = this.$(".data .series")[0];
    this.elYAxisPath = this.$(".y-axis path")[0];
    this.elYAxisTicks = this.$(".y-axis .ticks")[0];
    this.elXAxisPath = this.$(".x-axis path")[0];
    this.elXAxisTicks = this.$(".x-axis .ticks")[0];
    this.elMarkings = this.$(".axis .markings")[0];
    this.elXGuideline = this.$(".x-guideline")[0];
    this.elYGuideline = this.$(".y-guideline")[0];
    this.elLegend = this.$(".legend")[0];
    this.elLegendItems = this.$(".legend-items")[0];
    this.elTick = V(this.model.tickMarkup);
    this.elMarking = V(this.model.markingMarkup);
    this.elLegendItem = V(this.model.legendItemMarkup);
    this.elPoint = V(this.model.pointMarkup);
    this.elBar = V(this.model.barMarkup);
    this.elSerie = V(this.model.serieMarkup);
    this.elDataClipPath.id = "clip_" + this.cid;
    V(this.$(".data")[0]).attr("clip-path", "url(#" + this.elDataClipPath.id + ")");
    V(this.elMarkings).attr("clip-path", "url(#" + this.elDataClipPath.id + ")")
},update: function(series) {
    series = this.filterSeries(series);
    this.calculateStats(series);
    var size = this.model.get("size");
    var width = size.width;
    var height = size.height;
    this.canvas = _.extend({x: 0,y: 0,width: width,height: height}, this.model.get("canvas"));
    var padding;
    var defaultPadding = {top: 0,right: 0,bottom: 0,left: 0};
    var modelPadding = this.model.get("padding");
    if (_.isObject(modelPadding)) {
        padding = _.extend({}, defaultPadding, modelPadding)
    } else if (!_.isUndefined(modelPadding)) {
        padding = {top: modelPadding,right: 2 * modelPadding,bottom: 2 * modelPadding,left: modelPadding}
    } else {
        padding = defaultPadding
    }
    this.canvas = g.rect(this.canvas).moveAndExpand(g.rect(padding.left, padding.top, -padding.right, -padding.bottom));
    var viewRect = {x: 0,y: 0,width: width,height: height};
    V(this.elDataClipPathRect).attr(viewRect);
    V(this.elBackgroundRect).attr(viewRect);
    V(this.elForegroundRect).attr(viewRect);
    this.updateAxis();
    this.updateMarkings();
    if (this.isEmpty()) {
        $(this.elBackgroundText).show()
    } else {
        $(this.elBackgroundText).hide()
    }
    this.updateSeries(series);
    this.updateLegend();
    joint.dia.ElementView.prototype.update.apply(this, arguments)
},calculateStats: function(series) {
    series = series || this.model.get("series");
    var xValues = [];
    var yValues = [];
    var xMap = {};
    var yMap = {};
    var bySerie = {};
    _.each(series, function(serie, idx) {
        var stats = bySerie[serie.name || idx] || (bySerie[serie.name || idx] = {});
        stats.decreasingX = true;
        stats.decreasingY = true;
        stats.nonDecreasingX = true;
        stats.nonDecreasingY = true;
        var prev;
        _.each(serie.data, function(dp) {
            stats.minX = _.isUndefined(stats.minX) ? dp.x : Math.min(stats.minX, dp.x);
            stats.maxX = _.isUndefined(stats.maxX) ? dp.x : Math.max(stats.maxX, dp.x);
            stats.minY = _.isUndefined(stats.minY) ? dp.y : Math.min(stats.minY, dp.y);
            stats.maxY = _.isUndefined(stats.maxY) ? dp.y : Math.max(stats.maxY, dp.y);
            if (prev) {
                stats.decreasingX = stats.decreasingX && dp.x < prev.x;
                stats.decreasingY = stats.decreasingY && dp.y < prev.y;
                stats.nonDecreasingX = stats.nonDecreasingX && dp.x >= prev.x;
                stats.nonDecreasingY = stats.nonDecreasingY && dp.y >= prev.y
            }
            if (!_.contains(xValues, dp.x))
                xValues.push(dp.x);
            if (!_.contains(yValues, dp.y))
                yValues.push(dp.y);
            (xMap[dp.x] || (xMap[dp.x] = [])).push({serie: serie,x: dp.x,y: dp.y});
            (yMap[dp.y] || (yMap[dp.y] = [])).push({serie: serie,x: dp.x,y: dp.y});
            prev = dp
        })
    });
    var axis = this.model.get("axis") || {};
    var xAxis = axis["x-axis"] || {};
    var yAxis = axis["y-axis"] || {};
    this.stats = {minX: _.isUndefined(xAxis.min) ? _.min(xValues) : xAxis.min,maxX: _.isUndefined(xAxis.max) ? _.max(xValues) : xAxis.max,minY: _.isUndefined(yAxis.min) ? _.min(yValues) : yAxis.min,maxY: _.isUndefined(yAxis.max) ? _.max(yValues) : yAxis.max,bySerie: bySerie,xValues: xValues,yValues: yValues,xMap: xMap,yMap: yMap}
},isEmpty: function() {
    return !this.stats.xValues.length
},updateSeries: function(series) {
    series = series || this.model.get("series");
    this.elDataSeries.textContent = "";
    if (this.isEmpty())
        return;
    var xDomain = [this.stats.minX, this.stats.maxX];
    var yDomain = [this.stats.minY, this.stats.maxY];
    var xRange = [this.canvas.x, this.canvas.x + this.canvas.width];
    var yRange = [this.canvas.y + this.canvas.height, this.canvas.y];
    var attrs = this.model.get("attrs");
    _.each(series, function(serie, i) {
        var points = serie.data;
        var transformedPoints = [];
        var elSerie = this.elSerie.clone().attr("class", serie.name || "serie-" + i);
        V(this.elDataSeries).append(elSerie);
        _.each(points, function(p) {
            var x = g.scale.linear(xDomain, xRange, p.x);
            var y = g.scale.linear(yDomain, yRange, p.y);
            transformedPoints.push({x: x,y: y});
            if (attrs[".point"] && attrs[".point"].display !== "none") {
                this.renderPoint(p, serie)
            }
            if (serie.bars) {
                this.renderBar(p, serie)
            }
        }, this);
        var elSeriePathClip = elSerie.findOne(".serie-clip");
        var size = this.model.get("size");
        var stats = this.stats.bySerie[serie.name || i];
        var minX = g.scale.linear(xDomain, xRange, stats.minX);
        var maxX = g.scale.linear(xDomain, xRange, stats.maxX);
        var elSeriePathClipRect = elSeriePathClip.findOne("rect");
        elSeriePathClipRect.attr(g.rect(minX, 0, maxX - minX, size.height));
        if (!serie.bars) {
            var elSeriePath = elSerie.findOne("path");
            elSeriePath.attr({d: this.seriePathData(transformedPoints, serie, i),"clip-path": "url(#" + elSeriePathClip.node.id + ")"})
        }
    }, this)
},seriePathClipData: function(points, serie) {
    var padding = 10;
    var size = this.model.get("size");
    var firstPoint = _.first(points);
    var lastPoint = _.last(points);
    var d = ["M", firstPoint.x, firstPoint.y, "V", size.height + padding];
    return d.join(" ")
},renderBar: function(p, serie) {
    var xDomain = [this.stats.minX, this.stats.maxX];
    var yDomain = [this.stats.minY, this.stats.maxY];
    var xRange = [this.canvas.x, this.canvas.x + this.canvas.width];
    var yRange = [this.canvas.y + this.canvas.height, this.canvas.y];
    var x = g.scale.linear(xDomain, xRange, p.x);
    var y = g.scale.linear(yDomain, yRange, p.y);
    var definedBarWidth = serie.bars.barWidth || .8;
    var barWidth = definedBarWidth > 1 ? definedBarWidth : this.canvas.width / (this.stats.maxX - this.stats.minX) * definedBarWidth;
    var barHeight = g.scale.linear(yDomain, yRange, 0) - y;
    var topRx = p["top-rx"] || serie.bars["top-rx"];
    var topRy = p["top-ry"] || serie.bars["top-ry"];
    var bottomRx = p["bottom-rx"] || serie.bars["bottom-rx"];
    var bottomRy = p["bottom-ry"] || serie.bars["bottom-ry"];
    var barX = {left: x,middle: x - barWidth / 2,right: x - barWidth}[serie.bars.align || "middle"];
    var elBar = this.elBar.clone();
    elBar.attr({"data-serie": serie.name,"data-x": p.x,"data-y": p.y,d: V.rectToPath({x: barX,y: y,width: barWidth,height: barHeight,"top-rx": topRx,"top-ry": topRy,"bottom-rx": bottomRx,"bottom-ry": bottomRy})});
    var serieSelector = serie.name || "serie-" + this.model.get("series").indexOf(serie);
    V(this.elDataSeries).findOne("." + serieSelector + " .bars").append(elBar);
    return elBar.node
},renderPoint: function(p, serie) {
    var xDomain = [this.stats.minX, this.stats.maxX];
    var yDomain = [this.stats.minY, this.stats.maxY];
    var xRange = [this.canvas.x, this.canvas.x + this.canvas.width];
    var yRange = [this.canvas.y + this.canvas.height, this.canvas.y];
    var x = g.scale.linear(xDomain, xRange, p.x);
    var y = g.scale.linear(yDomain, yRange, p.y);
    var elPoint = this.elPoint.clone();
    elPoint.attr({"data-serie": serie.name,"data-x": p.x,"data-y": p.y});
    elPoint.findOne("circle").attr({cx: x,cy: y});
    elPoint.findOne("text").attr({x: x,dy: y}).text(this.pointLabel(p, serie));
    var serieSelector = serie.name || "serie-" + this.model.get("series").indexOf(serie);
    V(this.elDataSeries).findOne("." + serieSelector + " .points").append(elPoint);
    return elPoint.node
},seriePathData: function(points, serie, idx) {
    var interpolate = _.isUndefined(serie.interpolate) ? this.model.get("interpolate") : serie.interpolate;
    var d;
    var i;
    var p;
    var pointsLength = points.length;
    switch (interpolate) {
        case "bezier":
            d = g.bezier.curveThroughPoints(points);
            break;
        case "step":
            p = points[0];
            d = ["M", p.x, p.y];
            for (i = 1; i < pointsLength; i++) {
                d.push("H", (p.x + points[i].x) / 2, "V", points[i].y);
                p = points[i]
            }
            break;
        case "stepBefore":
            d = ["M", points[0].x, points[0].y];
            for (i = 1; i < pointsLength; i++) {
                d.push("V", points[i].y, "H", points[i].x)
            }
            break;
        case "stepAfter":
            d = ["M", points[0].x, points[0].y];
            for (i = 1; i < pointsLength; i++) {
                d.push("H", points[i].x, "V", points[i].y)
            }
            break;
        default:
            d = ["M"];
            for (i = 0; i < pointsLength; i++) {
                d.push(points[i].x, points[i].y)
            }
            break
    }
    d = this.fixPathForFill(d, points, serie, idx);
    return d.join(" ")
},fixPathForFill: function(d, points, serie, idx) {
    if (points.length === 0)
        return d;
    var stats = this.stats.bySerie[serie.name || idx];
    if (!stats.nonDecreasingX)
        return d;
    var padding = 10;
    var size = this.model.get("size");
    var firstPoint = _.first(points);
    var lastPoint = _.last(points);
    var dPrefix = ["M", lastPoint.x, size.height + padding, "H", firstPoint.x - padding, "V", firstPoint.y];
    d[0] = "L";
    return dPrefix.concat(d)
},updateAxis: function() {
    var size = this.model.get("size");
    var width = size.width;
    var height = size.height;
    var axis = this.model.get("axis");
    var canvasHeightRatio = this.canvas.height / height;
    var canvasWidthRatio = this.canvas.width / width;
    V(this.elYAxisPath).attr("d", ["M", 0, 0, "L", 0, height].join(" "));
    V(this.elXAxisPath).attr("d", ["M", 0, height, "L", width, height].join(" "));
    this.elXAxisTicks.textContent = "";
    this.elYAxisTicks.textContent = "";
    if (this.isEmpty())
        return;
    var xDomain = [this.stats.minX, this.stats.maxX];
    var yDomain = [this.stats.minY, this.stats.maxY];
    var xRange = [this.canvas.x, this.canvas.x + this.canvas.width];
    var yRange = [0, this.canvas.height];
    var xDomainSpan = xDomain[1] - xDomain[0];
    var yDomainSpan = yDomain[1] - yDomain[0];
    var yAxis = axis && axis["y-axis"] || {};
    var xAxis = axis && axis["x-axis"] || {};
    var ticks = yDomainSpan > 0 ? yAxis.ticks - 1 || 10 : 0;
    var tickStep = yDomainSpan / ticks / canvasHeightRatio;
    var y = yDomain[0];
    _.each(_.range(ticks + 1), function(i) {
        var ty = g.scale.linear(yDomain, yRange, y);
        var elTick = this.elTick.clone();
        elTick.translate(0, ty);
        V(this.elYAxisTicks).append(elTick);
        var tickValue = yDomain[1] - (y - yDomain[0]);
        tickValue += g.scale.linear(yRange, yDomain, this.canvas.y) - yDomain[0];
        elTick.findOne("text").text(this.tickLabel(tickValue, yAxis));
        y += tickStep
    }, this);
    _.each(this.stats.xValues, function(x, i) {
        if (i % (xAxis.tickStep || 1) !== 0)
            return;
        var tx = g.scale.linear(xDomain, xRange, x);
        if (tx > width)
            return;
        var elTick = this.elTick.clone();
        elTick.translate(tx, height);
        V(this.elXAxisTicks).append(elTick);
        elTick.findOne("text").text(this.tickLabel(x, xAxis))
    }, this)
},tickLabel: function(value, opt) {
    if (_.isFunction(opt.tickFormat)) {
        return opt.tickFormat(value)
    }
    var formatSpecifier = opt.tickFormat || ".1f";
    var label = joint.util.format.number(formatSpecifier, value);
    return label + (_.isFunction(opt.tickSuffix) ? opt.tickSuffix(value) : opt.tickSuffix || "")
},pointLabel: function(p, opt) {
    if (_.isFunction(opt.pointFormat)) {
        return opt.pointFormat(p)
    }
    var formatSpecifier = opt.pointFormat || ".1f";
    var label = joint.util.format.number(formatSpecifier, p.y);
    return label + (opt.pointSuffix || "")
},updateMarkings: function() {
    this.elMarkings.textContent = "";
    var markings = this.model.get("markings");
    if (!markings || markings.length === 0)
        return;
    var size = this.model.get("size");
    var width = size.width;
    var height = size.height;
    var xDomain = [this.stats.minX, this.stats.maxX];
    var yDomain = [this.stats.minY, this.stats.maxY];
    var xRange = [this.canvas.x, this.canvas.x + this.canvas.width];
    var yRange = [this.canvas.y, this.canvas.y + this.canvas.height];
    function firstDefined(a, b) {
        return _.isUndefined(a) ? b : a
    }
    _.each(markings, function(marking, i) {
        var start = marking.start || marking.end;
        var end = marking.end || marking.start;
        var startX = Math.min(firstDefined(start.x, this.stats.minX), firstDefined(end.x, this.stats.minX));
        var endX = Math.max(firstDefined(start.x, this.stats.maxX), firstDefined(end.x, this.stats.maxX));
        var startY = Math.min(firstDefined(start.y, this.stats.minY), firstDefined(end.y, this.stats.minY));
        var endY = Math.max(firstDefined(start.y, this.stats.maxY), firstDefined(end.y, this.stats.maxY));
        var isTrendLineX = _.isUndefined(start.x) || _.isUndefined(end.x);
        var isTrendLineY = _.isUndefined(start.y) || _.isUndefined(end.y);
        if (isTrendLineX)
            xRange = [0, width];
        if (isTrendLineY)
            yRange = [0, height];
        var startTx = g.scale.linear(xDomain, xRange, startX);
        var endTx = g.scale.linear(xDomain, xRange, endX);
        var startTy = g.scale.linear(yDomain, yRange, startY);
        var endTy = g.scale.linear(yDomain, yRange, endY);
        var mx = startTx;
        var my = yRange[1] - endTy + yRange[0];
        var mw = endTx - startTx;
        var mh = endTy - startTy;
        mw = Math.max(mw, 1);
        mh = Math.max(mh, 1);
        var elMarking = this.elMarking.clone();
        elMarking.findOne("rect").attr({x: mx,y: my,width: mw,height: mh});
        elMarking.findOne("text").text(marking.label || "").attr({x: mx + mw,y: my});
        var className = elMarking.attr("class") + " " + (marking.name || "marking-" + i);
        elMarking.attr(_.extend({"class": className}, marking.attrs));
        V(this.elMarkings).append(elMarking)
    }, this)
},updateLegend: function() {
    var series = this.model.get("series");
    this.elLegendItems.textContent = "";
    _.each(series, function(serie, i) {
        if (_.isFunction(serie.showLegend) && !serie.showLegend(serie, this.stats.bySerie[serie.name || i])) {
            return
        } else if (serie.showLegend === false) {
            return
        }
        var elLegendItem = this.elLegendItem.clone();
        if (_.contains(this._disabledSeries, serie.name)) {
            elLegendItem.addClass("disabled")
        }
        elLegendItem.attr("data-serie", serie.name);
        elLegendItem.findOne("circle").attr({fill: this.getSerieColor(serie.name)});
        elLegendItem.findOne("text").text(serie.label || serie.name);
        elLegendItem.translate(0, i * (serie.legendLabelLineHeight || 16));
        V(this.elLegendItems).append(elLegendItem)
    }, this)
},getSerieColor: function(serieName) {
    var attrs = this.model.get("attrs");
    var serieAttrs = _.find(attrs, function(attr, selector) {
        if (_.contains(selector, serieName))
            return true
    });
    return serieAttrs ? serieAttrs.stroke || serieAttrs.fill : "black"
},hideSerie: function(serieName) {
    if (!_.contains(this._disabledSeries, serieName)) {
        this._disabledSeries.push(serieName)
    }
    var series = this.filterSeries();
    this.update(series)
},showSerie: function(serieName) {
    this._disabledSeries = _.without(this._disabledSeries, serieName);
    var series = this.filterSeries();
    this.update(series)
},filterSeries: function(series) {
    series = series || this.model.get("series");
    series = _.reject(series, function(serie) {
        return _.contains(this._disabledSeries, serie.name)
    }, this);
    return series
},onPointerDown: function(evt, x, y) {
    var elLegendItem = $(evt.target).closest(".legend-item")[0];
    if (elLegendItem) {
        V(elLegendItem).toggleClass("disabled");
        if (V(elLegendItem).hasClass("disabled")) {
            this.hideSerie(V(elLegendItem).attr("data-serie"))
        } else {
            this.showSerie(V(elLegendItem).attr("data-serie"))
        }
    }
},onMouseMove: function(evt) {
    this.showGuidelines(evt.clientX, evt.clientY, evt)
},onMouseOut: function(evt) {
    this.hideGuidelines();
    this.trigger("mouseout", evt)
},showGuidelines: function(clientX, clientY, evt) {
    var angle = this.model.get("angle");
    var bbox = this.model.getBBox();
    var series = this.model.get("series");
    var localPoint = g.point(V(this.paper.viewport).toLocalPoint(clientX, clientY)).rotate(bbox.center(), angle);
    if (g.rect(bbox).containsPoint(localPoint)) {
        var size = this.model.get("size");
        var x = localPoint.x - bbox.x;
        var y = localPoint.y - bbox.y;
        V(this.elXGuideline).attr({x1: x,y1: 0,x2: x,y2: size.height,visibility: "visible"});
        V(this.elYGuideline).attr({x1: 0,y1: y,x2: size.width,y2: y,visibility: "visible"});
        var dataX = g.scale.linear([this.canvas.x, this.canvas.x + this.canvas.width], [this.stats.minX, this.stats.maxX], x);
        var dataY = g.scale.linear([this.canvas.y, this.canvas.y + this.canvas.height], [this.stats.minY, this.stats.maxY], y);
        var dataPoint = {x: dataX,y: this.stats.minY + this.stats.maxY - dataY};
        var clientPoint = {x: clientX,y: clientY};
        var closestPoints = this.closestPoints(dataX);
        this.trigger("mouseover", dataPoint, clientPoint, closestPoints, evt)
    }
},closestPoints: function(x) {
    var xValuesIndex = _.sortedIndex(this.stats.xValues, x);
    var xValue = this.stats.xValues[xValuesIndex];
    var xValueBefore = this.stats.xValues[xValuesIndex - 1];
    var xClosest = _.isUndefined(xValueBefore) ? xValue : Math.abs(x - xValue) < Math.abs(x - xValueBefore) ? xValue : xValueBefore;
    return this.stats.xMap[xClosest]
},hideGuidelines: function() {
    V(this.elXGuideline).attr("visibility", "hidden");
    V(this.elYGuideline).attr("visibility", "hidden")
}});
joint.shapes.chart.Pie = joint.shapes.basic.Generic.extend({markup: ['<g class="rotatable">', '<g class="scalable"></g>', '<g class="background"><rect/><text/></g>', '<g class="data"></g>', '<g class="foreground">', '<rect/><text class="caption"/><text class="subcaption"/>', '<g class="legend"><g class="legend-items"></g></g>', "</g>", "</g>"].join(""),sliceMarkup: '<g class="slice"/>',sliceFillMarkup: '<path class="slice-fill"/>',sliceBorderMarkup: '<path class="slice-border"/>',sliceInnerLabelMarkup: '<text class="slice-inner-label"/>',legendSerieMarkup: '<g class="legend-serie"><text/></g>',legendSliceMarkup: '<g class="legend-slice"><circle/><text/></g>',defaults: joint.util.deepSupplement({type: "chart.Pie",size: {width: 200,height: 200},pieHole: 0,serieDefaults: {startAngle: 0,degree: 360,label: null,showLegend: true,labelLineHeight: 6},sliceDefaults: {innerLabel: "{percentage:.0f}%",innerLabelMargin: 6,legendLabel: "{label}: {value}",legendLabelLineHeight: 6,legendLabelMargin: 14,offset: 0,onClickEffect: {type: "offset",offset: 20},onHoverEffect: null},series: [],attrs: {".background > rect": {opacity: 0},".background > text": {fill: "black",text: "No data available.",ref: ".background > rect","ref-x": .5,"ref-y": .5,"text-anchor": "middle","y-alignment": "middle",display: "none"},".foreground > rect": {fill: "white",stroke: "#e5e5e5",opacity: 0,"pointer-events": "none"},".foreground .caption": {fill: "black",text: "",ref: ".foreground > rect","ref-x": 2,"ref-y": 6,"text-anchor": "start","y-alignment": "middle","font-size": 14},".foreground .subcaption": {fill: "black",text: "",ref: ".foreground > rect","ref-x": 2,"ref-y": 18,"text-anchor": "start","y-alignment": "middle","font-size": 10},".data": {ref: ".background","ref-x": .5,"ref-y": .5},".slice": {cursor: "pointer"},".slice > .slice-fill": {stroke: "#ffffff","stroke-width": 1,"fill-opacity": 1},".slice.hover > .slice-fill": {"fill-opacity": .8},".slice > .slice-border": {"stroke-width": 6,"stroke-opacity": .4,"fill-opacity": 1,fill: "none",display: "none"},".slice.hover > .slice-border": {display: "block"},".slice > .slice-inner-label": {"text-anchor": "middle","font-size": "12",stroke: "none","stroke-width": "0",fill: "#ffffff",dy: "-.5em"},".legend": {ref: ".background","ref-dx": 20,"ref-y": 5},".legend-serie text": {fill: "grey",transform: "translate(2, 0)","font-size": 13},".legend-slice": {cursor: "pointer"},".legend-slice text": {"font-weight": "normal",fill: "black","font-size": 11},".legend-slice.hover text": {"font-weight": "bold"},".legend-slice circle": {r: 5,transform: "translate(5,5)"}}}, joint.shapes.basic.Generic.prototype.defaults),addSlice: function(slice, serieIndex, opt) {
    opt = opt || {};
    serieIndex = serieIndex || 0;
    var series = this.get("series");
    if (_.isUndefined(series[serieIndex]))
        series[serieIndex] = {data: []};
    var serie = _.cloneDeep(series[serieIndex]);
    serie.data.push(slice);
    series = series.slice();
    series[serieIndex] = serie;
    opt = serie.data.length > 1 ? _.extend(opt, {changedSerieIndex: serieIndex}) : opt;
    this.set("series", series, opt)
},editSlice: function(slice, sliceIndex, serieIndex, opt) {
    opt = opt || {};
    serieIndex = serieIndex || 0;
    var series = this.get("series");
    if (_.isUndefined(series[serieIndex]) || _.isUndefined(series[serieIndex].data[sliceIndex])) {
        throw new Error("Slice " + sliceIndex + " on serie " + serieIndex + " was not found.")
    }
    var serie = _.cloneDeep(series[serieIndex]);
    serie.data[sliceIndex] = _.extend(serie.data[sliceIndex], slice);
    series = series.slice();
    series[serieIndex] = serie;
    this.set("series", series, _.extend(opt, {changedSerieIndex: serieIndex}))
}});
joint.shapes.chart.PieView = joint.dia.ElementView.extend({events: {"mouseover .slice": "onMouseOverSlice","mouseout .slice": "onMouseOverSlice","mousemove .slice": "onMouseMoveSlice","mouseover .legend-slice": "onEventLegendItem","mouseout .legend-slice": "onEventLegendItem"},initialize: function() {
    joint.dia.ElementView.prototype.initialize.apply(this, arguments);
    this.listenTo(this.model, "change:series change:serieDefaults change:sliceDefaults change:pieHole", function(model, attr, opt) {
        this.update(null, null, opt.changedSerieIndex)
    });
    this.on("cell:pointerclick", this.onClickSlice, this);
    this.on("cell:pointerclick", this.onEventLegendItem, this)
},renderMarkup: function() {
    joint.dia.ElementView.prototype.renderMarkup.apply(this, arguments);
    this.elBackgroundRect = this.$(".background rect")[0];
    this.elBackgroundText = this.$(".background text")[0];
    this.elForegroundRect = this.$(".foreground rect")[0];
    this.elLegendItems = this.$(".legend-items")[0];
    this.elPie = this.$(".data")[0];
    this.elSlice = V(this.model.sliceMarkup);
    this.elSliceFill = V(this.model.sliceFillMarkup);
    this.elSliceBorder = V(this.model.sliceBorderMarkup);
    this.elSliceInnerLabel = V(this.model.sliceInnerLabelMarkup);
    this.elLegendSerie = V(this.model.legendSerieMarkup);
    this.elLegendSlice = V(this.model.legendSliceMarkup)
},update: function(cell, renderingOnlyAttrs, serieIndex) {
    var series = this.calculateSeries(serieIndex);
    if (serieIndex in series) {
        $(this.elPie).find(".serie-" + serieIndex).remove()
    } else {
        $(this.elPie).empty()
    }
    var size = this.model.get("size");
    V(this.elBackgroundRect).attr(size);
    V(this.elForegroundRect).attr(size);
    if (!series.length) {
        $(this.elBackgroundText).show()
    } else {
        $(this.elBackgroundText).hide()
    }
    _.each(series, function(serie, index) {
        if (!_.isUndefined(serieIndex) && serieIndex !== index)
            return;
        _.each(serie.data, function(slice) {
            this.updateSlice(slice)
        }, this)
    }, this);
    this.updateLegend();
    joint.dia.ElementView.prototype.update.apply(this, arguments)
},calculateSeries: function(serieIndex) {
    var series = _.cloneDeep(this.model.get("series"));
    var serieDefaults = this.model.get("serieDefaults");
    var sliceDefaults = this.model.get("sliceDefaults");
    var size = this.model.get("size");
    var radius = _.min([size.width, size.height]) / 2;
    var pieHole = this.model.get("pieHole");
    pieHole = pieHole > 1 ? pieHole : radius * pieHole;
    var outerRadius = radius;
    var radiusStep = (radius - pieHole) / series.length;
    this._series = _.map(series, function(serie, index) {
        if (!_.isUndefined(serieIndex) && serieIndex !== index)
            return serie;
        serie = _.defaults(serie, serieDefaults);
        var startAngle = serie.startAngle;
        var total = _.reduce(serie.data, function(sum, slice) {
            return sum + slice.value
        }, 0);
        var circleDividedByTotal = serie.degree / total || 0;
        var percentageDividedByTotal = 100 / total;
        serie.data = _.map(serie.data, function(slice, sliceIndex) {
            slice = _.defaults(slice, _.omit(sliceDefaults, "offset", "onClickEffect", "onHoverEffect"));
            slice.outerRadius = outerRadius;
            slice.innerRadius = outerRadius - radiusStep;
            if (!index) {
                slice = _.defaults(slice, _.pick(sliceDefaults, "offset", "onClickEffect", "onHoverEffect"));
                slice.outer = true;
                slice.offset = slice.offset > 1 ? slice.offset : slice.offset * slice.outerRadius;
                slice.onClickEffect.offset = slice.onClickEffect.offset > 1 ? slice.onClickEffect.offset : slice.onClickEffect.offset * slice.outerRadius
            }
            slice.serieIndex = index;
            slice.sliceIndex = sliceIndex;
            slice.innerLabelMargin = slice.innerLabelMargin < -1 || slice.innerLabelMargin > 1 ? slice.innerLabelMargin : slice.innerLabelMargin * slice.outerRadius;
            slice.percentage = slice.value * percentageDividedByTotal;
            var angle = slice.value * circleDividedByTotal;
            slice.degree = {angle: angle,start: startAngle,end: angle + startAngle};
            slice.rad = {angle: g.toRad(slice.degree.angle, true),start: g.toRad(slice.degree.start, true),end: g.toRad(slice.degree.end, true)};
            slice.middleangle = (slice.rad.start + slice.rad.end) / 2;
            startAngle = slice.degree.end;
            return slice
        });
        outerRadius -= radiusStep;
        return serie
    });
    return this._series
},updateLegend: function() {
    var series = this._series;
    this.elLegendItems.textContent = "";
    var xPadding = 0;
    var fontSizeLegendSerieText = parseInt(this.model.attr(".legend-serie text/font-size"), 10);
    var fontSizeLegendSliceText = parseInt(this.model.attr(".legend-slice text/font-size"), 10);
    _.each(series, function(serie, serieIndex) {
        if (!serie.showLegend)
            return;
        if (serie.label) {
            var elLegendSerie = this.elLegendSerie.clone();
            if (serie.name)
                elLegendSerie.addClass(serie.name);
            elLegendSerie.attr({"data-serie": serieIndex});
            elLegendSerie.findOne("text").text(serie.label);
            elLegendSerie.translate(0, xPadding);
            V(this.elLegendItems).append(elLegendSerie);
            xPadding += fontSizeLegendSerieText + serie.labelLineHeight
        }
        _.each(serie.data, function(slice, sliceIndex) {
            var elLegendSlice = this.elLegendSlice.clone();
            var slicefillColor = this.getSliceFillColor(sliceIndex, serieIndex);
            if (slice.name)
                elLegendSlice.addClass(slice.name);
            elLegendSlice.attr({"data-serie": serieIndex,"data-slice": sliceIndex});
            elLegendSlice.findOne("circle").attr({fill: slicefillColor});
            elLegendSlice.findOne("text").text(joint.util.format.string(slice.legendLabel, slice));
            elLegendSlice.findOne("text").translate(slice.legendLabelMargin);
            elLegendSlice.translate(0, xPadding);
            xPadding += fontSizeLegendSliceText + slice.legendLabelLineHeight;
            V(this.elLegendItems).append(elLegendSlice);
            if (_.isObject(slicefillColor)) {
                this.applyGradient("#" + elLegendSlice.findOne("circle").attr("id"), "fill", slicefillColor)
            }
        }, this)
    }, this)
},updateSlice: function(slice) {
    var elSlice = this.elSlice.clone();
    V(this.elPie).append(elSlice);
    var elSliceFill = this.elSliceFill.clone();
    var slicefillColor = this.getSliceFillColor(slice.sliceIndex, slice.serieIndex);
    elSliceFill.attr({fill: slicefillColor,d: this.drawSlice(slice.innerRadius, slice.outerRadius, slice.rad.start, slice.rad.end)});
    elSlice.append(elSliceFill);
    if (_.isObject(slicefillColor)) {
        this.applyGradient("#" + elSliceFill.attr("id"), "fill", slicefillColor)
    }
    var elSliceBorder = this.elSliceBorder.clone();
    var borderStrokeWidth = parseInt(this.model.attr(".slice > .slice-border/stroke-width"), 10);
    var startPoint = g.point.fromPolar(slice.outerRadius + borderStrokeWidth / 2, -slice.rad.start, g.point(0, 0));
    var endPoint = g.point.fromPolar(slice.outerRadius + borderStrokeWidth / 2, -slice.rad.end, g.point(0, 0));
    elSliceBorder.attr({stroke: slicefillColor,d: this.drawArc(startPoint, endPoint, slice.outerRadius + borderStrokeWidth / 2, slice.rad.start, slice.rad.end)});
    elSlice.append(elSliceBorder);
    if (_.isObject(slicefillColor)) {
        this.applyGradient("#" + elSliceBorder.attr("id"), "stroke", slicefillColor)
    }
    var elSliceInnerLabel = this.elSliceInnerLabel.clone();
    elSliceInnerLabel.text(joint.util.format.string(slice.innerLabel, slice));
    elSlice.append(elSliceInnerLabel);
    var innerLabelBbox = elSliceInnerLabel.bbox();
    var radiusLabel = slice.outerRadius - innerLabelBbox.width / 2 - slice.innerLabelMargin;
    elSliceInnerLabel.translate(radiusLabel * Math.cos(-slice.middleangle), -radiusLabel * Math.sin(-slice.middleangle));
    elSlice.attr({"data-serie": slice.serieIndex,"data-slice": slice.sliceIndex,"data-value": slice.value});
    var nameSerie = this._series[slice.serieIndex].name;
    if (nameSerie)
        elSlice.addClass(nameSerie);
    if (slice.name)
        elSlice.addClass(slice.name);
    elSlice.addClass("serie-" + slice.serieIndex + " slice-" + slice.sliceIndex);
    if (slice.outer) {
        elSlice.addClass("outer");
        if (slice.offset) {
            elSlice.addClass("clicked");
            this.effectOnSlice(elSlice, slice, {type: "offset",offset: slice.offset})
        }
    }
    return elSlice
},getSliceFillColor: function(sliceIndex, serieIndex) {
    serieIndex = serieIndex || 0;
    var attrs = this.model.get("attrs");
    var sliceFillAttr = _.find(attrs, function(attr, selector) {
        return selector.indexOf(".serie-" + serieIndex + ".slice-" + sliceIndex + " > .slice-fill") > -1
    });
    return sliceFillAttr ? sliceFillAttr.fill : this._series[serieIndex].data[sliceIndex].fill
},onMouseMoveSlice: function(event) {
    var elSlice = V(event.currentTarget);
    var serieIndex = elSlice.attr("data-serie");
    var sliceIndex = elSlice.attr("data-slice");
    var slice = this._series[serieIndex].data[sliceIndex];
    this.trigger(event.type, slice, event)
},mouseOverSlice: function(sliceIndex, serieIndex) {
    serieIndex = serieIndex || 0;
    var elSlice = V(this.$('.slice[data-serie="' + serieIndex + '"][data-slice="' + sliceIndex + '"]')[0]);
    var slice = this._series[serieIndex].data[sliceIndex];
    elSlice.toggleClass("hover");
    if (slice.outer && !_.isEmpty(slice.onHoverEffect)) {
        this.effectOnSlice(elSlice, slice, slice.onHoverEffect, elSlice.hasClass("hover") ? false : true)
    }
    var elLegendSlice = V(this.$('.legend-slice[data-serie="' + serieIndex + '"][data-slice="' + sliceIndex + '"]')[0]);
    if (elLegendSlice)
        elLegendSlice.toggleClass("hover");
    var attrsForSliceAndLegend = _.filter(_.keys(this.model.get("attrs")), function(selector) {
        return selector.indexOf(".slice") > -1 || selector.indexOf(".legend-slice") > -1
    });
    joint.dia.ElementView.prototype.update.call(this, this.model, _.pick(this.model.get("attrs"), attrsForSliceAndLegend))
},onMouseOverSlice: function(event) {
    var elSlice = V(event.currentTarget);
    var serieIndex = elSlice.attr("data-serie");
    var sliceIndex = elSlice.attr("data-slice");
    this.mouseOverSlice(sliceIndex, serieIndex);
    var slice = this._series[serieIndex].data[sliceIndex];
    this.trigger(event.type, slice, event)
},clickSlice: function(sliceIndex, serieIndex) {
    serieIndex = serieIndex || 0;
    var elSlice = V(this.$('.slice[data-serie="' + serieIndex + '"][data-slice="' + sliceIndex + '"]')[0]);
    var slice = this._series[serieIndex].data[sliceIndex];
    if (!slice.outer)
        return;
    if (!elSlice.hasClass("clicked")) {
        elSlice.addClass("clicked");
        this.model.get("series")[serieIndex].data[sliceIndex].offset = slice.onClickEffect.offset;
        this.effectOnSlice(elSlice, slice, slice.onClickEffect)
    } else {
        elSlice.removeClass("clicked");
        this.model.get("series")[serieIndex].data[sliceIndex].offset = 0;
        this.effectOnSlice(elSlice, slice, slice.onClickEffect, true)
    }
},onClickSlice: function(event) {
    var elSlice = V($(event.target).closest(".slice.outer")[0]);
    if (elSlice) {
        var serieIndex = elSlice.attr("data-serie");
        var sliceIndex = elSlice.attr("data-slice");
        this.clickSlice(sliceIndex, serieIndex);
        var slice = this._series[serieIndex].data[sliceIndex];
        this.trigger(event.type, slice, event)
    }
},onEventLegendItem: function(event) {
    var elLegendItem = V($(event.target).closest(".legend-slice")[0]);
    if (elLegendItem) {
        var serieIndex = elLegendItem.attr("data-serie");
        var sliceIndex = elLegendItem.attr("data-slice");
        switch (event.type) {
            case "click":
                this.clickSlice(sliceIndex, serieIndex);
                break;
            case "mouseover":
            case "mouseout":
                this.mouseOverSlice(sliceIndex, serieIndex);
                break
        }
    }
},effectOnSlice: function(elSlice, slice, effect, remove) {
    remove = remove || false;
    switch (effect.type) {
        case "enlarge":
            if (!remove)
                elSlice.scale(effect.scale || 1.05);
            else
                elSlice.scale(1);
            break;
        case "offset":
            if (!remove)
                elSlice.translate(effect.offset * Math.cos(-slice.middleangle), -effect.offset * Math.sin(-slice.middleangle));
            else
                elSlice.translate(0, 0, {absolute: true});
            break
    }
},svgArcMax: 2 * Math.PI - 1e-6,drawArc: function(startPoint, endPoint, radius, startAngle, endAngle) {
    var largeArcFlag = 0;
    var sweepFlag = 1;
    var angle = endAngle - startAngle;
    if (angle > Math.PI) {
        largeArcFlag = 1;
        if (angle >= this.svgArcMax) {
            largeArcFlag = 0;
            sweepFlag = 0
        }
    }
    return "M" + startPoint.x + "," + startPoint.y + " A" + radius + "," + radius + " 0 " + largeArcFlag + "," + sweepFlag + " " + endPoint.x + "," + endPoint.y
},drawSlice: function(innerRadius, outerRadius, startAngle, endAngle) {
    var r0 = innerRadius;
    var r1 = outerRadius;
    var a0 = startAngle;
    var a1 = endAngle;
    var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);
    var df = da < Math.PI ? "0" : "1";
    var c0 = Math.cos(a0);
    var s0 = Math.sin(a0);
    var c1 = Math.cos(a1);
    var s1 = Math.sin(a1);
    return da >= this.svgArcMax ? r0 ? "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "M0," + r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + -r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + r0 + "Z" : "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z" : r0 ? "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L" + r0 * c1 + "," + r0 * s1 + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0 + "Z" : "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L0,0" + "Z"
}});
joint.shapes.chart.Knob = joint.shapes.chart.Pie.extend({defaults: joint.util.deepSupplement({type: "chart.Knob",sliceDefaults: {legendLabel: "{value:.0f}",outer: {offsetOnClick: 0}},pieHole: .7,value: 0,attrs: {".legend": {"ref-x": .5,"ref-y": .5,"x-alignment": -.9,"y-alignment": -.4},".legend-slice text": {"font-size": 30},".legend-slice circle": {display: "none"},".slice-inner-label": {display: "none"},".slice-fill": {stroke: "none"}}}, joint.shapes.chart.Pie.prototype.defaults),initialize: function() {
    this.set("series", this.getKnobSeries(), {silent: true});
    joint.shapes.chart.Pie.prototype.initialize.apply(this, arguments);
    this.on("change:value change:min change:max change:fill", this.updateKnob, this)
},getKnobSeries: function() {
    var values = _.isArray(this.get("value")) ? this.get("value") : [this.get("value")];
    var fills = _.isArray(this.get("fill")) ? this.get("fill") : [this.get("fill")];
    var mins = _.isArray(this.get("min")) ? this.get("min") : [this.get("min")];
    var maxs = _.isArray(this.get("max")) ? this.get("max") : [this.get("max")];
    var series = _.map(values, function(value, i) {
        var min = _.isUndefined(mins[i]) ? mins[0] : mins[i];
        var max = _.isUndefined(maxs[i]) ? maxs[0] : maxs[i];
        var fill = _.isUndefined(fills[i]) ? fills[0] : fills[i];
        return {degree: g.scale.linear([min, max], [0, 360], value),data: [{value: value,fill: fill}],showLegend: i > 0 ? false : true}
    });
    return series
},updateKnob: function() {
    this.set("series", this.getKnobSeries())
}});
joint.shapes.chart.KnobView = joint.shapes.chart.PieView;
joint.shapes.chart.Matrix = joint.shapes.basic.Generic.extend({markup: ['<g class="rotatable">', '<g class="scalable">', '<g class="background"><rect/></g>', '<g class="cells"/>', '<g class="foreground"/>', "</g>", '<g class="labels">', '<g class="rows"/>', '<g class="columns"/>', "</g>", "</g>"].join(""),cellMarkup: '<rect class="cell"/>',labelMarkup: '<text class="label"/>',gridLineMarkup: '<path class="grid-line"/>',defaults: joint.util.deepSupplement({type: "chart.Matrix",attrs: {".background rect": {fill: "#eeeeee"},".grid-line": {stroke: "white","stroke-width": 2},".label": {fill: "black","alignment-baseline": "middle"},".labels .rows .label": {"text-anchor": "end"},".labels .columns .label": {"text-anchor": "start"}}}, joint.shapes.basic.Generic.prototype.defaults)});
joint.shapes.chart.MatrixView = joint.dia.ElementView.extend({initialize: function() {
    joint.dia.ElementView.prototype.initialize.apply(this, arguments);
    this.listenTo(this.model, "change:size", _.bind(function() {
        this.renderLabels();
        this.update()
    }, this));
    this.listenTo(this.model, "change:cells", _.bind(function() {
        this.renderMarkup();
        this.update()
    }, this))
},renderMarkup: function() {
    joint.dia.ElementView.prototype.renderMarkup.apply(this, arguments);
    this.elCells = this.$(".cells")[0];
    this.elRowLabels = this.$(".labels .rows")[0];
    this.elColumnLabels = this.$(".labels .columns")[0];
    this.elForeground = this.$(".foreground")[0];
    this.elCell = V(this.model.cellMarkup);
    this.elGridLine = V(this.model.gridLineMarkup);
    var cells = this.model.get("cells") || [];
    var size = this.model.get("size");
    this.elBackgroundRect = this.$(".background rect")[0];
    V(this.elBackgroundRect).attr(size);
    var cellHeight = size.height / cells.length;
    var cellWidth = size.width / cells.length;
    var elCellsFragment = document.createDocumentFragment();
    this.elCells.textContent = "";
    this.elForeground.textContent = "";
    var elGridLinesFragment = document.createDocumentFragment();
    for (var i = 0; i < cells.length; i++) {
        var elGridLine = this.elGridLine.clone();
        elGridLine.addClass("horizontal");
        elGridLine.attr("d", "M 0 " + i * cellHeight + " " + size.width + " " + i * cellHeight);
        elGridLinesFragment.appendChild(elGridLine.node);
        var row = cells[i];
        for (var j = 0; j < row.length; j++) {
            if (i === 0) {
                var elGridLine = this.elGridLine.clone();
                elGridLine.addClass("vertical");
                elGridLine.attr("d", "M " + j * cellWidth + " 0 " + j * cellWidth + " " + size.height);
                elGridLinesFragment.appendChild(elGridLine.node)
            }
            var cell = row[j];
            if (cell) {
                var elCell = this.elCell.clone();
                elCell.attr(_.extend({x: j * cellWidth,y: i * cellHeight,width: cellWidth,height: cellHeight}, cell));
                elCellsFragment.appendChild(elCell.node)
            }
        }
    }
    this.elForeground.appendChild(elGridLinesFragment);
    this.elCells.appendChild(elCellsFragment);
    this.renderLabels()
},renderLabels: function() {
    this.elLabel = V(this.model.labelMarkup);
    var cells = this.model.get("cells") || [];
    var labels = this.model.get("labels") || {};
    var rowLabels = labels.rows || [];
    var columnLabels = labels.columns || [];
    var size = this.model.get("size");
    var cellHeight = size.height / cells.length;
    var cellWidth = size.width / cells.length;
    this.elRowLabels.textContent = "";
    this.elColumnLabels.textContent = "";
    var elRowLabelsFragment = document.createDocumentFragment();
    for (var i = 0; i < rowLabels.length; i++) {
        var label = labels.rows[i];
        var elLabel = this.elLabel.clone();
        elLabel.text(label.text);
        elLabel.attr(_.extend({x: -(labels.padding || 5),y: i * cellHeight + cellHeight / 2,"text-anchor": "end","alignment-baseline": "middle","font-size": cellHeight,"data-row": i}, _.omit(label, "text")));
        elRowLabelsFragment.appendChild(elLabel.node)
    }
    this.elRowLabels.appendChild(elRowLabelsFragment);
    var elColumnLabelsFragment = document.createDocumentFragment();
    for (var j = 0; j < columnLabels.length; j++) {
        var label = labels.columns[j];
        var elLabel = this.elLabel.clone();
        elLabel.text(label.text);
        var x = j * cellWidth + cellWidth / 2;
        var y = -(labels.padding || 5);
        elLabel.attr(_.extend({x: x,y: y,"text-anchor": "start","alignment-baseline": "middle","font-size": cellWidth,"data-column": j}, _.omit(label, "text")));
        elLabel.rotate(-90, x, y);
        elColumnLabelsFragment.appendChild(elLabel.node)
    }
    this.elColumnLabels.appendChild(elColumnLabelsFragment)
}});
if (typeof exports === "object") {
    module.exports = joint.shapes.chart
}
var Handlebars = {};
(function(Handlebars, undefined) {
    Handlebars.VERSION = "1.0.0";
    Handlebars.COMPILER_REVISION = 4;
    Handlebars.REVISION_CHANGES = {1: "<= 1.0.rc.2",2: "== 1.0.0-rc.3",3: "== 1.0.0-rc.4",4: ">= 1.0.0"};
    Handlebars.helpers = {};
    Handlebars.partials = {};
    var toString = Object.prototype.toString, functionType = "[object Function]", objectType = "[object Object]";
    Handlebars.registerHelper = function(name, fn, inverse) {
        if (toString.call(name) === objectType) {
            if (inverse || fn) {
                throw new Handlebars.Exception("Arg not supported with multiple helpers")
            }
            Handlebars.Utils.extend(this.helpers, name)
        } else {
            if (inverse) {
                fn.not = inverse
            }
            this.helpers[name] = fn
        }
    };
    Handlebars.registerPartial = function(name, str) {
        if (toString.call(name) === objectType) {
            Handlebars.Utils.extend(this.partials, name)
        } else {
            this.partials[name] = str
        }
    };
    Handlebars.registerHelper("helperMissing", function(arg) {
        if (arguments.length === 2) {
            return undefined
        } else {
            throw new Error("Missing helper: '" + arg + "'")
        }
    });
    Handlebars.registerHelper("blockHelperMissing", function(context, options) {
        var inverse = options.inverse || function() {
            }, fn = options.fn;
        var type = toString.call(context);
        if (type === functionType) {
            context = context.call(this)
        }
        if (context === true) {
            return fn(this)
        } else if (context === false || context == null) {
            return inverse(this)
        } else if (type === "[object Array]") {
            if (context.length > 0) {
                return Handlebars.helpers.each(context, options)
            } else {
                return inverse(this)
            }
        } else {
            return fn(context)
        }
    });
    Handlebars.K = function() {
    };
    Handlebars.createFrame = Object.create || function(object) {
            Handlebars.K.prototype = object;
            var obj = new Handlebars.K;
            Handlebars.K.prototype = null;
            return obj
        };
    Handlebars.logger = {DEBUG: 0,INFO: 1,WARN: 2,ERROR: 3,level: 3,methodMap: {0: "debug",1: "info",2: "warn",3: "error"},log: function(level, obj) {
        if (Handlebars.logger.level <= level) {
            var method = Handlebars.logger.methodMap[level];
            if (typeof console !== "undefined" && console[method]) {
                console[method].call(console, obj)
            }
        }
    }};
    Handlebars.log = function(level, obj) {
        Handlebars.logger.log(level, obj)
    };
    Handlebars.registerHelper("each", function(context, options) {
        var fn = options.fn, inverse = options.inverse;
        var i = 0, ret = "", data;
        var type = toString.call(context);
        if (type === functionType) {
            context = context.call(this)
        }
        if (options.data) {
            data = Handlebars.createFrame(options.data)
        }
        if (context && typeof context === "object") {
            if (context instanceof Array) {
                for (var j = context.length; i < j; i++) {
                    if (data) {
                        data.index = i
                    }
                    ret = ret + fn(context[i], {data: data})
                }
            } else {
                for (var key in context) {
                    if (context.hasOwnProperty(key)) {
                        if (data) {
                            data.key = key
                        }
                        ret = ret + fn(context[key], {data: data});
                        i++
                    }
                }
            }
        }
        if (i === 0) {
            ret = inverse(this)
        }
        return ret
    });
    Handlebars.registerHelper("if", function(conditional, options) {
        var type = toString.call(conditional);
        if (type === functionType) {
            conditional = conditional.call(this)
        }
        if (!conditional || Handlebars.Utils.isEmpty(conditional)) {
            return options.inverse(this)
        } else {
            return options.fn(this)
        }
    });
    Handlebars.registerHelper("unless", function(conditional, options) {
        return Handlebars.helpers["if"].call(this, conditional, {fn: options.inverse,inverse: options.fn})
    });
    Handlebars.registerHelper("with", function(context, options) {
        var type = toString.call(context);
        if (type === functionType) {
            context = context.call(this)
        }
        if (!Handlebars.Utils.isEmpty(context))
            return options.fn(context)
    });
    Handlebars.registerHelper("log", function(context, options) {
        var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
        Handlebars.log(level, context)
    });
    var errorProps = ["description", "fileName", "lineNumber", "message", "name", "number", "stack"];
    Handlebars.Exception = function(message) {
        var tmp = Error.prototype.constructor.apply(this, arguments);
        for (var idx = 0; idx < errorProps.length; idx++) {
            this[errorProps[idx]] = tmp[errorProps[idx]]
        }
    };
    Handlebars.Exception.prototype = new Error;
    Handlebars.SafeString = function(string) {
        this.string = string
    };
    Handlebars.SafeString.prototype.toString = function() {
        return this.string.toString()
    };
    var escape = {"&": "&amp;","<": "&lt;",">": "&gt;",'"': "&quot;","'": "&#x27;","`": "&#x60;"};
    var badChars = /[&<>"'`]/g;
    var possible = /[&<>"'`]/;
    var escapeChar = function(chr) {
        return escape[chr] || "&amp;"
    };
    Handlebars.Utils = {extend: function(obj, value) {
        for (var key in value) {
            if (value.hasOwnProperty(key)) {
                obj[key] = value[key]
            }
        }
    },escapeExpression: function(string) {
        if (string instanceof Handlebars.SafeString) {
            return string.toString()
        } else if (string == null || string === false) {
            return ""
        }
        string = string.toString();
        if (!possible.test(string)) {
            return string
        }
        return string.replace(badChars, escapeChar)
    },isEmpty: function(value) {
        if (!value && value !== 0) {
            return true
        } else if (toString.call(value) === "[object Array]" && value.length === 0) {
            return true
        } else {
            return false
        }
    }};
    Handlebars.VM = {template: function(templateSpec) {
        var container = {escapeExpression: Handlebars.Utils.escapeExpression,invokePartial: Handlebars.VM.invokePartial,programs: [],program: function(i, fn, data) {
            var programWrapper = this.programs[i];
            if (data) {
                programWrapper = Handlebars.VM.program(i, fn, data)
            } else if (!programWrapper) {
                programWrapper = this.programs[i] = Handlebars.VM.program(i, fn)
            }
            return programWrapper
        },merge: function(param, common) {
            var ret = param || common;
            if (param && common) {
                ret = {};
                Handlebars.Utils.extend(ret, common);
                Handlebars.Utils.extend(ret, param)
            }
            return ret
        },programWithDepth: Handlebars.VM.programWithDepth,noop: Handlebars.VM.noop,compilerInfo: null};
        return function(context, options) {
            options = options || {};
            var result = templateSpec.call(container, Handlebars, context, options.helpers, options.partials, options.data);
            var compilerInfo = container.compilerInfo || [], compilerRevision = compilerInfo[0] || 1, currentRevision = Handlebars.COMPILER_REVISION;
            if (compilerRevision !== currentRevision) {
                if (compilerRevision < currentRevision) {
                    var runtimeVersions = Handlebars.REVISION_CHANGES[currentRevision], compilerVersions = Handlebars.REVISION_CHANGES[compilerRevision];
                    throw "Template was precompiled with an older version of Handlebars than the current runtime. " + "Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ")."
                } else {
                    throw "Template was precompiled with a newer version of Handlebars than the current runtime. " + "Please update your runtime to a newer version (" + compilerInfo[1] + ")."
                }
            }
            return result
        }
    },programWithDepth: function(i, fn, data) {
        var args = Array.prototype.slice.call(arguments, 3);
        var program = function(context, options) {
            options = options || {};
            return fn.apply(this, [context, options.data || data].concat(args))
        };
        program.program = i;
        program.depth = args.length;
        return program
    },program: function(i, fn, data) {
        var program = function(context, options) {
            options = options || {};
            return fn(context, options.data || data)
        };
        program.program = i;
        program.depth = 0;
        return program
    },noop: function() {
        return ""
    },invokePartial: function(partial, name, context, helpers, partials, data) {
        var options = {helpers: helpers,partials: partials,data: data};
        if (partial === undefined) {
            throw new Handlebars.Exception("The partial " + name + " could not be found")
        } else if (partial instanceof Function) {
            return partial(context, options)
        } else if (!Handlebars.compile) {
            throw new Handlebars.Exception("The partial " + name + " could not be compiled when running in runtime-only mode")
        } else {
            partials[name] = Handlebars.compile(partial, {data: data !== undefined});
            return partials[name](context, options)
        }
    }};
    Handlebars.template = Handlebars.VM.template
})(Handlebars);
this["joint"] = this["joint"] || {};
this["joint"]["templates"] = this["joint"]["templates"] || {};
this["joint"]["templates"]["halo"] = this["joint"]["templates"]["halo"] || {};
this["joint"]["templates"]["halo"]["box.html"] = Handlebars.template(function(Handlebars, depth0, helpers, partials, data) {
    this.compilerInfo = [4, ">= 1.0.0"];
    helpers = this.merge(helpers, Handlebars.helpers);
    data = data || {};
    return '<label class="box"></label>\n'
});
this["joint"]["templates"]["halo"]["handle.html"] = Handlebars.template(function(Handlebars, depth0, helpers, partials, data) {
    this.compilerInfo = [4, ">= 1.0.0"];
    helpers = this.merge(helpers, Handlebars.helpers);
    data = data || {};
    var buffer = "", stack1, options, functionType = "function", escapeExpression = this.escapeExpression, self = this, blockHelperMissing = helpers.blockHelperMissing;
    function program1(depth0, data) {
        var buffer = "";
        buffer += 'style="background-image: url(' + escapeExpression(typeof depth0 === functionType ? depth0.apply(depth0) : depth0) + ')"';
        return buffer
    }
    buffer += '<div class="handle ';
    if (stack1 = helpers.position) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.position;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + " ";
    if (stack1 = helpers.name) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.name;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '" draggable="false" data-action="';
    if (stack1 = helpers.name) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.name;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '" ';
    options = {hash: {},inverse: self.noop,fn: self.program(1, program1, data),data: data};
    if (stack1 = helpers.icon) {
        stack1 = stack1.call(depth0, options)
    } else {
        stack1 = depth0.icon;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    if (!helpers.icon) {
        stack1 = blockHelperMissing.call(depth0, stack1, options)
    }
    if (stack1 || stack1 === 0) {
        buffer += stack1
    }
    buffer += ">\n    ";
    if (stack1 = helpers.content) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.content;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    if (stack1 || stack1 === 0) {
        buffer += stack1
    }
    buffer += "\n</div>\n\n";
    return buffer
});


joint.ui.Halo = Backbone.View.extend({
    className: "halo",
    events: {
        "mousedown .handle": "onHandlePointerDown",
        "touchstart .handle": "onHandlePointerDown"
    },
    options: {tinyTreshold: 40,smallTreshold: 80,loopLinkPreferredSide: "top",loopLinkWidth: 40,rotateAngleGrid: 15,useModelGeometry: false,boxContent: function(cellView, boxElement) {
    var tmpl = _.template("x: <%= x %>, y: <%= y %>, width: <%= width %>, height: <%= height %>, angle: <%= angle %>");
    var bbox = cellView.model.getBBox();
    return tmpl({x: Math.floor(bbox.x),y: Math.floor(bbox.y),width: bbox.width,height: bbox.height,angle: Math.floor(cellView.model.get("angle") || 0)})
},linkAttributes: {},smoothLinks: undefined,handles: [{name: "resize",position: "se",events: {pointerdown: "startResizing",pointermove: "doResize",pointerup: "stopBatch"}}, {name: "remove",position: "nw",events: {pointerdown: "removeElement"}}, {name: "clone",position: "n",events: {pointerdown: "startCloning",pointermove: "doClone",pointerup: "stopCloning"}}, {name: "link",position: "e",events: {pointerdown: "startLinking",pointermove: "doLink",pointerup: "stopLinking"}}, {name: "fork",position: "ne",events: {pointerdown: "startForking",pointermove: "doFork",pointerup: "stopForking"}}, {name: "unlink",position: "w",events: {pointerdown: "unlinkElement"}}, {name: "rotate",position: "sw",events: {pointerdown: "startRotating",pointermove: "doRotate",pointerup: "stopBatch"}}]},
    initialize: function(options) {
    this.options = _.extend({}, _.result(this, "options"), options || {});
    _.defaults(this.options, {paper: this.options.cellView.paper,graph: this.options.cellView.paper.model});
    _.bindAll(this, "pointermove", "pointerup", "render", "update", "remove");
    joint.ui.Halo.clear(this.options.paper);
    this.handles = [];
    _.each(this.options.handles, this.addHandle, this);
    this.listenTo(this.options.graph, "reset", this.remove);
    this.listenTo(this.options.graph, "all", this.update);
    this.listenTo(this.options.paper, "blank:pointerdown halo:create", this.remove);
    this.listenTo(this.options.paper, "scale translate", this.update);
    $(document.body).on("mousemove touchmove", this.pointermove);
    $(document).on("mouseup touchend", this.pointerup);
    this.options.paper.$el.append(this.$el)
},
    render: function() {
    this.options.cellView.model.on("remove", this.remove);
    this.$el.append(joint.templates.halo["box.html"]());
    this.renderMagnets();
    this.update();
    this.$el.addClass("animate");
    this.$el.attr("data-type", this.options.cellView.model.get("type"));
    this.toggleFork();
    return this
},
    update: function() {
    if (this.options.cellView.model instanceof joint.dia.Link)
        return;
    if (_.isFunction(this.options.boxContent)) {
        var $box = this.$(".box");
        var content = this.options.boxContent.call(this, this.options.cellView, $box[0]);
        if (content) {
            $box.html(content)
        }
    }
    var bbox = this.options.cellView.getBBox({useModelGeometry: this.options.useModelGeometry});
    this.$el.toggleClass("tiny", bbox.width < this.options.tinyTreshold && bbox.height < this.options.tinyTreshold);
    this.$el.toggleClass("small", !this.$el.hasClass("tiny") && (bbox.width < this.options.smallTreshold && bbox.height < this.options.smallTreshold));
    this.$el.css({width: bbox.width,height: bbox.height,left: bbox.x,top: bbox.y}).show();
    this.updateMagnets();
    this.toggleUnlink()
},
    addHandle: function(opt) {
    this.handles.push(opt);
    this.$el.append(joint.templates.halo["handle.html"](opt));
    _.each(opt.events, function(method, event) {
        if (_.isString(method)) {
            this.on("action:" + opt.name + ":" + event, this[method], this)
        } else {
            this.on("action:" + opt.name + ":" + event, method)
        }
    }, this);
    return this
},
    removeHandle: function(name) {
    var handleIdx = _.findIndex(this.handles, {name: name});
    var handle = this.handles[handleIdx];
    if (handle) {
        _.each(handle.events, function(method, event) {
            this.off("action:" + name + ":" + event)
        }, this);
        this.$(".handle." + name).remove();
        this.handles.splice(handleIdx, 1)
    }
    return this
},
    changeHandle: function(name, opt) {
    var handle = _.findWhere(this.handles, {name: name});
    if (handle) {
        this.removeHandle(name);
        this.addHandle(_.merge({name: name}, handle, opt))
    }
    return this
},
    onHandlePointerDown: function(evt) {
    this._action = $(evt.target).closest(".handle").attr("data-action");
    if (this._action) {
        evt.preventDefault();
        evt.stopPropagation();
        evt = joint.util.normalizeEvent(evt);
        this._clientX = evt.clientX;
        this._clientY = evt.clientY;
        this._startClientX = this._clientX;
        this._startClientY = this._clientY;
        this.triggerAction(this._action, "pointerdown", evt)
    }
},
    triggerAction: function(action, eventName, evt) {
    var args = ["action:" + action + ":" + eventName].concat(_.rest(_.toArray(arguments), 2));
    this.trigger.apply(this, args)
},
    startCloning: function(evt) {
    this.options.graph.trigger("batch:start");
    var clone = this.options.cellView.model.clone();
    clone.unset("z");
    this.options.graph.addCell(clone, {halo: this.cid});
    this._cloneView = clone.findView(this.options.paper);
    this._cloneView.pointerdown(evt, this._clientX, this._clientY)
},
    startLinking: function(evt) {
    this.options.graph.trigger("batch:start");
    var cellView = this.options.cellView;
    var selector = $.data(evt.target, "selector");
    var link = this.options.paper.getDefaultLink(cellView, selector && cellView.el.querySelector(selector));
    link.set("source", {id: cellView.model.id,selector: selector});
    link.set("target", {x: evt.clientX,y: evt.clientY});
    link.attr(this.options.linkAttributes);
    if (_.isBoolean(this.options.smoothLinks)) {
        link.set("smooth", this.options.smoothLinks)
    }
    this.options.graph.addCell(link, {validation: false,halo: this.cid});
    link.set("target", this.options.paper.snapToGrid({x: evt.clientX,y: evt.clientY}));
    this._linkView = this.options.paper.findViewByModel(link);
    this._linkView.startArrowheadMove("target")
},
    startForking: function(evt) {
    this.options.graph.trigger("batch:start");
    var clone = this.options.cellView.model.clone();
    clone.unset("z");
    this.options.graph.addCell(clone, {halo: this.cid});
    var link = this.options.paper.getDefaultLink(this.options.cellView);
    link.set("source", {id: this.options.cellView.model.id});
    link.set("target", {id: clone.id});
    link.attr(this.options.linkAttributes);
    if (_.isBoolean(this.options.smoothLinks)) {
        link.set("smooth", this.options.smoothLinks)
    }
    this.options.graph.addCell(link, {halo: this.cid});
    this._cloneView = clone.findView(this.options.paper);
    this._cloneView.pointerdown(evt, this._clientX, this._clientY)
},
    startResizing: function(evt) {
    this.options.graph.trigger("batch:start");
    this._flip = [1, 0, 0, 1, 1, 0, 0, 1][Math.floor(g.normalizeAngle(this.options.cellView.model.get("angle")) / 45)]
},
    startRotating: function(evt) {
    this.options.graph.trigger("batch:start");
    var bbox = this.options.cellView.getBBox();
    this._center = g.rect(bbox).center();
    if (typeof evt.offsetX === "undefined" || typeof evt.offsetY === "undefined") {
        var targetOffset = $(evt.target).offset();
        evt.offsetX = evt.pageX - targetOffset.left;
        evt.offsetY = evt.pageY - targetOffset.top
    }
    this._rotationStart = g.point(evt.offsetX + evt.target.parentNode.offsetLeft, evt.offsetY + evt.target.parentNode.offsetTop + evt.target.parentNode.offsetHeight);
    var angle = this.options.cellView.model.get("angle");
    this._rotationStartAngle = angle || 0
},
    doResize: function(evt, dx, dy) {
    var size = this.options.cellView.model.get("size");
    var width = Math.max(size.width + (this._flip ? dx : dy), 1);
    var height = Math.max(size.height + (this._flip ? dy : dx), 1);
    this.options.cellView.model.resize(width, height, {absolute: true})
},
    doRotate: function(evt, dx, dy, tx, ty) {
    var p = g.point(this._rotationStart).offset(tx, ty);
    var a = p.distance(this._center);
    var b = this._center.distance(this._rotationStart);
    var c = this._rotationStart.distance(p);
    var sign = (this._center.x - this._rotationStart.x) * (p.y - this._rotationStart.y) - (this._center.y - this._rotationStart.y) * (p.x - this._rotationStart.x);
    var _angle = Math.acos((a * a + b * b - c * c) / (2 * a * b));
    if (sign <= 0) {
        _angle = -_angle
    }
    var angleDiff = -g.toDeg(_angle);
    angleDiff = g.snapToGrid(angleDiff, this.options.rotateAngleGrid);
    this.options.cellView.model.rotate(angleDiff + this._rotationStartAngle, true)
},
    doClone: function(evt) {
    this._cloneView.pointermove(evt, this._clientX, this._clientY)
},
    doFork: function(evt) {
    this._cloneView.pointermove(evt, this._clientX, this._clientY)
},
    doLink: function(evt) {
    var clientCoords = this.options.paper.snapToGrid({x: evt.clientX,y: evt.clientY});
    this._linkView.pointermove(evt, clientCoords.x, clientCoords.y)
},
    stopLinking: function(evt) {
    this._linkView.pointerup(evt);
    var sourceId = this._linkView.model.get("source").id;
    var targetId = this._linkView.model.get("target").id;
    if (sourceId && targetId && sourceId === targetId) {
        this.makeLoopLink(this._linkView.model)
    }
    this.stopBatch();
    this.triggerAction("link", "add", this._linkView.model);
    delete this._linkView
},
    stopForking: function(evt) {
    this._cloneView.pointerup(evt, this._clientX, this._clientY);
    this.stopBatch()
},
    stopCloning: function(evt) {
    this._cloneView.pointerup(evt, this._clientX, this._clientY);
    this.stopBatch()
},
    pointermove: function(evt) {
    if (!this._action)
        return;
    evt.preventDefault();
    evt.stopPropagation();
    evt = joint.util.normalizeEvent(evt);
    var clientCoords = this.options.paper.snapToGrid({x: evt.clientX,y: evt.clientY});
    var oldClientCoords = this.options.paper.snapToGrid({x: this._clientX,y: this._clientY});
    var dx = clientCoords.x - oldClientCoords.x;
    var dy = clientCoords.y - oldClientCoords.y;
    this.triggerAction(this._action, "pointermove", evt, dx, dy, evt.clientX - this._startClientX, evt.clientY - this._startClientY);
    this._clientX = evt.clientX;
    this._clientY = evt.clientY
},
    pointerup: function(evt) {
    if (!this._action)
        return;
    this.triggerAction(this._action, "pointerup", evt);
    delete this._action
},
    stopBatch: function() {
    this.options.graph.trigger("batch:stop")
},
    remove: function(evt) {
    Backbone.View.prototype.remove.apply(this, arguments);
    $(document.body).off("mousemove touchmove", this.pointermove);
    $(document).off("mouseup touchend", this.pointerup)
},
    removeElement: function(evt) {
    this.options.cellView.model.remove()
},
    unlinkElement: function(evt) {
    this.options.graph.removeLinks(this.options.cellView.model)
},
    toggleUnlink: function() {
    if (this.options.graph.getConnectedLinks(this.options.cellView.model).length > 0) {
        this.$(".unlink").show()
    } else {
        this.$(".unlink").hide()
    }
},
    toggleFork: function() {
    var clone = this.options.cellView.model.clone();
    var cloneView = this.options.paper.createViewForModel(clone);
    if (!this.options.paper.options.validateConnection(this.options.cellView, null, cloneView, null, "target")) {
        this.$(".fork").hide()
    }
    cloneView.remove();
    clone = null
},
    makeLoopLink: function(link) {
    var linkWidth = this.options.loopLinkWidth;
    var paperOpt = this.options.paper.options;
    var paperRect = g.rect({x: 0,y: 0,width: paperOpt.width,height: paperOpt.height});
    var bbox = V(this.options.cellView.el).bbox(false, this.options.paper.viewport);
    var p1, p2;
    var sides = _.uniq([this.options.loopLinkPreferredSide, "top", "bottom", "left", "right"]);
    var sideFound = _.find(sides, function(side) {
        var centre, dx = 0, dy = 0;
        switch (side) {
            case "top":
                centre = g.point(bbox.x + bbox.width / 2, bbox.y - linkWidth);
                dx = linkWidth / 2;
                break;
            case "bottom":
                centre = g.point(bbox.x + bbox.width / 2, bbox.y + bbox.height + linkWidth);
                dx = linkWidth / 2;
                break;
            case "left":
                centre = g.point(bbox.x - linkWidth, bbox.y + bbox.height / 2);
                dy = linkWidth / 2;
                break;
            case "right":
                centre = g.point(bbox.x + bbox.width + linkWidth, bbox.y + bbox.height / 2);
                dy = linkWidth / 2;
                break
        }
        p1 = g.point(centre).offset(-dx, -dy);
        p2 = g.point(centre).offset(dx, dy);
        return paperRect.containsPoint(p1) && paperRect.containsPoint(p2)
    }, this);
    if (sideFound)
        link.set("vertices", [p1, p2])
},
    renderMagnets: function() {
    this._magnets = [];
    var $link = this.$(".link");
    var magnetElements = this.options.cellView.$('[magnet="true"]');
    if (this.options.magnetFilter) {
        if (_.isFunction(this.options.magnetFilter)) {
            magnetElements = _.filter(magnetElements, this.options.magnetFilter)
        } else {
            magnetElements = magnetElements.filter(this.options.magnetFilter)
        }
    }
    if ($link.length && magnetElements.length) {
        var linkWidth = $link.width();
        var linkHeight = $link.height();
        _.each(magnetElements, function(magnetElement) {
            var magnetClientRect = magnetElement.getBoundingClientRect();
            var $haloElement = $link.clone().addClass("halo-magnet").css({width: Math.min(magnetClientRect.width, linkWidth),height: Math.min(magnetClientRect.height, linkHeight),"background-size": "contain"}).data("selector", this.options.cellView.getSelector(magnetElement)).appendTo(this.$el);
            this._magnets.push({$halo: $haloElement,el: magnetElement})
        }, this)
    }
    if (this.options.cellView.$el.attr("magnet") == "false") {
        $link.hide();
        this.$(".fork").hide()
    }
},
    updateMagnets: function() {
    if (this._magnets.length) {
        var hClientRect = this.el.getBoundingClientRect();
        _.each(this._magnets, function(magnet) {
            var mClientRect = magnet.el.getBoundingClientRect();
            magnet.$halo.css({left: mClientRect.left - hClientRect.left + (mClientRect.width - magnet.$halo.width()) / 2,top: mClientRect.top - hClientRect.top + (mClientRect.height - magnet.$halo.height()) / 2})
        }, this)
    }
}
}, {
    clear: function(paper) {
    paper.trigger("halo:create")
}
});


(function() {
    var _resize = joint.dia.Element.prototype.resize;
    joint.dia.Element.prototype.resize = resize;
    function resize(width, height, opt) {
        if (_.isUndefined(opt)) {
            return _resize.call(this, width, height)
        }
        opt.direction = opt.direction || "bottom-right";
        var angle = g.normalizeAngle(this.get("angle") || 0);
        var quadrant = {"top-right": 0,"top-left": 1,"bottom-left": 2,"bottom-right": 3}[opt.direction];
        if (opt.absolute) {
            quadrant += Math.floor((angle + 45) / 90);
            quadrant %= 4
        }
        var bbox = this.getBBox();
        var indentFixedPoint = bbox[["bottomLeft", "corner", "topRight", "origin"][quadrant]]();
        var imageFixedPoint = g.point(indentFixedPoint).rotate(bbox.center(), -angle);
        var radius = Math.sqrt(width * width + height * height) / 2;
        var alpha = quadrant * Math.PI / 2;
        alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height);
        alpha -= g.toRad(angle);
        var center = g.point.fromPolar(radius, alpha, imageFixedPoint);
        var origin = g.point(center).offset(width / -2, height / -2);
        this.resize(width, height).position(origin.x, origin.y);
        return this
    }
})();
var Handlebars = {};
(function(Handlebars, undefined) {
    Handlebars.VERSION = "1.0.0";
    Handlebars.COMPILER_REVISION = 4;
    Handlebars.REVISION_CHANGES = {1: "<= 1.0.rc.2",2: "== 1.0.0-rc.3",3: "== 1.0.0-rc.4",4: ">= 1.0.0"};
    Handlebars.helpers = {};
    Handlebars.partials = {};
    var toString = Object.prototype.toString, functionType = "[object Function]", objectType = "[object Object]";
    Handlebars.registerHelper = function(name, fn, inverse) {
        if (toString.call(name) === objectType) {
            if (inverse || fn) {
                throw new Handlebars.Exception("Arg not supported with multiple helpers")
            }
            Handlebars.Utils.extend(this.helpers, name)
        } else {
            if (inverse) {
                fn.not = inverse
            }
            this.helpers[name] = fn
        }
    };
    Handlebars.registerPartial = function(name, str) {
        if (toString.call(name) === objectType) {
            Handlebars.Utils.extend(this.partials, name)
        } else {
            this.partials[name] = str
        }
    };
    Handlebars.registerHelper("helperMissing", function(arg) {
        if (arguments.length === 2) {
            return undefined
        } else {
            throw new Error("Missing helper: '" + arg + "'")
        }
    });
    Handlebars.registerHelper("blockHelperMissing", function(context, options) {
        var inverse = options.inverse || function() {
            }, fn = options.fn;
        var type = toString.call(context);
        if (type === functionType) {
            context = context.call(this)
        }
        if (context === true) {
            return fn(this)
        } else if (context === false || context == null) {
            return inverse(this)
        } else if (type === "[object Array]") {
            if (context.length > 0) {
                return Handlebars.helpers.each(context, options)
            } else {
                return inverse(this)
            }
        } else {
            return fn(context)
        }
    });
    Handlebars.K = function() {
    };
    Handlebars.createFrame = Object.create || function(object) {
            Handlebars.K.prototype = object;
            var obj = new Handlebars.K;
            Handlebars.K.prototype = null;
            return obj
        };
    Handlebars.logger = {DEBUG: 0,INFO: 1,WARN: 2,ERROR: 3,level: 3,methodMap: {0: "debug",1: "info",2: "warn",3: "error"},log: function(level, obj) {
        if (Handlebars.logger.level <= level) {
            var method = Handlebars.logger.methodMap[level];
            if (typeof console !== "undefined" && console[method]) {
                console[method].call(console, obj)
            }
        }
    }};
    Handlebars.log = function(level, obj) {
        Handlebars.logger.log(level, obj)
    };
    Handlebars.registerHelper("each", function(context, options) {
        var fn = options.fn, inverse = options.inverse;
        var i = 0, ret = "", data;
        var type = toString.call(context);
        if (type === functionType) {
            context = context.call(this)
        }
        if (options.data) {
            data = Handlebars.createFrame(options.data)
        }
        if (context && typeof context === "object") {
            if (context instanceof Array) {
                for (var j = context.length; i < j; i++) {
                    if (data) {
                        data.index = i
                    }
                    ret = ret + fn(context[i], {data: data})
                }
            } else {
                for (var key in context) {
                    if (context.hasOwnProperty(key)) {
                        if (data) {
                            data.key = key
                        }
                        ret = ret + fn(context[key], {data: data});
                        i++
                    }
                }
            }
        }
        if (i === 0) {
            ret = inverse(this)
        }
        return ret
    });
    Handlebars.registerHelper("if", function(conditional, options) {
        var type = toString.call(conditional);
        if (type === functionType) {
            conditional = conditional.call(this)
        }
        if (!conditional || Handlebars.Utils.isEmpty(conditional)) {
            return options.inverse(this)
        } else {
            return options.fn(this)
        }
    });
    Handlebars.registerHelper("unless", function(conditional, options) {
        return Handlebars.helpers["if"].call(this, conditional, {fn: options.inverse,inverse: options.fn})
    });
    Handlebars.registerHelper("with", function(context, options) {
        var type = toString.call(context);
        if (type === functionType) {
            context = context.call(this)
        }
        if (!Handlebars.Utils.isEmpty(context))
            return options.fn(context)
    });
    Handlebars.registerHelper("log", function(context, options) {
        var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
        Handlebars.log(level, context)
    });
    var errorProps = ["description", "fileName", "lineNumber", "message", "name", "number", "stack"];
    Handlebars.Exception = function(message) {
        var tmp = Error.prototype.constructor.apply(this, arguments);
        for (var idx = 0; idx < errorProps.length; idx++) {
            this[errorProps[idx]] = tmp[errorProps[idx]]
        }
    };
    Handlebars.Exception.prototype = new Error;
    Handlebars.SafeString = function(string) {
        this.string = string
    };
    Handlebars.SafeString.prototype.toString = function() {
        return this.string.toString()
    };
    var escape = {"&": "&amp;","<": "&lt;",">": "&gt;",'"': "&quot;","'": "&#x27;","`": "&#x60;"};
    var badChars = /[&<>"'`]/g;
    var possible = /[&<>"'`]/;
    var escapeChar = function(chr) {
        return escape[chr] || "&amp;"
    };
    Handlebars.Utils = {extend: function(obj, value) {
        for (var key in value) {
            if (value.hasOwnProperty(key)) {
                obj[key] = value[key]
            }
        }
    },escapeExpression: function(string) {
        if (string instanceof Handlebars.SafeString) {
            return string.toString()
        } else if (string == null || string === false) {
            return ""
        }
        string = string.toString();
        if (!possible.test(string)) {
            return string
        }
        return string.replace(badChars, escapeChar)
    },isEmpty: function(value) {
        if (!value && value !== 0) {
            return true
        } else if (toString.call(value) === "[object Array]" && value.length === 0) {
            return true
        } else {
            return false
        }
    }};
    Handlebars.VM = {template: function(templateSpec) {
        var container = {escapeExpression: Handlebars.Utils.escapeExpression,invokePartial: Handlebars.VM.invokePartial,programs: [],program: function(i, fn, data) {
            var programWrapper = this.programs[i];
            if (data) {
                programWrapper = Handlebars.VM.program(i, fn, data)
            } else if (!programWrapper) {
                programWrapper = this.programs[i] = Handlebars.VM.program(i, fn)
            }
            return programWrapper
        },merge: function(param, common) {
            var ret = param || common;
            if (param && common) {
                ret = {};
                Handlebars.Utils.extend(ret, common);
                Handlebars.Utils.extend(ret, param)
            }
            return ret
        },programWithDepth: Handlebars.VM.programWithDepth,noop: Handlebars.VM.noop,compilerInfo: null};
        return function(context, options) {
            options = options || {};
            var result = templateSpec.call(container, Handlebars, context, options.helpers, options.partials, options.data);
            var compilerInfo = container.compilerInfo || [], compilerRevision = compilerInfo[0] || 1, currentRevision = Handlebars.COMPILER_REVISION;
            if (compilerRevision !== currentRevision) {
                if (compilerRevision < currentRevision) {
                    var runtimeVersions = Handlebars.REVISION_CHANGES[currentRevision], compilerVersions = Handlebars.REVISION_CHANGES[compilerRevision];
                    throw "Template was precompiled with an older version of Handlebars than the current runtime. " + "Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ")."
                } else {
                    throw "Template was precompiled with a newer version of Handlebars than the current runtime. " + "Please update your runtime to a newer version (" + compilerInfo[1] + ")."
                }
            }
            return result
        }
    },programWithDepth: function(i, fn, data) {
        var args = Array.prototype.slice.call(arguments, 3);
        var program = function(context, options) {
            options = options || {};
            return fn.apply(this, [context, options.data || data].concat(args))
        };
        program.program = i;
        program.depth = args.length;
        return program
    },program: function(i, fn, data) {
        var program = function(context, options) {
            options = options || {};
            return fn(context, options.data || data)
        };
        program.program = i;
        program.depth = 0;
        return program
    },noop: function() {
        return ""
    },invokePartial: function(partial, name, context, helpers, partials, data) {
        var options = {helpers: helpers,partials: partials,data: data};
        if (partial === undefined) {
            throw new Handlebars.Exception("The partial " + name + " could not be found")
        } else if (partial instanceof Function) {
            return partial(context, options)
        } else if (!Handlebars.compile) {
            throw new Handlebars.Exception("The partial " + name + " could not be compiled when running in runtime-only mode")
        } else {
            partials[name] = Handlebars.compile(partial, {data: data !== undefined});
            return partials[name](context, options)
        }
    }};
    Handlebars.template = Handlebars.VM.template
})(Handlebars);
this["joint"] = this["joint"] || {};
this["joint"]["templates"] = this["joint"]["templates"] || {};
this["joint"]["templates"]["freetransform.html"] = Handlebars.template(function(Handlebars, depth0, helpers, partials, data) {
    this.compilerInfo = [4, ">= 1.0.0"];
    helpers = this.merge(helpers, Handlebars.helpers);
    data = data || {};
    return '<div class="resize" data-position="top-left" draggable="false"/>\n<div class="resize" data-position="top" draggable="false"/>\n<div class="resize" data-position="top-right" draggable="false"/>\n<div class="resize" data-position="right" draggable="false"/>\n<div class="resize" data-position="bottom-right" draggable="false"/>\n<div class="resize" data-position="bottom" draggable="false"/>\n<div class="resize" data-position="bottom-left" draggable="false"/>\n<div class="resize" data-position="left" draggable="false"/>\n<div class="rotate" draggable="false"/>\n\n'
});
joint.ui.FreeTransform = Backbone.View.extend({className: "free-transform",template: "freetransform",events: {"mousedown .resize": "startResizing","mousedown .rotate": "startRotating","touchstart .resize": "startResizing","touchstart .rotate": "startRotating"},options: {rotateAngleGrid: 15,preventAspectRatio: false,directions: ["nw", "n", "ne", "e", "se", "s", "sw", "w"]},initialize: function(options) {
    this.options = _.extend({}, _.result(this, "options"), options || {});
    if (this.options.cellView) {
        _.defaults(this.options, {cell: this.options.cellView.model,paper: this.options.cellView.paper,graph: this.options.cellView.paper.model})
    }
    _.bindAll(this, "update", "remove", "pointerup", "pointermove");
    joint.ui.FreeTransform.clear(this.options.paper);
    $(document.body).on("mousemove touchmove", this.pointermove);
    $(document).on("mouseup touchend", this.pointerup);
    this.listenTo(this.options.graph, "all", this.update);
    this.listenTo(this.options.graph, "reset", this.remove);
    this.listenTo(this.options.cell, "remove", this.remove);
    this.listenTo(this.options.paper, "blank:pointerdown freetransform:create", this.remove);
    this.listenTo(this.options.paper, "scale translate", this.update);
    this.options.paper.$el.append(this.el)
},render: function() {
    this.$el.html(joint.templates["freetransform.html"](this.template));
    this.$el.attr("data-type", this.options.cell.get("type"));
    this.$el.toggleClass("prevent-aspect-ratio", this.options.preventAspectRatio);
    this.update()
},update: function() {
    var viewportCTM = this.options.paper.viewport.getCTM();
    var bbox = this.options.cell.getBBox();
    bbox.x *= viewportCTM.a;
    bbox.x += viewportCTM.e;
    bbox.y *= viewportCTM.d;
    bbox.y += viewportCTM.f;
    bbox.width *= viewportCTM.a;
    bbox.height *= viewportCTM.d;
    var angle = g.normalizeAngle(this.options.cell.get("angle") || 0);
    var transformVal = "rotate(" + angle + "deg)";
    this.$el.css({width: bbox.width + 4,height: bbox.height + 4,left: bbox.x - 3,top: bbox.y - 3,transform: transformVal,"-webkit-transform": transformVal,"-ms-transform": transformVal});
    var shift = Math.floor(angle * (this.options.directions.length / 360));
    if (shift != this._previousDirectionsShift) {
        var directions = _.rest(this.options.directions, shift).concat(_.first(this.options.directions, shift));
        this.$(".resize").removeClass("nw n ne e se s sw w").each(function(index, el) {
            $(el).addClass(directions[index])
        });
        this._previousDirectionsShift = shift
    }
},startResizing: function(evt) {
    evt.stopPropagation();
    this.options.graph.trigger("batch:start");
    var direction = $(evt.target).data("position");
    var rx = 0, ry = 0;
    _.each(direction.split("-"), function(singleDirection) {
        rx = {left: -1,right: 1}[singleDirection] || rx;
        ry = {top: -1,bottom: 1}[singleDirection] || ry
    });
    direction = {top: "top-left",bottom: "bottom-right",left: "bottom-left",right: "top-right"}[direction] || direction;
    var selector = {"top-right": "bottomLeft","top-left": "corner","bottom-left": "topRight","bottom-right": "origin"}[direction];
    this._initial = {angle: g.normalizeAngle(this.options.cell.get("angle") || 0),resizeX: rx,resizeY: ry,selector: selector,direction: direction};
    this._action = "resize";
    this.startOp(evt.target)
},startRotating: function(evt) {
    evt.stopPropagation();
    this.options.graph.trigger("batch:start");
    var center = this.options.cell.getBBox().center();
    var clientCoords = this.options.paper.snapToGrid({x: evt.clientX,y: evt.clientY});
    this._initial = {centerRotation: center,modelAngle: g.normalizeAngle(this.options.cell.get("angle") || 0),startAngle: g.point(clientCoords).theta(center)};
    this._action = "rotate";
    this.startOp(evt.target)
},pointermove: function(evt) {
    if (!this._action)
        return;
    evt = joint.util.normalizeEvent(evt);
    var clientCoords = this.options.paper.snapToGrid({x: evt.clientX,y: evt.clientY});
    var gridSize = this.options.paper.options.gridSize;
    var model = this.options.cell, i = this._initial;
    switch (this._action) {
        case "resize":
            var currentRect = model.getBBox();
            var coimageCoords = g.point(clientCoords).rotate(currentRect.center(), i.angle);
            var requestedSize = coimageCoords.difference(currentRect[i.selector]());
            var width = i.resizeX ? requestedSize.x * i.resizeX : currentRect.width;
            var height = i.resizeY ? requestedSize.y * i.resizeY : currentRect.height;
            if (this.options.preventAspectRatio) {
                var candidateWidth = currentRect.width * height / currentRect.height;
                var candidateHeight = currentRect.height * width / currentRect.width;
                candidateWidth > width ? height = candidateHeight : width = candidateWidth
            }
            width = width < gridSize ? gridSize : g.snapToGrid(width, gridSize);
            height = height < gridSize ? gridSize : g.snapToGrid(height, gridSize);
            if (currentRect.width != width || currentRect.height != height) {
                model.resize(width, height, {direction: i.direction})
            }
            break;
        case "rotate":
            var theta = i.startAngle - g.point(clientCoords).theta(i.centerRotation);
            model.rotate(g.snapToGrid(i.modelAngle + theta, this.options.rotateAngleGrid), true);
            break
    }
},pointerup: function(evt) {
    if (!this._action)
        return;
    this.stopOp();
    this.options.graph.trigger("batch:stop");
    delete this._action;
    delete this._initial
},remove: function(evt) {
    Backbone.View.prototype.remove.apply(this, arguments);
    $("body").off("mousemove touchmove", this.pointermove);
    $(document).off("mouseup touchend", this.pointerup)
},startOp: function(el) {
    if (el) {
        $(el).addClass("in-operation");
        this._elementOp = el
    }
    this.$el.addClass("in-operation")
},stopOp: function() {
    if (this._elementOp) {
        $(this._elementOp).removeClass("in-operation");
        delete this._elementOp
    }
    this.$el.removeClass("in-operation")
}}, {clear: function(paper) {
    paper.trigger("freetransform:create")
}});
joint.ui.Navigator = Backbone.View.extend({className: "navigator",events: {"mousedown .paper": "scrollTo","touchstart .paper": "scrollTo",mousedown: "startAction",touchstart: "startAction"},options: {paperConstructor: joint.dia.Paper,paperOptions: {},zoomOptions: {min: .1,max: 10},width: 300,height: 200,padding: 10},initialize: function(options) {
    this.options = _.extend({}, _.result(this, "options"), options || {});
    _.bindAll(this, "updateCurrentView", "doAction", "stopAction");
    this.updateCurrentView = _.debounce(this.updateCurrentView, 0);
    var paperScroller = this.options.paperScroller;
    paperScroller.$el.on("scroll.navigator", this.updateCurrentView);
    var sourcePaper = this.sourcePaper = paperScroller.options.paper;
    this.listenTo(sourcePaper, "resize", this.updatePaper);
    var targetPaper = this.targetPaper = new this.options.paperConstructor(_.extend({model: sourcePaper.model,interactive: false}, this.options.paperOptions));
    $(document.body).on({"mousemove.navigator touchmove.navigator": this.doAction,"mouseup.navigator touchend.navigator": this.stopAction})
},render: function() {
    this.targetPaper.$el.appendTo(this.el);
    this.sourcePaper.model.get("cells").each(this.targetPaper.addCell, this.targetPaper);
    this.$currentViewControl = $("<div>").addClass("current-view-control");
    this.$currentView = $("<div>").addClass("current-view").append(this.$currentViewControl);
    this.$el.append(this.$currentView).css({width: this.options.width,height: this.options.height,padding: this.options.padding});
    this.updatePaper(this.sourcePaper.options.width, this.sourcePaper.options.height);
    return this
},updatePaper: function(width, height) {
    var sourceOrigin = this.sourcePaper.options.origin;
    var sourceScale = V(this.sourcePaper.viewport).scale();
    var navigatorWidth = this.options.width - 2 * this.options.padding;
    var navigatorHeight = this.options.height - 2 * this.options.padding;
    width /= sourceScale.sx;
    height /= sourceScale.sy;
    var ratio = this.ratio = Math.min(navigatorWidth / width, navigatorHeight / height);
    var ox = sourceOrigin.x * ratio / sourceScale.sx;
    var oy = sourceOrigin.y * ratio / sourceScale.sy;
    width *= ratio;
    height *= ratio;
    this.targetPaper.setDimensions(width, height);
    this.targetPaper.setOrigin(ox, oy);
    this.targetPaper.scale(ratio, ratio);
    this.updateCurrentView()
},updateCurrentView: function() {
    var ratio = this.ratio;
    var sourceScale = V(this.sourcePaper.viewport).scale();
    var paperScroller = this.options.paperScroller;
    var topLeftCoordinates = paperScroller.toLocalPoint(0, 0);
    var paperPosition = this.targetPaper.$el.position();
    var paperOrigin = V(this.targetPaper.viewport).translate();
    paperOrigin.ty = paperOrigin.ty || 0;
    this.currentViewGeometry = {top: paperPosition.top + topLeftCoordinates.y * ratio + paperOrigin.ty,left: paperPosition.left + topLeftCoordinates.x * ratio + paperOrigin.tx,width: paperScroller.$el.innerWidth() * ratio / sourceScale.sx,height: paperScroller.$el.innerHeight() * ratio / sourceScale.sy};
    this.$currentView.css(this.currentViewGeometry)
},startAction: function(evt) {
    evt = joint.util.normalizeEvent(evt);
    this._action = $(evt.target).hasClass("current-view-control") ? "zooming" : "panning";
    this._clientX = evt.clientX;
    this._clientY = evt.clientY
},doAction: function(evt) {
    if (!this._action)
        return;
    evt = joint.util.normalizeEvent(evt);
    var sourceScale = V(this.sourcePaper.viewport).scale();
    var dx = (evt.clientX - this._clientX) * sourceScale.sx;
    var dy = (evt.clientY - this._clientY) * sourceScale.sy;
    switch (this._action) {
        case "panning":
            this.options.paperScroller.el.scrollLeft += dx / this.ratio;
            this.options.paperScroller.el.scrollTop += dy / this.ratio;
            break;
        case "zooming":
            var levelDiff = -dx / this.currentViewGeometry.width;
            this.options.paperScroller.zoom(levelDiff, this.options.zoomOptions);
            break
    }
    this._clientX = evt.clientX;
    this._clientY = evt.clientY
},stopAction: function() {
    delete this._action
},scrollTo: function(evt) {
    evt = joint.util.normalizeEvent(evt);
    var paperOrigin = V(this.targetPaper.viewport).translate();
    paperOrigin.ty = paperOrigin.ty || 0;
    var offsetX, offsetY;
    if (_.isUndefined(evt.offsetX)) {
        var targetPaperOffset = this.targetPaper.$el.offset();
        offsetX = evt.pageX - targetPaperOffset.left;
        offsetY = evt.pageY - targetPaperOffset.top
    } else {
        offsetX = evt.offsetX;
        offsetY = evt.offsetY
    }
    var cx = (offsetX - paperOrigin.tx) / this.ratio;
    var cy = (offsetY - paperOrigin.ty) / this.ratio;
    this.options.paperScroller.center(cx, cy)
},remove: function() {
    this.targetPaper.remove();
    this.options.paperScroller.$el.off(".navigator");
    $(document.body).off(".navigator");
    Backbone.View.prototype.remove.apply(this, arguments)
}});
var Handlebars = {};
(function(Handlebars, undefined) {
    Handlebars.VERSION = "1.0.0";
    Handlebars.COMPILER_REVISION = 4;
    Handlebars.REVISION_CHANGES = {1: "<= 1.0.rc.2",2: "== 1.0.0-rc.3",3: "== 1.0.0-rc.4",4: ">= 1.0.0"};
    Handlebars.helpers = {};
    Handlebars.partials = {};
    var toString = Object.prototype.toString, functionType = "[object Function]", objectType = "[object Object]";
    Handlebars.registerHelper = function(name, fn, inverse) {
        if (toString.call(name) === objectType) {
            if (inverse || fn) {
                throw new Handlebars.Exception("Arg not supported with multiple helpers")
            }
            Handlebars.Utils.extend(this.helpers, name)
        } else {
            if (inverse) {
                fn.not = inverse
            }
            this.helpers[name] = fn
        }
    };
    Handlebars.registerPartial = function(name, str) {
        if (toString.call(name) === objectType) {
            Handlebars.Utils.extend(this.partials, name)
        } else {
            this.partials[name] = str
        }
    };
    Handlebars.registerHelper("helperMissing", function(arg) {
        if (arguments.length === 2) {
            return undefined
        } else {
            throw new Error("Missing helper: '" + arg + "'")
        }
    });
    Handlebars.registerHelper("blockHelperMissing", function(context, options) {
        var inverse = options.inverse || function() {
            }, fn = options.fn;
        var type = toString.call(context);
        if (type === functionType) {
            context = context.call(this)
        }
        if (context === true) {
            return fn(this)
        } else if (context === false || context == null) {
            return inverse(this)
        } else if (type === "[object Array]") {
            if (context.length > 0) {
                return Handlebars.helpers.each(context, options)
            } else {
                return inverse(this)
            }
        } else {
            return fn(context)
        }
    });
    Handlebars.K = function() {
    };
    Handlebars.createFrame = Object.create || function(object) {
            Handlebars.K.prototype = object;
            var obj = new Handlebars.K;
            Handlebars.K.prototype = null;
            return obj
        };
    Handlebars.logger = {DEBUG: 0,INFO: 1,WARN: 2,ERROR: 3,level: 3,methodMap: {0: "debug",1: "info",2: "warn",3: "error"},log: function(level, obj) {
        if (Handlebars.logger.level <= level) {
            var method = Handlebars.logger.methodMap[level];
            if (typeof console !== "undefined" && console[method]) {
                console[method].call(console, obj)
            }
        }
    }};
    Handlebars.log = function(level, obj) {
        Handlebars.logger.log(level, obj)
    };
    Handlebars.registerHelper("each", function(context, options) {
        var fn = options.fn, inverse = options.inverse;
        var i = 0, ret = "", data;
        var type = toString.call(context);
        if (type === functionType) {
            context = context.call(this)
        }
        if (options.data) {
            data = Handlebars.createFrame(options.data)
        }
        if (context && typeof context === "object") {
            if (context instanceof Array) {
                for (var j = context.length; i < j; i++) {
                    if (data) {
                        data.index = i
                    }
                    ret = ret + fn(context[i], {data: data})
                }
            } else {
                for (var key in context) {
                    if (context.hasOwnProperty(key)) {
                        if (data) {
                            data.key = key
                        }
                        ret = ret + fn(context[key], {data: data});
                        i++
                    }
                }
            }
        }
        if (i === 0) {
            ret = inverse(this)
        }
        return ret
    });
    Handlebars.registerHelper("if", function(conditional, options) {
        var type = toString.call(conditional);
        if (type === functionType) {
            conditional = conditional.call(this)
        }
        if (!conditional || Handlebars.Utils.isEmpty(conditional)) {
            return options.inverse(this)
        } else {
            return options.fn(this)
        }
    });
    Handlebars.registerHelper("unless", function(conditional, options) {
        return Handlebars.helpers["if"].call(this, conditional, {fn: options.inverse,inverse: options.fn})
    });
    Handlebars.registerHelper("with", function(context, options) {
        var type = toString.call(context);
        if (type === functionType) {
            context = context.call(this)
        }
        if (!Handlebars.Utils.isEmpty(context))
            return options.fn(context)
    });
    Handlebars.registerHelper("log", function(context, options) {
        var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
        Handlebars.log(level, context)
    });
    var errorProps = ["description", "fileName", "lineNumber", "message", "name", "number", "stack"];
    Handlebars.Exception = function(message) {
        var tmp = Error.prototype.constructor.apply(this, arguments);
        for (var idx = 0; idx < errorProps.length; idx++) {
            this[errorProps[idx]] = tmp[errorProps[idx]]
        }
    };
    Handlebars.Exception.prototype = new Error;
    Handlebars.SafeString = function(string) {
        this.string = string
    };
    Handlebars.SafeString.prototype.toString = function() {
        return this.string.toString()
    };
    var escape = {"&": "&amp;","<": "&lt;",">": "&gt;",'"': "&quot;","'": "&#x27;","`": "&#x60;"};
    var badChars = /[&<>"'`]/g;
    var possible = /[&<>"'`]/;
    var escapeChar = function(chr) {
        return escape[chr] || "&amp;"
    };
    Handlebars.Utils = {extend: function(obj, value) {
        for (var key in value) {
            if (value.hasOwnProperty(key)) {
                obj[key] = value[key]
            }
        }
    },escapeExpression: function(string) {
        if (string instanceof Handlebars.SafeString) {
            return string.toString()
        } else if (string == null || string === false) {
            return ""
        }
        string = string.toString();
        if (!possible.test(string)) {
            return string
        }
        return string.replace(badChars, escapeChar)
    },isEmpty: function(value) {
        if (!value && value !== 0) {
            return true
        } else if (toString.call(value) === "[object Array]" && value.length === 0) {
            return true
        } else {
            return false
        }
    }};
    Handlebars.VM = {template: function(templateSpec) {
        var container = {escapeExpression: Handlebars.Utils.escapeExpression,invokePartial: Handlebars.VM.invokePartial,programs: [],program: function(i, fn, data) {
            var programWrapper = this.programs[i];
            if (data) {
                programWrapper = Handlebars.VM.program(i, fn, data)
            } else if (!programWrapper) {
                programWrapper = this.programs[i] = Handlebars.VM.program(i, fn)
            }
            return programWrapper
        },merge: function(param, common) {
            var ret = param || common;
            if (param && common) {
                ret = {};
                Handlebars.Utils.extend(ret, common);
                Handlebars.Utils.extend(ret, param)
            }
            return ret
        },programWithDepth: Handlebars.VM.programWithDepth,noop: Handlebars.VM.noop,compilerInfo: null};
        return function(context, options) {
            options = options || {};
            var result = templateSpec.call(container, Handlebars, context, options.helpers, options.partials, options.data);
            var compilerInfo = container.compilerInfo || [], compilerRevision = compilerInfo[0] || 1, currentRevision = Handlebars.COMPILER_REVISION;
            if (compilerRevision !== currentRevision) {
                if (compilerRevision < currentRevision) {
                    var runtimeVersions = Handlebars.REVISION_CHANGES[currentRevision], compilerVersions = Handlebars.REVISION_CHANGES[compilerRevision];
                    throw "Template was precompiled with an older version of Handlebars than the current runtime. " + "Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ")."
                } else {
                    throw "Template was precompiled with a newer version of Handlebars than the current runtime. " + "Please update your runtime to a newer version (" + compilerInfo[1] + ")."
                }
            }
            return result
        }
    },programWithDepth: function(i, fn, data) {
        var args = Array.prototype.slice.call(arguments, 3);
        var program = function(context, options) {
            options = options || {};
            return fn.apply(this, [context, options.data || data].concat(args))
        };
        program.program = i;
        program.depth = args.length;
        return program
    },program: function(i, fn, data) {
        var program = function(context, options) {
            options = options || {};
            return fn(context, options.data || data)
        };
        program.program = i;
        program.depth = 0;
        return program
    },noop: function() {
        return ""
    },invokePartial: function(partial, name, context, helpers, partials, data) {
        var options = {helpers: helpers,partials: partials,data: data};
        if (partial === undefined) {
            throw new Handlebars.Exception("The partial " + name + " could not be found")
        } else if (partial instanceof Function) {
            return partial(context, options)
        } else if (!Handlebars.compile) {
            throw new Handlebars.Exception("The partial " + name + " could not be compiled when running in runtime-only mode")
        } else {
            partials[name] = Handlebars.compile(partial, {data: data !== undefined});
            return partials[name](context, options)
        }
    }};
    Handlebars.template = Handlebars.VM.template
})(Handlebars);
this["joint"] = this["joint"] || {};
this["joint"]["templates"] = this["joint"]["templates"] || {};
this["joint"]["templates"]["inspector"] = this["joint"]["templates"]["inspector"] || {};
this["joint"]["templates"]["inspector"]["color.html"] = Handlebars.template(function(Handlebars, depth0, helpers, partials, data) {
    this.compilerInfo = [4, ">= 1.0.0"];
    helpers = this.merge(helpers, Handlebars.helpers);
    data = data || {};
    var buffer = "", stack1, functionType = "function", escapeExpression = this.escapeExpression;
    buffer += "<label>";
    if (stack1 = helpers.label) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.label;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + ':</label>\n<input type="color" class="color" data-type="';
    if (stack1 = helpers.type) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.type;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '" data-attribute="';
    if (stack1 = helpers.attribute) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.attribute;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '" value="';
    if (stack1 = helpers.value) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.value;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '" />\n';
    return buffer
});
this["joint"]["templates"]["inspector"]["group.html"] = Handlebars.template(function(Handlebars, depth0, helpers, partials, data) {
    this.compilerInfo = [4, ">= 1.0.0"];
    helpers = this.merge(helpers, Handlebars.helpers);
    data = data || {};
    var buffer = "", stack1, functionType = "function", escapeExpression = this.escapeExpression;
    buffer += '<div class="group">\n    <h3 class="group-label">';
    if (stack1 = helpers.label) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.label;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + "</h3>\n</div>\n";
    return buffer
});
this["joint"]["templates"]["inspector"]["list-item.html"] = Handlebars.template(function(Handlebars, depth0, helpers, partials, data) {
    this.compilerInfo = [4, ">= 1.0.0"];
    helpers = this.merge(helpers, Handlebars.helpers);
    data = data || {};
    var buffer = "", stack1, functionType = "function", escapeExpression = this.escapeExpression;
    buffer += '<div class="list-item" data-index="';
    if (stack1 = helpers.index) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.index;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '">\n    <button class="btn-list-del">-</button>\n</div>\n';
    return buffer
});
this["joint"]["templates"]["inspector"]["list.html"] = Handlebars.template(function(Handlebars, depth0, helpers, partials, data) {
    this.compilerInfo = [4, ">= 1.0.0"];
    helpers = this.merge(helpers, Handlebars.helpers);
    data = data || {};
    var buffer = "", stack1, functionType = "function", escapeExpression = this.escapeExpression;
    buffer += "<label>";
    if (stack1 = helpers.label) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.label;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + ':</label>\n<div class="list" data-type="';
    if (stack1 = helpers.type) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.type;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '" data-attribute="';
    if (stack1 = helpers.attribute) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.attribute;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '">\n    <button class="btn-list-add">+</button>\n    <div class="list-items">\n    </div>\n</div>\n';
    return buffer
});
this["joint"]["templates"]["inspector"]["number.html"] = Handlebars.template(function(Handlebars, depth0, helpers, partials, data) {
    this.compilerInfo = [4, ">= 1.0.0"];
    helpers = this.merge(helpers, Handlebars.helpers);
    data = data || {};
    var buffer = "", stack1, stack2, functionType = "function", escapeExpression = this.escapeExpression;
    buffer += "<label>";
    if (stack1 = helpers.label) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.label;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + ':</label>\n<input type="number" class="number" data-type="';
    if (stack1 = helpers.type) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.type;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '" data-attribute="';
    if (stack1 = helpers.attribute) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.attribute;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '" min="' + escapeExpression((stack1 = (stack1 = depth0.options, stack1 == null || stack1 === false ? stack1 : stack1.min), typeof stack1 === functionType ? stack1.apply(depth0) : stack1)) + '" max="' + escapeExpression((stack1 = (stack1 = depth0.options, stack1 == null || stack1 === false ? stack1 : stack1.max), typeof stack1 === functionType ? stack1.apply(depth0) : stack1)) + '" step="' + escapeExpression((stack1 = (stack1 = depth0.options, stack1 == null || stack1 === false ? stack1 : stack1.step), typeof stack1 === functionType ? stack1.apply(depth0) : stack1)) + '" value="';
    if (stack2 = helpers.value) {
        stack2 = stack2.call(depth0, {hash: {},data: data})
    } else {
        stack2 = depth0.value;
        stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2
    }
    buffer += escapeExpression(stack2) + '"/>\n';
    return buffer
});
this["joint"]["templates"]["inspector"]["object-property.html"] = Handlebars.template(function(Handlebars, depth0, helpers, partials, data) {
    this.compilerInfo = [4, ">= 1.0.0"];
    helpers = this.merge(helpers, Handlebars.helpers);
    data = data || {};
    var buffer = "", stack1, functionType = "function", escapeExpression = this.escapeExpression;
    buffer += '<div class="object-property" data-property="';
    if (stack1 = helpers.property) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.property;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '">\n</div>\n';
    return buffer
});
this["joint"]["templates"]["inspector"]["object.html"] = Handlebars.template(function(Handlebars, depth0, helpers, partials, data) {
    this.compilerInfo = [4, ">= 1.0.0"];
    helpers = this.merge(helpers, Handlebars.helpers);
    data = data || {};
    var buffer = "", stack1, functionType = "function", escapeExpression = this.escapeExpression;
    buffer += "<label>";
    if (stack1 = helpers.label) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.label;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + ':</label>\n<div class="object" data-type="';
    if (stack1 = helpers.type) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.type;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '" data-attribute="';
    if (stack1 = helpers.attribute) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.attribute;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '">\n    <div class="object-properties"></div>\n</div>\n';
    return buffer
});
this["joint"]["templates"]["inspector"]["range.html"] = Handlebars.template(function(Handlebars, depth0, helpers, partials, data) {
    this.compilerInfo = [4, ">= 1.0.0"];
    helpers = this.merge(helpers, Handlebars.helpers);
    data = data || {};
    var buffer = "", stack1, stack2, functionType = "function", escapeExpression = this.escapeExpression;
    buffer += "<form onchange=\"$(this).find('output').text(range.value)\">\n    <label>";
    if (stack1 = helpers.label) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.label;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + ": (<output>";
    if (stack1 = helpers.value) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.value;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + "</output>" + escapeExpression((stack1 = (stack1 = depth0.options, stack1 == null || stack1 === false ? stack1 : stack1.unit), typeof stack1 === functionType ? stack1.apply(depth0) : stack1)) + ')</label>\n    <input type="range" class="range" name="range" data-type="';
    if (stack2 = helpers.type) {
        stack2 = stack2.call(depth0, {hash: {},data: data})
    } else {
        stack2 = depth0.type;
        stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2
    }
    buffer += escapeExpression(stack2) + '" data-attribute="';
    if (stack2 = helpers.attribute) {
        stack2 = stack2.call(depth0, {hash: {},data: data})
    } else {
        stack2 = depth0.attribute;
        stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2
    }
    buffer += escapeExpression(stack2) + '" min="' + escapeExpression((stack1 = (stack1 = depth0.options, stack1 == null || stack1 === false ? stack1 : stack1.min), typeof stack1 === functionType ? stack1.apply(depth0) : stack1)) + '" max="' + escapeExpression((stack1 = (stack1 = depth0.options, stack1 == null || stack1 === false ? stack1 : stack1.max), typeof stack1 === functionType ? stack1.apply(depth0) : stack1)) + '" step="' + escapeExpression((stack1 = (stack1 = depth0.options, stack1 == null || stack1 === false ? stack1 : stack1.step), typeof stack1 === functionType ? stack1.apply(depth0) : stack1)) + '" value="';
    if (stack2 = helpers.value) {
        stack2 = stack2.call(depth0, {hash: {},data: data})
    } else {
        stack2 = depth0.value;
        stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2
    }
    buffer += escapeExpression(stack2) + '"/>\n</form>\n';
    return buffer
});
this["joint"]["templates"]["inspector"]["select.html"] = Handlebars.template(function(Handlebars, depth0, helpers, partials, data) {
    this.compilerInfo = [4, ">= 1.0.0"];
    helpers = this.merge(helpers, Handlebars.helpers);
    data = data || {};
    var buffer = "", stack1, stack2, functionType = "function", escapeExpression = this.escapeExpression, self = this, helperMissing = helpers.helperMissing;
    function program1(depth0, data) {
        var buffer = "", stack1;
        buffer += ' multiple size="' + escapeExpression((stack1 = (stack1 = (stack1 = depth0.options, stack1 == null || stack1 === false ? stack1 : stack1.options), stack1 == null || stack1 === false ? stack1 : stack1.length), typeof stack1 === functionType ? stack1.apply(depth0) : stack1)) + '" ';
        return buffer
    }
    function program3(depth0, data, depth1) {
        var buffer = "", stack1, stack2, options;
        buffer += '\n    <option value="' + escapeExpression((stack1 = depth0.value, typeof stack1 === functionType ? stack1.apply(depth0) : stack1)) + '" ';
        options = {hash: {},inverse: self.noop,fn: self.program(4, program4, data),data: data};
        stack2 = (stack1 = helpers["is-or-contains"] || depth0["is-or-contains"], stack1 ? stack1.call(depth0, depth0.value, depth1.value, options) : helperMissing.call(depth0, "is-or-contains", depth0.value, depth1.value, options));
        if (stack2 || stack2 === 0) {
            buffer += stack2
        }
        buffer += ">" + escapeExpression((stack1 = depth0.content, typeof stack1 === functionType ? stack1.apply(depth0) : stack1)) + "</option>\n    ";
        return buffer
    }
    function program4(depth0, data) {
        return " selected "
    }
    buffer += "<label>";
    if (stack1 = helpers.label) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.label;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + ':</label>\n<select class="select" data-type="';
    if (stack1 = helpers.type) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.type;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '" data-attribute="';
    if (stack1 = helpers.attribute) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.attribute;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '" value="';
    if (stack1 = helpers.value) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.value;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '" ';
    stack2 = helpers["if"].call(depth0, (stack1 = depth0.options, stack1 == null || stack1 === false ? stack1 : stack1.multiple), {hash: {},inverse: self.noop,fn: self.program(1, program1, data),data: data});
    if (stack2 || stack2 === 0) {
        buffer += stack2
    }
    buffer += ">\n    ";
    stack2 = helpers.each.call(depth0, (stack1 = depth0.options, stack1 == null || stack1 === false ? stack1 : stack1.items), {hash: {},inverse: self.noop,fn: self.programWithDepth(3, program3, data, depth0),data: data});
    if (stack2 || stack2 === 0) {
        buffer += stack2
    }
    buffer += "\n</select>\n";
    return buffer
});
this["joint"]["templates"]["inspector"]["text.html"] = Handlebars.template(function(Handlebars, depth0, helpers, partials, data) {
    this.compilerInfo = [4, ">= 1.0.0"];
    helpers = this.merge(helpers, Handlebars.helpers);
    data = data || {};
    var buffer = "", stack1, functionType = "function", escapeExpression = this.escapeExpression;
    buffer += "<label>";
    if (stack1 = helpers.label) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.label;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + ':</label>\n<input type="text" class="text" data-type="';
    if (stack1 = helpers.type) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.type;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '" data-attribute="';
    if (stack1 = helpers.attribute) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.attribute;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '" value="';
    if (stack1 = helpers.value) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.value;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '" />\n';
    return buffer
});
this["joint"]["templates"]["inspector"]["textarea.html"] = Handlebars.template(function(Handlebars, depth0, helpers, partials, data) {
    this.compilerInfo = [4, ">= 1.0.0"];
    helpers = this.merge(helpers, Handlebars.helpers);
    data = data || {};
    var buffer = "", stack1, functionType = "function", escapeExpression = this.escapeExpression;
    buffer += "<label>";
    if (stack1 = helpers.label) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.label;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + ':</label>\n<textarea class="textarea" data-type="';
    if (stack1 = helpers.type) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.type;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '" data-attribute="';
    if (stack1 = helpers.attribute) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.attribute;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '">';
    if (stack1 = helpers.value) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.value;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + "</textarea>\n";
    return buffer
});
this["joint"]["templates"]["inspector"]["toggle.html"] = Handlebars.template(function(Handlebars, depth0, helpers, partials, data) {
    this.compilerInfo = [4, ">= 1.0.0"];
    helpers = this.merge(helpers, Handlebars.helpers);
    data = data || {};
    var buffer = "", stack1, functionType = "function", escapeExpression = this.escapeExpression, self = this;
    function program1(depth0, data) {
        return " checked "
    }
    buffer += "<label>";
    if (stack1 = helpers.label) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.label;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + ':</label>\n<div class="toggle">\n    <input type="checkbox" data-type="';
    if (stack1 = helpers.type) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.type;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '" data-attribute="';
    if (stack1 = helpers.attribute) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.attribute;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + '" ';
    stack1 = helpers["if"].call(depth0, depth0.value, {hash: {},inverse: self.noop,fn: self.program(1, program1, data),data: data});
    if (stack1 || stack1 === 0) {
        buffer += stack1
    }
    buffer += " />\n    <span><i></i></span>\n</div>\n";
    return buffer
});
Handlebars.registerHelper("is", function(value, test, options) {
    if (value == test) {
        return options.fn(this)
    }
    return options.inverse(this)
});
Handlebars.registerHelper("is-or-contains", function(value, test, options) {
    if (_.isArray(test) ? _.contains(test, value) : value == test) {
        return options.fn(this)
    }
    return options.inverse(this)
});
Handlebars.registerPartial("list-item", joint.templates.inspector["list-item.html"]);
joint.ui.Inspector = Backbone.View.extend({className: "inspector",options: {cellView: undefined,cell: undefined,live: true,validateInput: function(input, path) {
    return input.validity.valid
}},events: {mousedown: "startBatchCommand","change [data-attribute]": "onChangeInput","click .group-label": "onGroupLabelClick","click .btn-list-add": "addListItem","click .btn-list-del": "deleteListItem"},initialize: function(options) {
    this.options = _.extend({}, _.result(this, "options"), options || {});
    this.options.groups = this.options.groups || {};
    _.bindAll(this, "stopBatchCommand");
    $(document).on("mouseup", this.stopBatchCommand);
    this.flatAttributes = joint.util.flattenObject(this.options.inputs, "/", function(obj) {
        return obj.type
    });
    this._when = {};
    this._bound = {};
    var attributesArray = _.map(this.flatAttributes, function(options, path) {
        if (options.when) {
            var dependant = {expression: options.when,path: path};
            _.each(this.extractExpressionPaths(dependant.expression), function(condPath) {
                (this._when[condPath] || (this._when[condPath] = [])).push(dependant)
            }, this)
        }
        if (options.type == "select" && _.isString(options.options)) {
            this._bound[path] = options.options
        }
        options.path = path;
        return options
    }, this);
    this.groupedFlatAttributes = _.sortBy(_.sortBy(attributesArray, "index"), function(options) {
        var groupOptions = this.options.groups[options.group];
        return groupOptions && groupOptions.index || Number.MAX_VALUE
    }, this);
    this.on("render", function() {
        this._byPath = {};
        _.each(this.$("[data-attribute]"), function(attribute) {
            var $attribute = $(attribute);
            this._byPath[$attribute.attr("data-attribute")] = $attribute
        }, this)
    }, this);
    this.listenTo(this.getModel(), "all", this.onCellChange, this)
},getModel: function() {
    return this.options.cell || this.options.cellView.model
},onCellChange: function(eventName, cell, change, opt) {
    opt = opt || {};
    if (opt.inspector == this.cid)
        return;
    switch (eventName) {
        case "remove":
            this.remove();
            break;
        case "change:position":
            this.updateInputPosition();
            break;
        case "change:size":
            this.updateInputSize();
            break;
        case "change:angle":
            this.updateInputAngle();
            break;
        case "change:source":
        case "change:target":
        case "change:vertices":
            break;
        default:
            var changeAttributeEvent = "change:";
            if (eventName.slice(0, changeAttributeEvent.length) === changeAttributeEvent) {
                this.render()
            }
            break
    }
},render: function() {
    this.$el.empty();
    var lastGroup;
    var $groups = [];
    var $group;
    _.each(this.groupedFlatAttributes, function(options) {
        if (lastGroup !== options.group) {
            var groupOptions = this.options.groups[options.group];
            var groupLabel = groupOptions ? groupOptions.label || options.group : options.group;
            $group = $(joint.templates.inspector["group.html"]({label: groupLabel}));
            $group.attr("data-name", options.group);
            if (groupOptions && groupOptions.closed)
                $group.addClass("closed");
            $groups.push($group)
        }
        this.renderTemplate($group, options, options.path);
        lastGroup = options.group
    }, this);
    this.$el.append($groups);
    this.trigger("render");
    return this
},getCellAttributeValue: function(path, options) {
    var cell = this.getModel();
    var value = joint.util.getByPath(cell.attributes, path, "/");
    if (!options)
        return value;
    if (_.isUndefined(value) && !_.isUndefined(options.defaultValue)) {
        value = options.defaultValue
    }
    if (options.valueRegExp) {
        if (_.isUndefined(value)) {
            throw new Error("Inspector: defaultValue must be present when valueRegExp is used.")
        }
        var valueMatch = value.match(new RegExp(options.valueRegExp));
        value = valueMatch && valueMatch[2]
    }
    return value
},resolveBindings: function(options) {
    switch (options.type) {
        case "select":
            var items = options.options || [];
            if (_.isString(items)) {
                items = joint.util.getByPath(this.getModel().attributes, items, "/") || []
            }
            if (!_.isObject(items[0])) {
                items = _.map(items, function(item) {
                    return {value: item,content: item}
                })
            }
            options.items = items;
            break
    }
},updateBindings: function(path) {
    var slaves = _.reduce(this._bound, function(result, master, slave) {
        if (!path.indexOf(master))
            result.push(slave);
        return result
    }, []);
    if (!_.isEmpty(slaves)) {
        _.each(slaves, function(slave) {
            this.renderTemplate(null, this.flatAttributes[slave], slave, {replace: true})
        }, this);
        this.trigger("render")
    }
},renderTemplate: function($el, options, path, opt) {
    $el = $el || this.$el;
    opt = opt || {};
    this.resolveBindings(options);
    var $field = $('<div class="field"></div>').attr("data-field", path);
    if (options.when && !this.isExpressionValid(options.when)) {
        $field.addClass("hidden");
        if (options.when.otherwise) {
            if (options.when.otherwise.unset)
                this.unsetProperty(path)
        }
    }
    var value = this.getCellAttributeValue(path, options);
    var inputHtml = joint.templates.inspector[options.type + ".html"]({options: options,type: options.type,label: options.label || path,attribute: path,value: value});
    var $input = $(inputHtml);
    $field.append($input);
    _.each(options.attrs, function(attrs, selector) {
        $field.find(selector).addBack().filter(selector).attr(attrs)
    });
    if (options.type === "list") {
        _.each(value, function(itemValue, idx) {
            var $listItem = $(joint.templates.inspector["list-item.html"]({index: idx}));
            this.renderTemplate($listItem, options.item, path + "/" + idx);
            $input.children(".list-items").append($listItem)
        }, this)
    } else if (options.type === "object") {
        options.flatAttributes = joint.util.flattenObject(options.properties, "/", function(obj) {
            return obj.type
        });
        var attributesArray = _.map(options.flatAttributes, function(options, path) {
            options.path = path;
            return options
        });
        attributesArray = _.sortBy(attributesArray, function(options) {
            return options.index
        });
        _.each(attributesArray, function(propertyOptions) {
            var $objectProperty = $(joint.templates.inspector["object-property.html"]({property: propertyOptions.path}));
            this.renderTemplate($objectProperty, propertyOptions, path + "/" + propertyOptions.path);
            $input.children(".object-properties").append($objectProperty)
        }, this)
    }
    if (opt.replace) {
        $el.find('[data-field="' + path + '"]').replaceWith($field)
    } else {
        $el.append($field)
    }
},updateInputPosition: function() {
    var $inputX = this._byPath["position/x"];
    var $inputY = this._byPath["position/y"];
    var position = this.getModel().get("position");
    if ($inputX) {
        $inputX.val(position.x)
    }
    if ($inputY) {
        $inputY.val(position.y)
    }
},updateInputSize: function() {
    var $inputWidth = this._byPath["size/width"];
    var $inputHeight = this._byPath["size/height"];
    var size = this.getModel().get("size");
    if ($inputWidth) {
        $inputWidth.val(size.width)
    }
    if ($inputHeight) {
        $inputHeight.val(size.height)
    }
},updateInputAngle: function() {
    var $inputAngle = this._byPath["angle"];
    var angle = this.getModel().get("angle");
    if ($inputAngle) {
        $inputAngle.val(angle)
    }
},onChangeInput: function(evt) {
    var $input = $(evt.target);
    var path = $input.attr("data-attribute");
    if (!this.options.validateInput($input[0], path))
        return;
    if (this.options.live) {
        this.updateCell($input, path)
    }
    var type = $input.attr("data-type");
    var value = this.parse(type, $input.val(), $input[0]);
    var dependants = this._when[path];
    this.trigger("change:" + path, value, $input[0]);
    if (dependants) {
        _.each(dependants, function(dependant) {
            var $attribute = this._byPath[dependant.path];
            var $field = $attribute.closest(".field");
            var previouslyHidden = $field.hasClass("hidden");
            var valid = this.isExpressionValid(dependant.expression);
            $field.toggleClass("hidden", !valid);
            if (dependant.expression.otherwise) {
                if (dependant.expression.otherwise.unset && this.options.live) {
                    if (!valid) {
                        this.unsetProperty(dependant.path);
                        this.renderTemplate(null, this.flatAttributes[dependant.path], dependant.path, {replace: true});
                        this.trigger("render")
                    } else if (previouslyHidden) {
                        this.updateCell($attribute, dependant.path)
                    }
                }
            }
        }, this)
    }
},unsetProperty: function(path, opt) {
    var cell = this.getModel();
    var pathArray = path.split("/");
    var attribute = _.first(pathArray);
    var nestedAttrPath = _.rest(pathArray).join("/");
    opt = opt || {};
    opt.inspector = this.cid;
    opt["inspector_" + this.cid] = true;
    if (path == "attrs") {
        cell.removeAttr(nestedAttrPath, opt)
    } else if (path == attribute) {
        cell.unset(attribute, opt)
    } else {
        var oldAttrValue = _.merge({}, cell.get(attribute));
        var newAttrValue = joint.util.unsetByPath(oldAttrValue, nestedAttrPath, "/");
        cell.set(attribute, newAttrValue, opt)
    }
},getOptions: function($attribute) {
    if ($attribute.length === 0)
        return undefined;
    var path = $attribute.attr("data-attribute");
    var type = $attribute.attr("data-type");
    var options = this.flatAttributes[path];
    if (!options) {
        var $parentAttribute = $attribute.parent().closest("[data-attribute]");
        var parentPath = $parentAttribute.attr("data-attribute");
        options = this.getOptions($parentAttribute);
        var childPath = path.replace(parentPath + "/", "");
        var parent = options;
        options = parent.item || parent.flatAttributes[childPath];
        options.parent = parent
    }
    return options
},updateCell: function($attr, attrPath) {
    var cell = this.getModel();
    var byPath = {};
    if ($attr) {
        byPath[attrPath] = $attr
    } else {
        byPath = this._byPath
    }
    this.startBatchCommand();
    this._tempListsByPath = {};
    _.each(byPath, function($attribute, path) {
        if ($attribute.closest(".field").hasClass("hidden"))
            return;
        var type = $attribute.attr("data-type");
        var value;
        var options;
        var kind;
        switch (type) {
            case "list":
                if (!byPath[path + "/0"]) {
                    this.setProperty(path, [], {rewrite: true})
                } else {
                    this._tempListsByPath[path] = []
                }
                break;
            case "object":
                break;
            default:
                if (!this.options.validateInput($attribute[0], path))
                    return;
                value = this.parse(type, $attribute.val(), $attribute[0]);
                options = this.getOptions($attribute);
                if (options.valueRegExp) {
                    var oldValue = joint.util.getByPath(cell.attributes, path, "/") || options.defaultValue;
                    value = oldValue.replace(new RegExp(options.valueRegExp), "$1" + value + "$3")
                }
                if (options.parent && options.parent.type === "list") {
                    var pathArray = path.split("/");
                    var parentPath = _.initial(pathArray).join("/");
                    if (this._tempListsByPath[parentPath]) {
                        var index = parseInt(_.last(pathArray), 10);
                        this._tempListsByPath[parentPath][index] = value;
                        if (!byPath[parentPath + "/" + (index + 1)]) {
                            this.setProperty(parentPath, this._tempListsByPath[parentPath], {rewrite: true})
                        }
                        return
                    }
                }
                this.setProperty(path, value);
                break
        }
        this.updateBindings(path)
    }, this);
    this.stopBatchCommand()
},setProperty: function(path, value, opt) {
    opt = opt || {};
    opt.inspector = this.cid;
    opt["inspector_" + this.cid] = true;
    joint.dia.Cell.prototype.prop.call(this.getModel(), path, value, opt)
},parse: function(type, value, targetElement) {
    switch (type) {
        case "number":
            value = parseFloat(value);
            break;
        case "toggle":
            value = targetElement.checked;
            break;
        default:
            value = value;
            break
    }
    return value
},startBatchCommand: function() {
    this.getModel().trigger("batch:start")
},stopBatchCommand: function() {
    this.getModel().trigger("batch:stop")
},addListItem: function(evt) {
    var $target = $(evt.target);
    var $attribute = $target.closest("[data-attribute]");
    var path = $attribute.attr("data-attribute");
    var options = this.getOptions($attribute);
    var $lastListItem = $attribute.children(".list-items").children(".list-item").last();
    var lastIndex = $lastListItem.length === 0 ? -1 : parseInt($lastListItem.attr("data-index"), 10);
    var index = lastIndex + 1;
    var $listItem = $(joint.templates.inspector["list-item.html"]({index: index}));
    this.renderTemplate($listItem, options.item, path + "/" + index);
    $target.parent().children(".list-items").append($listItem);
    $listItem.find("input:first").focus();
    this.trigger("render");
    if (this.options.live) {
        this.updateCell()
    }
},deleteListItem: function(evt) {
    var $listItem = $(evt.target).closest(".list-item");
    $listItem.nextAll(".list-item").each(function() {
        var index = parseInt($(this).attr("data-index"), 10);
        var newIndex = index - 1;
        $(this).find("[data-field]").each(function() {
            $(this).attr("data-field", $(this).attr("data-field").replace("/" + index, "/" + newIndex))
        });
        $(this).find("[data-attribute]").each(function() {
            $(this).attr("data-attribute", $(this).attr("data-attribute").replace("/" + index, "/" + newIndex))
        });
        $(this).attr("data-index", newIndex)
    });
    $listItem.remove();
    this.trigger("render");
    if (this.options.live) {
        this.updateCell()
    }
},remove: function() {
    $(document).off("mouseup", this.stopBatchCommand);
    return Backbone.View.prototype.remove.apply(this, arguments)
},onGroupLabelClick: function(evt) {
    evt.preventDefault();
    var $group = $(evt.target).closest(".group");
    this.toggleGroup($group.data("name"))
},toggleGroup: function(name) {
    this.$('.group[data-name="' + name + '"]').toggleClass("closed")
},closeGroup: function(name) {
    this.$('.group[data-name="' + name + '"]').addClass("closed")
},openGroup: function(name) {
    this.$('.group[data-name="' + name + '"]').removeClass("closed")
},closeGroups: function() {
    this.$(".group").addClass("closed")
},openGroups: function() {
    this.$(".group").removeClass("closed")
},_isComposite: function(expr) {
    var composite = _.pick(expr, "not", "and", "or", "nor");
    return _.some(composite)
},_isPrimitive: function(expr) {
    var primitive = _.pick(expr, "eq", "ne", "regex", "text", "lt", "lte", "gt", "gte", "in", "nin");
    return _.some(primitive)
},_evalPrimitive: function(expr) {
    return _.reduce(expr, function(res, condition, operator) {
        return _.reduce(condition, function(res, condValue, condPath) {
            var val = this.getCellAttributeValue(condPath, this.flatAttributes[condPath]);
            switch (operator) {
                case "eq":
                    return condValue == val;
                case "ne":
                    return condValue != val;
                case "regex":
                    return new RegExp(condValue).test(val);
                case "text":
                    return !condValue || _.isString(val) && val.toLowerCase().indexOf(condValue) > -1;
                case "lt":
                    return val < condValue;
                case "lte":
                    return val <= condValue;
                case "gt":
                    return val > condValue;
                case "gte":
                    return val >= condValue;
                case "in":
                    return _.contains(condValue, val);
                case "nin":
                    return !_.contains(condValue, val);
                default:
                    return res
            }
        }, false, this)
    }, false, this)
},_evalExpression: function(expr) {
    if (this._isPrimitive(expr)) {
        return this._evalPrimitive(expr)
    }
    return _.reduce(expr, function(res, childExpr, operator) {
        if (operator == "not")
            return !this._evalExpression(childExpr);
        var childExprRes = _.map(childExpr, this._evalExpression, this);
        switch (operator) {
            case "and":
                return _.every(childExprRes);
            case "or":
                return _.some(childExprRes);
            case "nor":
                return !_.some(childExprRes);
            default:
                return res
        }
    }, false, this)
},_extractVariables: function(expr) {
    if (_.isArray(expr) || this._isComposite(expr)) {
        return _.reduce(expr, function(res, childExpr) {
            return res.concat(this._extractVariables(childExpr))
        }, [], this)
    }
    return _.reduce(expr, function(res, primitive) {
        return _.keys(primitive)
    }, [])
},isExpressionValid: function(expr) {
    expr = _.omit(expr, "otherwise");
    return this._evalExpression(expr)
},extractExpressionPaths: function(expr) {
    expr = _.omit(expr, "otherwise");
    return _.uniq(this._extractVariables(expr))
}});
joint.ui.SelectionView = Backbone.View.extend({options: {paper: undefined,graph: undefined,boxContent: function(boxElement) {
    var tmpl = _.template("<%= length %> elements selected.");
    return tmpl({length: this.model.length})
},handles: [{name: "remove",position: "nw",events: {pointerdown: "removeElements"}}, {name: "rotate",position: "sw",events: {pointerdown: "startRotating",pointermove: "doRotate",pointerup: "stopBatch"}}],useModelGeometry: false},className: "selection",events: {"mousedown .selection-box": "startTranslatingSelection","touchstart .selection-box": "startTranslatingSelection","mousedown .handle": "onHandlePointerDown","touchstart .handle": "onHandlePointerDown"},initialize: function(options) {
    this.options = _.extend({}, _.result(this, "options"), options || {});
    _.bindAll(this, "startSelecting", "stopSelecting", "adjustSelection", "pointerup");
    $(document.body).on("mousemove.selectionView touchmove.selectionView", this.adjustSelection);
    $(document).on("mouseup.selectionView touchend.selectionView", this.pointerup);
    this.listenTo(this.options.graph, "reset", this.cancelSelection);
    this.listenTo(this.options.paper, "scale translate", this.updateSelectionBoxes);
    this.listenTo(this.options.graph, "remove change", function(cell, opt) {
        if (!opt["selectionView_" + this.cid])
            this.updateSelectionBoxes()
    });
    this.options.paper.$el.append(this.$el);
    this._boxCount = 0;
    this.createSelectionWrapper();
    this.handles = [];
    _.each(this.options.handles, this.addHandle, this)
},addHandle: function(opt) {
    this.handles.push(opt);
    var $handle = $("<div/>", {"class": "handle " + (opt.position || "") + " " + (opt.name || ""),"data-action": opt.name});
    if (opt.icon) {
        $handle.css("background-image", "url(" + opt.icon + ")")
    }
    $handle.html(opt.content || "");
    this.$(".selection-wrapper").append($handle);
    _.each(opt.events, function(method, event) {
        if (_.isString(method)) {
            this.on("action:" + opt.name + ":" + event, this[method], this)
        } else {
            this.on("action:" + opt.name + ":" + event, method)
        }
    }, this);
    return this
},removeHandle: function(name) {
    var handleIdx = _.findIndex(this.handles, {name: name});
    var handle = this.handles[handleIdx];
    if (handle) {
        _.each(handle.events, function(method, event) {
            this.off("action:" + name + ":" + event)
        }, this);
        this.$(".handle." + name).remove();
        this.handles.splice(handleIdx, 1)
    }
    return this
},changeHandle: function(name, opt) {
    var handle = _.findWhere(this.handles, {name: name});
    if (handle) {
        this.removeHandle(name);
        this.addHandle(_.merge({name: name}, handle, opt))
    }
    return this
},startTranslatingSelection: function(evt) {
    evt.stopPropagation();
    evt = joint.util.normalizeEvent(evt);
    this._action = "translating";
    this.options.graph.trigger("batch:start");
    var snappedClientCoords = this.options.paper.snapToGrid(g.point(evt.clientX, evt.clientY));
    this._snappedClientX = snappedClientCoords.x;
    this._snappedClientY = snappedClientCoords.y;
    this.trigger("selection-box:pointerdown", evt)
},startSelecting: function(evt) {
    evt = joint.util.normalizeEvent(evt);
    this.cancelSelection();
    this._action = "selecting";
    this._clientX = evt.clientX;
    this._clientY = evt.clientY;
    var paperElement = evt.target.parentElement || evt.target.parentNode;
    var paperOffset = $(paperElement).offset();
    var paperScrollLeft = paperElement.scrollLeft;
    var paperScrollTop = paperElement.scrollTop;
    this._offsetX = evt.offsetX === undefined ? evt.clientX - paperOffset.left + window.pageXOffset + paperScrollLeft : evt.offsetX;
    this._offsetY = evt.offsetY === undefined ? evt.clientY - paperOffset.top + window.pageYOffset + paperScrollTop : evt.offsetY;
    this.$el.css({width: 1,height: 1,left: this._offsetX,top: this._offsetY}).show()
},adjustSelection: function(evt) {
    evt = joint.util.normalizeEvent(evt);
    var dx;
    var dy;
    switch (this._action) {
        case "selecting":
            dx = evt.clientX - this._clientX;
            dy = evt.clientY - this._clientY;
            var width = this.$el.width();
            var height = this.$el.height();
            var left = parseInt(this.$el.css("left"), 10);
            var top = parseInt(this.$el.css("top"), 10);
            this.$el.css({left: dx < 0 ? this._offsetX + dx : left,top: dy < 0 ? this._offsetY + dy : top,width: Math.abs(dx),height: Math.abs(dy)});
            break;
        case "translating":
            var snappedClientCoords = this.options.paper.snapToGrid(g.point(evt.clientX, evt.clientY));
            var snappedClientX = snappedClientCoords.x;
            var snappedClientY = snappedClientCoords.y;
            dx = snappedClientX - this._snappedClientX;
            dy = snappedClientY - this._snappedClientY;
            var processedCells = {};
            this.model.each(function(element) {
                if (processedCells[element.id])
                    return;
                var opt = {};
                opt["selectionView_" + this.cid] = true;
                element.translate(dx, dy, opt);
                _.each(element.getEmbeddedCells({deep: true}), function(embed) {
                    processedCells[embed.id] = true
                });
                var connectedLinks = this.options.graph.getConnectedLinks(element);
                _.each(connectedLinks, function(link) {
                    if (processedCells[link.id])
                        return;
                    link.translate(dx, dy, opt);
                    processedCells[link.id] = true
                })
            }, this);
            if (dx || dy) {
                var paperScale = V(this.options.paper.viewport).scale();
                dx *= paperScale.sx;
                dy *= paperScale.sy;
                this.$(".selection-box").each(function() {
                    var left = parseFloat($(this).css("left"), 10);
                    var top = parseFloat($(this).css("top"), 10);
                    $(this).css({left: left + dx,top: top + dy})
                });
                var $selectionWrapper = this.$(".selection-wrapper");
                if ($selectionWrapper.length) {
                    var left = parseFloat($selectionWrapper.css("left"), 10);
                    var top = parseFloat($selectionWrapper.css("top"), 10);
                    $selectionWrapper.css({left: left + dx,top: top + dy})
                }
                this._snappedClientX = snappedClientX;
                this._snappedClientY = snappedClientY
            }
            this.trigger("selection-box:pointermove", evt);
            break;
        default:
            if (this._action) {
                this.pointermove(evt)
            }
            break
    }
},stopSelecting: function(evt) {
    switch (this._action) {
        case "selecting":
            var offset = this.$el.offset();
            var width = this.$el.width();
            var height = this.$el.height();
            var localPoint = V(this.options.paper.viewport).toLocalPoint(offset.left, offset.top);
            localPoint.x -= window.pageXOffset;
            localPoint.y -= window.pageYOffset;
            var paperScale = V(this.options.paper.viewport).scale();
            width /= paperScale.sx;
            height /= paperScale.sy;
            var elementViews = this.options.paper.findViewsInArea(g.rect(localPoint.x, localPoint.y, width, height));
            var filter = this.options.filter;
            if (_.isArray(filter)) {
                elementViews = _.reject(elementViews, function(view) {
                    if (_.contains(filter, view.model) || _.contains(filter, view.model.get("type"))) {
                        return true
                    }
                })
            } else if (_.isFunction(filter)) {
                elementViews = _.reject(elementViews, function(view) {
                    return filter(view.model)
                })
            }
            this.model.reset(_.pluck(elementViews, "model"));
            if (elementViews.length) {
                _.each(elementViews, this.createSelectionBox, this);
                this.$el.addClass("selected")
            } else {
                this.$el.hide()
            }
            break;
        case "translating":
            this.options.graph.trigger("batch:stop");
            this.trigger("selection-box:pointerup", evt);
            break;
        default:
            if (!this._action) {
                this.cancelSelection()
            }
            break
    }
    delete this._action
},pointerup: function(evt) {
    if (!this._action)
        return;
    this.triggerAction(this._action, "pointerup", evt);
    this.stopSelecting();
    delete this._action
},cancelSelection: function() {
    this.$el.hide();
    this.$(".selection-box").remove();
    this.$el.removeClass("selected");
    this.model.reset([]);
    this._boxCount = 0;
    this.updateSelectionWrapper()
},destroySelectionBox: function(elementView) {
    this.$('[data-model="' + elementView.model.get("id") + '"]').remove();
    if (this.$(".selection-box").length === 0) {
        this.$el.hide().removeClass("selected")
    }
    this._boxCount = Math.max(0, this._boxCount - 1);
    this.updateSelectionWrapper()
},createSelectionBox: function(elementView) {
    var viewBbox = elementView.getBBox({useModelGeometry: this.options.useModelGeometry});
    var $selectionBox = $("<div/>", {"class": "selection-box","data-model": elementView.model.get("id")});
    $selectionBox.css({left: viewBbox.x,top: viewBbox.y,width: viewBbox.width,height: viewBbox.height});
    this.$el.append($selectionBox);
    this.$el.addClass("selected").show();
    this._boxCount++;
    this.updateSelectionWrapper()
},createSelectionWrapper: function() {
    var $selectionWrapper = $("<div/>", {"class": "selection-wrapper"});
    var $box = $("<div/>", {"class": "box"});
    $selectionWrapper.append($box);
    $selectionWrapper.attr("data-selection-length", this.model.length);
    this.$el.prepend($selectionWrapper)
},updateSelectionWrapper: function() {
    var origin = {x: Infinity,y: Infinity};
    var corner = {x: 0,y: 0};
    this.model.each(function(cell) {
        var view = this.options.paper.findViewByModel(cell);
        if (view) {
            var bbox = view.getBBox({useModelGeometry: this.options.useModelGeometry});
            origin.x = Math.min(origin.x, bbox.x);
            origin.y = Math.min(origin.y, bbox.y);
            corner.x = Math.max(corner.x, bbox.x + bbox.width);
            corner.y = Math.max(corner.y, bbox.y + bbox.height)
        }
    }, this);
    this.$(".selection-wrapper").css({left: origin.x,top: origin.y,width: corner.x - origin.x,height: corner.y - origin.y}).attr("data-selection-length", this.model.length);
    if (_.isFunction(this.options.boxContent)) {
        var $box = this.$(".box");
        var content = this.options.boxContent.call(this, $box[0]);
        if (content) {
            $box.html(content)
        }
    }
},updateSelectionBoxes: function() {
    if (!this._boxCount)
        return;
    this.$el.hide().removeClass("selected").find(".selection-box").each(_.bind(function(index, element) {
        var removedId = $(element).remove().attr("data-model");
        var view = this.options.paper.findViewByModel(this.model.get(removedId));
        if (view) {
            this.createSelectionBox(view)
        }
    }, this));
    this.updateSelectionWrapper()
},remove: function() {
    Backbone.View.prototype.remove.apply(this, arguments);
    $(document.body).off(".selectionView")
},onHandlePointerDown: function(evt) {
    this._action = $(evt.target).closest(".handle").attr("data-action");
    if (this._action) {
        evt.preventDefault();
        evt.stopPropagation();
        evt = joint.util.normalizeEvent(evt);
        this._clientX = evt.clientX;
        this._clientY = evt.clientY;
        this._startClientX = this._clientX;
        this._startClientY = this._clientY;
        this.triggerAction(this._action, "pointerdown", evt)
    }
},pointermove: function(evt) {
    if (!this._action)
        return;
    var clientCoords = this.options.paper.snapToGrid({x: evt.clientX,y: evt.clientY});
    var oldClientCoords = this.options.paper.snapToGrid({x: this._clientX,y: this._clientY});
    var dx = clientCoords.x - oldClientCoords.x;
    var dy = clientCoords.y - oldClientCoords.y;
    this.triggerAction(this._action, "pointermove", evt, dx, dy, evt.clientX - this._startClientX, evt.clientY - this._startClientY);
    this._clientX = evt.clientX;
    this._clientY = evt.clientY
},triggerAction: function(action, eventName, evt) {
    var args = ["action:" + action + ":" + eventName].concat(_.rest(_.toArray(arguments), 2));
    this.trigger.apply(this, args)
},removeElements: function(evt) {
    var cells = this.model.models;
    this.cancelSelection();
    this.options.graph.trigger("batch:start");
    _.invoke(cells, "remove");
    this.options.graph.trigger("batch:stop")
},startRotating: function(evt) {
    this.options.graph.trigger("batch:start");
    var bbox = this.options.graph.getBBox(this.model.models);
    this._center = bbox.center();
    if (typeof evt.offsetX === "undefined" || typeof evt.offsetY === "undefined") {
        var targetOffset = $(evt.target).offset();
        evt.offsetX = evt.pageX - targetOffset.left;
        evt.offsetY = evt.pageY - targetOffset.top
    }
    this._rotationStart = g.point(evt.offsetX + evt.target.parentNode.offsetLeft, evt.offsetY + evt.target.parentNode.offsetTop + evt.target.parentNode.offsetHeight);
    this._rotationStartAngle = {};
    this.model.each(function(cell) {
        this._rotationStartAngle[cell.id] = cell.get("angle") || 0
    }, this)
},doRotate: function(evt, dx, dy, tx, ty) {
    var p = g.point(this._rotationStart).offset(tx, ty);
    var a = p.distance(this._center);
    var b = this._center.distance(this._rotationStart);
    var c = this._rotationStart.distance(p);
    var sign = (this._center.x - this._rotationStart.x) * (p.y - this._rotationStart.y) - (this._center.y - this._rotationStart.y) * (p.x - this._rotationStart.x);
    var _angle = Math.acos((a * a + b * b - c * c) / (2 * a * b));
    if (sign <= 0) {
        _angle = -_angle
    }
    var angleDiff = -g.toDeg(_angle);
    angleDiff = g.snapToGrid(angleDiff, 15);
    this.model.each(function(cell) {
        cell.rotate(angleDiff + this._rotationStartAngle[cell.id], true, this._center)
    }, this)
},stopBatch: function() {
    this.options.graph.trigger("batch:stop")
}});
joint.ui.Clipboard = Backbone.Collection.extend({copyElements: function(selection, graph, opt) {
    opt = opt || {};
    var links = [];
    var elements = [];
    var elementsIdMap = {};
    selection.each(function(element) {
        var connectedLinks = graph.getConnectedLinks(element);
        links = links.concat(_.filter(connectedLinks, function(link) {
            if (selection.get(link.get("source").id) && selection.get(link.get("target").id)) {
                return true
            }
            return false
        }));
        var clonedElement = element.clone();
        if (opt.translate) {
            clonedElement.translate(opt.translate.dx || 20, opt.translate.dy || 20)
        }
        elements.push(clonedElement);
        elementsIdMap[element.get("id")] = clonedElement.get("id")
    });
    var originalLinks = _.unique(links);
    links = _.map(originalLinks, function(link) {
        var clonedLink = link.clone();
        var source = clonedLink.get("source");
        var target = clonedLink.get("target");
        source.id = elementsIdMap[source.id];
        target.id = elementsIdMap[target.id];
        clonedLink.set({source: _.clone(source),target: _.clone(target)});
        if (opt.translate) {
            _.each(clonedLink.get("vertices"), function(vertex) {
                vertex.x += opt.translate.dx || 20;
                vertex.y += opt.translate.dy || 20
            })
        }
        return clonedLink
    });
    this.reset(elements.concat(links));
    if (opt.useLocalStorage && window.localStorage) {
        localStorage.setItem("joint.ui.Clipboard.cells", JSON.stringify(this.toJSON()))
    }
    return (selection.models || []).concat(originalLinks)
},pasteCells: function(graph, opt) {
    opt = opt || {};
    if (opt.useLocalStorage && this.length === 0 && window.localStorage) {
        this.reset(JSON.parse(localStorage.getItem("joint.ui.Clipboard.cells")))
    }
    graph.trigger("batch:start");
    this.each(function(cell) {
        cell.unset("z");
        if (cell instanceof joint.dia.Link && opt.link) {
            cell.set(opt.link)
        }
        graph.addCell(cell.toJSON())
    });
    graph.trigger("batch:stop")
},clear: function() {
    this.reset([]);
    if (window.localStorage) {
        localStorage.removeItem("joint.ui.Clipboard.cells")
    }
}});
var Handlebars = {};
(function(Handlebars, undefined) {
    Handlebars.VERSION = "1.0.0";
    Handlebars.COMPILER_REVISION = 4;
    Handlebars.REVISION_CHANGES = {1: "<= 1.0.rc.2",2: "== 1.0.0-rc.3",3: "== 1.0.0-rc.4",4: ">= 1.0.0"};
    Handlebars.helpers = {};
    Handlebars.partials = {};
    var toString = Object.prototype.toString, functionType = "[object Function]", objectType = "[object Object]";
    Handlebars.registerHelper = function(name, fn, inverse) {
        if (toString.call(name) === objectType) {
            if (inverse || fn) {
                throw new Handlebars.Exception("Arg not supported with multiple helpers")
            }
            Handlebars.Utils.extend(this.helpers, name)
        } else {
            if (inverse) {
                fn.not = inverse
            }
            this.helpers[name] = fn
        }
    };
    Handlebars.registerPartial = function(name, str) {
        if (toString.call(name) === objectType) {
            Handlebars.Utils.extend(this.partials, name)
        } else {
            this.partials[name] = str
        }
    };
    Handlebars.registerHelper("helperMissing", function(arg) {
        if (arguments.length === 2) {
            return undefined
        } else {
            throw new Error("Missing helper: '" + arg + "'")
        }
    });
    Handlebars.registerHelper("blockHelperMissing", function(context, options) {
        var inverse = options.inverse || function() {
            }, fn = options.fn;
        var type = toString.call(context);
        if (type === functionType) {
            context = context.call(this)
        }
        if (context === true) {
            return fn(this)
        } else if (context === false || context == null) {
            return inverse(this)
        } else if (type === "[object Array]") {
            if (context.length > 0) {
                return Handlebars.helpers.each(context, options)
            } else {
                return inverse(this)
            }
        } else {
            return fn(context)
        }
    });
    Handlebars.K = function() {
    };
    Handlebars.createFrame = Object.create || function(object) {
            Handlebars.K.prototype = object;
            var obj = new Handlebars.K;
            Handlebars.K.prototype = null;
            return obj
        };
    Handlebars.logger = {DEBUG: 0,INFO: 1,WARN: 2,ERROR: 3,level: 3,methodMap: {0: "debug",1: "info",2: "warn",3: "error"},log: function(level, obj) {
        if (Handlebars.logger.level <= level) {
            var method = Handlebars.logger.methodMap[level];
            if (typeof console !== "undefined" && console[method]) {
                console[method].call(console, obj)
            }
        }
    }};
    Handlebars.log = function(level, obj) {
        Handlebars.logger.log(level, obj)
    };
    Handlebars.registerHelper("each", function(context, options) {
        var fn = options.fn, inverse = options.inverse;
        var i = 0, ret = "", data;
        var type = toString.call(context);
        if (type === functionType) {
            context = context.call(this)
        }
        if (options.data) {
            data = Handlebars.createFrame(options.data)
        }
        if (context && typeof context === "object") {
            if (context instanceof Array) {
                for (var j = context.length; i < j; i++) {
                    if (data) {
                        data.index = i
                    }
                    ret = ret + fn(context[i], {data: data})
                }
            } else {
                for (var key in context) {
                    if (context.hasOwnProperty(key)) {
                        if (data) {
                            data.key = key
                        }
                        ret = ret + fn(context[key], {data: data});
                        i++
                    }
                }
            }
        }
        if (i === 0) {
            ret = inverse(this)
        }
        return ret
    });
    Handlebars.registerHelper("if", function(conditional, options) {
        var type = toString.call(conditional);
        if (type === functionType) {
            conditional = conditional.call(this)
        }
        if (!conditional || Handlebars.Utils.isEmpty(conditional)) {
            return options.inverse(this)
        } else {
            return options.fn(this)
        }
    });
    Handlebars.registerHelper("unless", function(conditional, options) {
        return Handlebars.helpers["if"].call(this, conditional, {fn: options.inverse,inverse: options.fn})
    });
    Handlebars.registerHelper("with", function(context, options) {
        var type = toString.call(context);
        if (type === functionType) {
            context = context.call(this)
        }
        if (!Handlebars.Utils.isEmpty(context))
            return options.fn(context)
    });
    Handlebars.registerHelper("log", function(context, options) {
        var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
        Handlebars.log(level, context)
    });
    var errorProps = ["description", "fileName", "lineNumber", "message", "name", "number", "stack"];
    Handlebars.Exception = function(message) {
        var tmp = Error.prototype.constructor.apply(this, arguments);
        for (var idx = 0; idx < errorProps.length; idx++) {
            this[errorProps[idx]] = tmp[errorProps[idx]]
        }
    };
    Handlebars.Exception.prototype = new Error;
    Handlebars.SafeString = function(string) {
        this.string = string
    };
    Handlebars.SafeString.prototype.toString = function() {
        return this.string.toString()
    };
    var escape = {"&": "&amp;","<": "&lt;",">": "&gt;",'"': "&quot;","'": "&#x27;","`": "&#x60;"};
    var badChars = /[&<>"'`]/g;
    var possible = /[&<>"'`]/;
    var escapeChar = function(chr) {
        return escape[chr] || "&amp;"
    };
    Handlebars.Utils = {extend: function(obj, value) {
        for (var key in value) {
            if (value.hasOwnProperty(key)) {
                obj[key] = value[key]
            }
        }
    },escapeExpression: function(string) {
        if (string instanceof Handlebars.SafeString) {
            return string.toString()
        } else if (string == null || string === false) {
            return ""
        }
        string = string.toString();
        if (!possible.test(string)) {
            return string
        }
        return string.replace(badChars, escapeChar)
    },isEmpty: function(value) {
        if (!value && value !== 0) {
            return true
        } else if (toString.call(value) === "[object Array]" && value.length === 0) {
            return true
        } else {
            return false
        }
    }};
    Handlebars.VM = {template: function(templateSpec) {
        var container = {escapeExpression: Handlebars.Utils.escapeExpression,invokePartial: Handlebars.VM.invokePartial,programs: [],program: function(i, fn, data) {
            var programWrapper = this.programs[i];
            if (data) {
                programWrapper = Handlebars.VM.program(i, fn, data)
            } else if (!programWrapper) {
                programWrapper = this.programs[i] = Handlebars.VM.program(i, fn)
            }
            return programWrapper
        },merge: function(param, common) {
            var ret = param || common;
            if (param && common) {
                ret = {};
                Handlebars.Utils.extend(ret, common);
                Handlebars.Utils.extend(ret, param)
            }
            return ret
        },programWithDepth: Handlebars.VM.programWithDepth,noop: Handlebars.VM.noop,compilerInfo: null};
        return function(context, options) {
            options = options || {};
            var result = templateSpec.call(container, Handlebars, context, options.helpers, options.partials, options.data);
            var compilerInfo = container.compilerInfo || [], compilerRevision = compilerInfo[0] || 1, currentRevision = Handlebars.COMPILER_REVISION;
            if (compilerRevision !== currentRevision) {
                if (compilerRevision < currentRevision) {
                    var runtimeVersions = Handlebars.REVISION_CHANGES[currentRevision], compilerVersions = Handlebars.REVISION_CHANGES[compilerRevision];
                    throw "Template was precompiled with an older version of Handlebars than the current runtime. " + "Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ")."
                } else {
                    throw "Template was precompiled with a newer version of Handlebars than the current runtime. " + "Please update your runtime to a newer version (" + compilerInfo[1] + ")."
                }
            }
            return result
        }
    },programWithDepth: function(i, fn, data) {
        var args = Array.prototype.slice.call(arguments, 3);
        var program = function(context, options) {
            options = options || {};
            return fn.apply(this, [context, options.data || data].concat(args))
        };
        program.program = i;
        program.depth = args.length;
        return program
    },program: function(i, fn, data) {
        var program = function(context, options) {
            options = options || {};
            return fn(context, options.data || data)
        };
        program.program = i;
        program.depth = 0;
        return program
    },noop: function() {
        return ""
    },invokePartial: function(partial, name, context, helpers, partials, data) {
        var options = {helpers: helpers,partials: partials,data: data};
        if (partial === undefined) {
            throw new Handlebars.Exception("The partial " + name + " could not be found")
        } else if (partial instanceof Function) {
            return partial(context, options)
        } else if (!Handlebars.compile) {
            throw new Handlebars.Exception("The partial " + name + " could not be compiled when running in runtime-only mode")
        } else {
            partials[name] = Handlebars.compile(partial, {data: data !== undefined});
            return partials[name](context, options)
        }
    }};
    Handlebars.template = Handlebars.VM.template
})(Handlebars);
this["joint"] = this["joint"] || {};
this["joint"]["templates"] = this["joint"]["templates"] || {};
this["joint"]["templates"]["stencil"] = this["joint"]["templates"]["stencil"] || {};
this["joint"]["templates"]["stencil"]["elements.html"] = Handlebars.template(function(Handlebars, depth0, helpers, partials, data) {
    this.compilerInfo = [4, ">= 1.0.0"];
    helpers = this.merge(helpers, Handlebars.helpers);
    data = data || {};
    return '<div class="elements"></div>\n'
});
this["joint"]["templates"]["stencil"]["group.html"] = Handlebars.template(function(Handlebars, depth0, helpers, partials, data) {
    this.compilerInfo = [4, ">= 1.0.0"];
    helpers = this.merge(helpers, Handlebars.helpers);
    data = data || {};
    var buffer = "", stack1, functionType = "function", escapeExpression = this.escapeExpression;
    buffer += '<div class="group">\n    <h3 class="group-label">';
    if (stack1 = helpers.label) {
        stack1 = stack1.call(depth0, {hash: {},data: data})
    } else {
        stack1 = depth0.label;
        stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1
    }
    buffer += escapeExpression(stack1) + "</h3>\n</div>\n";
    return buffer
});
this["joint"]["templates"]["stencil"]["search.html"] = Handlebars.template(function(Handlebars, depth0, helpers, partials, data) {
    this.compilerInfo = [4, ">= 1.0.0"];
    helpers = this.merge(helpers, Handlebars.helpers);
    data = data || {};
    return '<input class="search" type="search" placeholder="search"/>\n'
});
this["joint"]["templates"]["stencil"]["stencil.html"] = Handlebars.template(function(Handlebars, depth0, helpers, partials, data) {
    this.compilerInfo = [4, ">= 1.0.0"];
    helpers = this.merge(helpers, Handlebars.helpers);
    data = data || {};
    return '<div class="stencil-paper-drag"></div>\n<div class="content"></div>\n\n'
});


joint.ui.Stencil = Backbone.View.extend({
    className: "stencil",
    events: {
        "click .group-label": "onGroupLabelClick",
        "touchstart .group-label": "onGroupLabelClick",
        "input .search": "onSearch"
    },
    options: {
        width: 200,
        height: 800
    },
    initialize: function(options) {
        this.options = _.extend({}, _.result(this, "options"), options || {});
        this.graphs = {};
        this.papers = {};
        this.$groups = {};
        _.bindAll(this, "onDrag", "onDragEnd");
        $(document.body).on({
            "mousemove.stencil touchmove.stencil": this.onDrag,"mouseup.stencil touchend.stencil": this.onDragEnd});
        this.onSearch = _.debounce(this.onSearch, 200)
    },
    render: function() {
    this.$el.html(joint.templates.stencil["stencil.html"](this.template));
    this.$content = this.$(".content");
    if (this.options.search) {
        this.$el.addClass("searchable").prepend(joint.templates.stencil["search.html"]())
    }
    var paperOptions = {width: this.options.width,height: this.options.height,interactive: false};
    if (this.options.groups) {
        var sortedGroups = _.sortBy(_.pairs(this.options.groups), function(pair) {
            return pair[1].index
        });
        _.each(sortedGroups, function(groupArray) {
            var name = groupArray[0];
            var group = groupArray[1];
            var $group = $(joint.templates.stencil["group.html"]({label: group.label || name}));
            $group.attr("data-name", name);
            if (group.closed)
                $group.addClass("closed");
            $group.append($(joint.templates.stencil["elements.html"]()));
            this.$content.append($group);
            this.$groups[name] = $group;
            var graph = new joint.dia.Graph;
            this.graphs[name] = graph;
            var paper = new joint.dia.Paper(_.extend({}, paperOptions, {el: $group.find(".elements"),model: graph,width: group.width || paperOptions.width,height: group.height || paperOptions.height}));
            this.papers[name] = paper
        }, this)
    } else {
        this.$content.append($(joint.templates.stencil["elements.html"]()));
        var graph = new joint.dia.Graph;
        this.graphs["__default__"] = graph;
        var paper = new joint.dia.Paper(_.extend(paperOptions, {el: this.$(".elements"),model: graph}));
        this.papers["__default__"] = paper
    }
    this._graphDrag = new joint.dia.Graph;
    this._paperDrag = new joint.dia.Paper({el: this.$(".stencil-paper-drag"),width: 1,height: 1,model: this._graphDrag});
    _.each(this.papers, function(paper) {
        this.listenTo(paper, "cell:pointerdown", this.onDragStart)
    }, this);
    return this
},
    load: function(cells, group) {
    var graph = this.graphs[group || "__default__"];
    if (graph) {
        graph.resetCells(cells);
        var paperHeight = this.options.height;
        if (group && this.options.groups[group]) {
            paperHeight = this.options.groups[group].height
        }
        if (!paperHeight) {
            this.papers[group || "__default__"].fitToContent(1, 1, this.options.paperPadding || 10)
        }
    } else {
        throw new Error("Stencil: group " + group + " does not exist.")
    }
},
    getGraph: function(group) {
    return this.graphs[group || "__default__"]
},
    getPaper: function(group) {
    return this.papers[group || "__default__"]
},
    onDragStart: function(cellView, evt) {
    this.$el.addClass("dragging");
    this._paperDrag.$el.addClass("dragging");
    $(document.body).append(this._paperDrag.$el);
    this._clone = cellView.model.clone();
    this._cloneBbox = cellView.getBBox();
    var padding = 5;
    var shift = g.point(this._cloneBbox.x - this._clone.get("position").x, this._cloneBbox.y - this._clone.get("position").y);
    this._clone.set("position", {x: -shift.x + padding,y: -shift.y + padding});
    this._graphDrag.addCell(this._clone);
    this._paperDrag.setDimensions(this._cloneBbox.width + 2 * padding, this._cloneBbox.height + 2 * padding);
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
    this._paperDrag.$el.offset({left: evt.clientX - this._cloneBbox.width / 2,top: evt.clientY + scrollTop - this._cloneBbox.height / 2})
},
    onDrag: function(evt) {
    evt = joint.util.normalizeEvent(evt);
    if (this._clone) {
        var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
        this._paperDrag.$el.offset({left: evt.clientX - this._cloneBbox.width / 2,top: evt.clientY + scrollTop - this._cloneBbox.height / 2})
    }
},
    onDragEnd: function(evt) {
    evt = joint.util.normalizeEvent(evt);
    if (this._clone && this._cloneBbox) {
        this.drop(evt, this._clone.clone(), this._cloneBbox);
        this.$el.append(this._paperDrag.$el);
        this.$el.removeClass("dragging");
        this._paperDrag.$el.removeClass("dragging");
        this._clone.remove();
        this._clone = undefined
    }
},
    drop: function(evt, cell, cellViewBBox) {
    var paper = this.options.paper;
    var graph = this.options.graph;
    var paperPosition = paper.$el.offset();
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
    var scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft;
    var paperArea = g.rect(paperPosition.left + parseInt(paper.$el.css("border-left-width"), 10) - scrollLeft, paperPosition.top + parseInt(paper.$el.css("border-top-width"), 10) - scrollTop, paper.$el.innerWidth(), paper.$el.innerHeight());
    var p = paper.svg.createSVGPoint();
    p.x = evt.clientX;
    p.y = evt.clientY;
    if (paperArea.containsPoint(p)) {
        var fakeRect = V("rect", {width: paper.options.width,height: paper.options.height,x: 0,y: 0,opacity: 0});
        V(paper.svg).prepend(fakeRect);
        var paperOffset = $(paper.svg).offset();
        fakeRect.remove();
        p.x += scrollLeft - paperOffset.left;
        p.y += scrollTop - paperOffset.top;
        var pointTransformed = p.matrixTransform(paper.viewport.getCTM().inverse());
        var cellBBox = cell.getBBox();
        pointTransformed.x += cellBBox.x - cellViewBBox.width / 2;
        pointTransformed.y += cellBBox.y - cellViewBBox.height / 2;
        cell.set("position", {x: g.snapToGrid(pointTransformed.x, paper.options.gridSize),y: g.snapToGrid(pointTransformed.y, paper.options.gridSize)});
        cell.unset("z");
        graph.addCell(cell, {stencil: this.cid})
    }
},
    filter: function(keyword, cellAttributesMap) {
    var lowerCaseOnly = keyword.toLowerCase() == keyword;
    var match = _.reduce(this.papers, function(wasMatch, paper, group) {
        var matchedCells = paper.model.get("cells").filter(function(cell) {
            var cellView = paper.findViewByModel(cell);
            var cellMatch = !keyword || _.some(cellAttributesMap, function(paths, type) {
                    if (type != "*" && cell.get("type") != type) {
                        return false
                    }
                    var attributeMatch = _.some(paths, function(path) {
                        var value = joint.util.getByPath(cell.attributes, path, "/");
                        if (_.isUndefined(value) || _.isNull(value)) {
                            return false
                        }
                        value = value.toString();
                        if (lowerCaseOnly) {
                            value = value.toLowerCase()
                        }
                        return value.indexOf(keyword) >= 0
                    });
                    return attributeMatch
                });
            V(cellView.el).toggleClass("unmatched", !cellMatch);
            return cellMatch
        }, this);
        var isMatch = !_.isEmpty(matchedCells);
        var filteredGraph = (new joint.dia.Graph).resetCells(matchedCells);
        this.trigger("filter", filteredGraph, group);
        if (this.$groups[group]) {
            this.$groups[group].toggleClass("unmatched", !isMatch)
        }
        paper.fitToContent(1, 1, this.options.paperPadding || 10);
        return wasMatch || isMatch
    }, false, this);
    this.$el.toggleClass("not-found", !match)
},
    onSearch: function(evt) {
    this.filter(evt.target.value, this.options.search)
},
    onGroupLabelClick: function(evt) {
    evt.preventDefault();
    var $group = $(evt.target).closest(".group");
    this.toggleGroup($group.data("name"))
},
    toggleGroup: function(name) {
    this.$('.group[data-name="' + name + '"]').toggleClass("closed")
},
    closeGroup: function(name) {
    this.$('.group[data-name="' + name + '"]').addClass("closed")
},
    openGroup: function(name) {
    this.$('.group[data-name="' + name + '"]').removeClass("closed")
},
    closeGroups: function() {
    this.$(".group").addClass("closed")
},
    openGroups: function() {
        this.$(".group").removeClass("closed")
    },
    remove: function() {
        Backbone.View.prototype.remove.apply(this, arguments);
        $(document.body).off(".stencil", this.onDrag).off(".stencil", this.onDragEnd)
    }
});


joint.ui.PaperScroller = Backbone.View.extend({className: "paper-scroller",events: {mousedown: "pointerdown",mousemove: "pointermove",touchmove: "pointermove",mouseout: "stopPanning"},options: {paper: undefined,padding: 0,autoResizePaper: false,minWidth: undefined,minHeight: undefined},initialize: function(options) {
    _.bindAll(this, "startPanning", "stopPanning");
    this.options = _.extend({}, _.result(this, "options"), options || {});
    var paper = this.options.paper;
    var initScale = V(paper.viewport).scale();
    this._sx = initScale.sx;
    this._sy = initScale.sy;
    this._baseWidth = paper.options.width;
    this._baseHeight = paper.options.height;
    this.$el.append(paper.el);
    this.addPadding();
    this.listenTo(paper, "scale", this.onScale);
    this.listenTo(paper, "resize", this.onResize);
    if (this.options.autoResizePaper) {
        this.listenTo(paper.model, "change add remove reset", this.adjustPaper)
    }
    $(document.body).on("mouseup.stopPanning touchend.stopPanning", this.stopPanning)
},onResize: function() {
    if (this._center)
        this.center(this._center.x, this._center.y)
},onScale: function(sx, sy, ox, oy) {
    this._sx = sx;
    this._sy = sy;
    this.adjustPaper();
    if (ox || oy)
        this.center(ox, oy)
},beforePaperManipulation: function() {
    this.$el.css("visibility", "hidden")
},afterPaperManipulation: function() {
    this.$el.css("visibility", "visible")
},toLocalPoint: function(x, y) {
    var ctm = this.options.paper.viewport.getCTM();
    x += this.el.scrollLeft - this.padding.paddingLeft - ctm.e;
    x /= ctm.a;
    y += this.el.scrollTop - this.padding.paddingTop - ctm.f;
    y /= ctm.d;
    return g.point(x, y)
},adjustPaper: function() {
    this._center = this.toLocalPoint(this.el.clientWidth / 2, this.el.clientHeight / 2);
    var sx = this._sx;
    var sy = this._sy;
    var options = {gridWidth: this._baseWidth * sx,gridHeight: this._baseHeight * sy,allowNewOrigin: "negative"};
    if (this.options.minWidth) {
        options.minWidth = this.options.minWidth * sx
    }
    if (this.options.minHeight) {
        options.minHeight = this.options.minHeight * sy
    }
    this.options.paper.fitToContent(options);
    return this
},center: function(x, y) {
    var ctm = this.options.paper.viewport.getCTM();
    var x1 = -ctm.e;
    var y1 = -ctm.f;
    var x2 = x1 + this.options.paper.options.width;
    var y2 = y1 + this.options.paper.options.height;
    if (_.isUndefined(x) || _.isUndefined(y)) {
        x = (x1 + x2) / 2;
        y = (y1 + y2) / 2
    } else {
        x *= ctm.a;
        y *= ctm.d
    }
    var p = this.options.padding;
    var cx = this.el.clientWidth / 2;
    var cy = this.el.clientHeight / 2;
    var left = cx - p - x + x1;
    var right = cx - p + x - x2;
    var top = cy - p - y + y1;
    var bottom = cy - p + y - y2;
    this.addPadding(Math.max(left, 0), Math.max(right, 0), Math.max(top, 0), Math.max(bottom, 0));
    this.el.scrollLeft = x - cx + ctm.e + this.padding.paddingLeft;
    this.el.scrollTop = y - cy + ctm.f + this.padding.paddingTop;
    return this
},centerContent: function() {
    var vbox = V(this.options.paper.viewport).bbox(true, this.options.paper.svg);
    this.center(vbox.x + vbox.width / 2, vbox.y + vbox.height / 2);
    return this
},addPadding: function(left, right, top, bottom) {
    var base = this.options.padding;
    var padding = this.padding = {paddingLeft: Math.round(base + (left || 0)),paddingTop: Math.round(base + (top || 0))};
    var margin = {marginBottom: Math.round(base + (bottom || 0)),marginRight: Math.round(base + (right || 0))};
    padding.paddingLeft = Math.min(padding.paddingLeft, this.el.clientWidth * .9);
    padding.paddingTop = Math.min(padding.paddingTop, this.el.clientHeight * .9);
    this.$el.css(padding);
    this.options.paper.$el.css(margin);
    return this
},zoom: function(value, opt) {
    opt = opt || {};
    var center = this.toLocalPoint(this.el.clientWidth / 2, this.el.clientHeight / 2);
    var sx = value;
    var sy = value;
    var ox;
    var oy;
    if (!opt.absolute) {
        sx += this._sx;
        sy += this._sy
    }
    if (opt.grid) {
        sx = Math.round(sx / opt.grid) * opt.grid;
        sy = Math.round(sy / opt.grid) * opt.grid
    }
    if (opt.max) {
        sx = Math.min(opt.max, sx);
        sy = Math.min(opt.max, sy)
    }
    if (opt.min) {
        sx = Math.max(opt.min, sx);
        sy = Math.max(opt.min, sy)
    }
    if (_.isUndefined(opt.ox) || _.isUndefined(opt.oy)) {
        ox = center.x;
        oy = center.y
    } else {
        var fsx = sx / this._sx;
        var fsy = sy / this._sy;
        ox = opt.ox - (opt.ox - center.x) / fsx;
        oy = opt.oy - (opt.oy - center.y) / fsy
    }
    this.beforePaperManipulation();
    this.options.paper.scale(sx, sy);
    this.center(ox, oy);
    this.afterPaperManipulation();
    return this
},zoomToFit: function(opt) {
    opt = opt || {};
    var paper = this.options.paper;
    var paperOrigin = _.clone(paper.options.origin);
    opt.fittingBBox = opt.fittingBBox || _.extend({}, g.point(paperOrigin), {width: this.$el.width() + this.padding.paddingLeft,height: this.$el.height() + this.padding.paddingTop});
    this.beforePaperManipulation();
    paper.scaleContentToFit(opt);
    paper.setOrigin(paperOrigin.x, paperOrigin.y);
    this.adjustPaper().centerContent();
    this.afterPaperManipulation();
    return this
},startPanning: function(evt) {
    evt = joint.util.normalizeEvent(evt);
    this._panning = true;
    this._clientX = evt.clientX;
    this._clientY = evt.clientY
},pan: function(evt) {
    if (!this._panning)
        return;
    evt = joint.util.normalizeEvent(evt);
    var dx = evt.clientX - this._clientX;
    var dy = evt.clientY - this._clientY;
    this.el.scrollTop -= dy;
    this.el.scrollLeft -= dx;
    this._clientX = evt.clientX;
    this._clientY = evt.clientY
},stopPanning: function() {
    delete this._panning
},pointerdown: function(evt) {
    if (evt.target == this.el) {
        this.options.paper.pointerdown.apply(this.options.paper, arguments)
    }
},pointermove: function(evt) {
    this.pan.apply(this, arguments);
    if (evt.target == this.el) {
        this.options.paper.pointermove.apply(this.options.paper, arguments)
    }
},remove: function() {
    Backbone.View.prototype.remove.apply(this, arguments);
    $(document.body).off(".stopPanning", this.stopPanning)
}});
joint.ui.Tooltip = Backbone.View.extend({className: "tooltip",options: {left: undefined,right: undefined,top: undefined,bottom: undefined,padding: 10,target: undefined,rootTarget: undefined},initialize: function(options) {
    this.options = _.extend({}, _.result(this, "options"), options || {});
    _.bindAll(this, "render", "hide", "position");
    if (this.options.rootTarget) {
        this.$rootTarget = $(this.options.rootTarget);
        this.$rootTarget.on("mouseover", this.options.target, this.render);
        this.$rootTarget.on("mouseout", this.options.target, this.hide);
        this.$rootTarget.on("mousedown", this.options.target, this.hide)
    } else {
        this.$target = $(this.options.target);
        this.$target.on("mouseover", this.render);
        this.$target.on("mouseout", this.hide);
        this.$target.on("mousedown", this.hide)
    }
    this.$el.addClass(this.options.direction)
},remove: function() {
    this.$target.off("mouseover", this.render);
    this.$target.off("mouseout", this.hide);
    this.$target.off("mousedown", this.hide);
    Backbone.View.prototype.remove.apply(this, arguments)
},hide: function() {
    Backbone.View.prototype.remove.apply(this, arguments)
},render: function(evt) {
    var target;
    var isPoint = !_.isUndefined(evt.x) && !_.isUndefined(evt.y);
    if (isPoint) {
        target = evt
    } else {
        this.$target = $(evt.target).closest(this.options.target);
        target = this.$target[0]
    }
    this.$el.html(_.isFunction(this.options.content) ? this.options.content(target) : this.options.content);
    this.$el.hide();
    $(document.body).append(this.$el);
    var $images = this.$("img");
    if ($images.length) {
        $images.on("load", _.bind(function() {
            this.position(isPoint ? target : undefined)
        }, this))
    } else {
        this.position(isPoint ? target : undefined)
    }
},getElementBBox: function(el) {
    var $el = $(el);
    var offset = $el.offset();
    var bbox;
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
    var scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft;
    offset.top -= scrollTop || 0;
    offset.left -= scrollLeft || 0;
    if (el.ownerSVGElement) {
        bbox = V(el).bbox();
        var crect = el.getBoundingClientRect();
        var strokeWidthX = (crect.width - bbox.width) / 2;
        var strokeWidthY = (crect.height - bbox.height) / 2;
        bbox.x = offset.left + strokeWidthX;
        bbox.y = offset.top + strokeWidthY
    } else {
        bbox = {x: offset.left,y: offset.top,width: $el.outerWidth(),height: $el.outerHeight()}
    }
    return bbox
},position: function(p) {
    var bbox;
    if (p) {
        bbox = {x: p.x,y: p.y,width: 1,height: 1}
    } else {
        bbox = this.getElementBBox(this.$target[0])
    }
    var padding = this.options.padding;
    this.$el.show();
    var height = this.$el.outerHeight();
    var width = this.$el.outerWidth();
    if (this.options.left) {
        var $left = $(_.isFunction(this.options.left) ? this.options.left(this.$target[0]) : this.options.left);
        var leftBbox = this.getElementBBox($left[0]);
        this.$el.css({left: leftBbox.x + leftBbox.width + padding,top: bbox.y + bbox.height / 2 - height / 2})
    } else if (this.options.right) {
        var $right = $(_.isFunction(this.options.right) ? this.options.right(this.$target[0]) : this.options.right);
        var rightBbox = this.getElementBBox($right[0]);
        this.$el.css({left: rightBbox.x - width - padding,top: bbox.y + bbox.height / 2 - height / 2})
    } else if (this.options.top) {
        var $top = $(_.isFunction(this.options.top) ? this.options.top(this.$target[0]) : this.options.top);
        var topBbox = this.getElementBBox($top[0]);
        this.$el.css({top: topBbox.y + topBbox.height + padding,left: bbox.x + bbox.width / 2 - width / 2})
    } else if (this.options.bottom) {
        var $bottom = $(_.isFunction(this.options.bottom) ? this.options.bottom(this.$target[0]) : this.options.bottom);
        var bottomBbox = this.getElementBBox($bottom[0]);
        this.$el.css({top: bottomBbox.y - height - padding,left: bbox.x + bbox.width / 2 - width / 2})
    } else {
        this.$el.css({left: bbox.x + bbox.width + padding,top: bbox.y + bbox.height / 2 - height / 2})
    }
}});
joint.ui.Snaplines = Backbone.View.extend({options: {paper: undefined,distance: 10},className: "snaplines",initialize: function(options) {
    this.options = _.extend({}, _.result(this, "options"), options || {});
    this.$horizontal = $("<div>").addClass("snapline horizontal").appendTo(this.el);
    this.$vertical = $("<div>").addClass("snapline vertical").appendTo(this.el);
    this.$el.hide().appendTo(this.options.paper.el);
    this.startListening()
},startListening: function() {
    this.stopListening();
    this.listenTo(this.options.paper, "cell:pointerdown", this.startSnapping);
    this.listenTo(this.options.paper, "cell:pointermove", this.snap);
    this.listenTo(this.options.paper, "cell:pointerup", this.hide);
    this.filterTypes = {};
    this.filterCells = {};
    this.filterFunction = undefined;
    if (_.isArray(this.options.filter)) {
        _.each(this.options.filter, function(item) {
            if (_.isString(item)) {
                this.filterTypes[item] = true
            } else {
                this.filterCells[item.id] = true
            }
        }, this)
    } else if (_.isFunction(this.options.filter)) {
        this.filterFunction = this.options.filter
    }
},startSnapping: function(cellView, evt, x, y) {
    if (cellView instanceof joint.dia.LinkView)
        return;
    var position = cellView.model.get("position");
    this._diffX = x - position.x;
    this._diffY = y - position.y
},snap: function(cellView, evt, x, y) {
    if (cellView instanceof joint.dia.LinkView)
        return;
    var cell = cellView.model;
    var cellBBox = g.rect(_.extend({x: x - this._diffX,y: y - this._diffY}, cell.get("size")));
    var cellCenter = cellBBox.center();
    var cellBBoxRotated = cellBBox.bbox(cell.get("angle"));
    var cellTopLeft = cellBBoxRotated.origin();
    var cellBottomRight = cellBBoxRotated.corner();
    var distance = this.options.distance;
    var vertical = null;
    var horizontal = null;
    var verticalFix = 0;
    var horizontalFix = 0;
    _.find(this.options.paper.model.getElements(), function(element) {
        if (element === cell || element.isEmbeddedIn(cell) || this.filterTypes[element.get("type")] || this.filterCells[element.id] || this.filterFunction && this.filterFunction(element)) {
            return false
        }
        var snapBBox = element.getBBox().bbox(element.get("angle"));
        var snapCenter = snapBBox.center();
        var snapTopLeft = snapBBox.origin();
        var snapBottomRight = snapBBox.corner();
        if (_.isNull(vertical)) {
            if (Math.abs(snapCenter.x - cellCenter.x) < distance) {
                vertical = snapCenter.x;
                verticalFix = .5
            } else if (Math.abs(snapTopLeft.x - cellTopLeft.x) < distance) {
                vertical = snapTopLeft.x
            } else if (Math.abs(snapTopLeft.x - cellBottomRight.x) < distance) {
                vertical = snapTopLeft.x;
                verticalFix = 1
            } else if (Math.abs(snapBottomRight.x - cellBottomRight.x) < distance) {
                vertical = snapBottomRight.x;
                verticalFix = 1
            } else if (Math.abs(snapBottomRight.x - cellTopLeft.x) < distance) {
                vertical = snapBottomRight.x
            }
        }
        if (_.isNull(horizontal)) {
            if (Math.abs(snapCenter.y - cellCenter.y) < distance) {
                horizontal = snapCenter.y;
                horizontalFix = .5
            } else if (Math.abs(snapTopLeft.y - cellTopLeft.y) < distance) {
                horizontal = snapTopLeft.y
            } else if (Math.abs(snapTopLeft.y - cellBottomRight.y) < distance) {
                horizontal = snapTopLeft.y;
                horizontalFix = 1
            } else if (Math.abs(snapBottomRight.y - cellBottomRight.y) < distance) {
                horizontal = snapBottomRight.y;
                horizontalFix = 1
            } else if (Math.abs(snapBottomRight.y - cellTopLeft.y) < distance) {
                horizontal = snapBottomRight.y
            }
        }
        return _.isNumber(vertical) && _.isNumber(horizontal)
    }, this);
    this.hide();
    if (_.isNumber(vertical) || _.isNumber(horizontal)) {
        if (_.isNumber(vertical)) {
            cellBBoxRotated.x = vertical - verticalFix * cellBBoxRotated.width
        }
        if (_.isNumber(horizontal)) {
            cellBBoxRotated.y = horizontal - horizontalFix * cellBBoxRotated.height
        }
        var newCellCenter = cellBBoxRotated.center();
        var newX = newCellCenter.x - cellBBox.width / 2;
        var newY = newCellCenter.y - cellBBox.height / 2;
        var cellPosition = cell.get("position");
        cell.translate(newX - cellPosition.x, newY - cellPosition.y);
        this.show({vertical: vertical,horizontal: horizontal})
    }
},show: function(opt) {
    opt = opt || {};
    var ctm = this.options.paper.viewport.getCTM();
    if (opt.horizontal) {
        this.$horizontal.css("top", opt.horizontal * ctm.d + ctm.f).show()
    } else {
        this.$horizontal.hide()
    }
    if (opt.vertical) {
        this.$vertical.css("left", opt.vertical * ctm.a + ctm.e).show()
    } else {
        this.$vertical.hide()
    }
    this.$el.show()
},hide: function() {
    this.$el.hide()
}});
joint.dia.Paper.prototype.toSVG = function(callback, opt) {
    opt = opt || {};
    var viewportTransform = V(this.viewport).attr("transform");
    V(this.viewport).attr("transform", "");
    var viewportBbox = this.getContentBBox();
    var svgClone = this.svg.cloneNode(true);
    V(this.viewport).attr("transform", viewportTransform || "");
    svgClone.removeAttribute("style");
    if (opt.preserveDimensions) {
        V(svgClone).attr({width: viewportBbox.width,height: viewportBbox.height})
    } else {
        V(svgClone).attr({width: "100%",height: "100%"})
    }
    V(svgClone).attr("viewBox", viewportBbox.x + " " + viewportBbox.y + " " + viewportBbox.width + " " + viewportBbox.height);
    var styleSheetsCount = document.styleSheets.length;
    var styleSheetsCopy = [];
    for (var i = styleSheetsCount - 1; i >= 0; i--) {
        styleSheetsCopy[i] = document.styleSheets[i];
        document.styleSheets[i].disabled = true
    }
    var defaultComputedStyles = {};
    $(this.svg).find("*").each(function(idx) {
        var computedStyle = window.getComputedStyle(this, null);
        var defaultComputedStyle = {};
        _.each(computedStyle, function(property) {
            defaultComputedStyle[property] = computedStyle.getPropertyValue(property)
        });
        defaultComputedStyles[idx] = defaultComputedStyle
    });
    if (styleSheetsCount != document.styleSheets.length) {
        _.each(styleSheetsCopy, function(copy, i) {
            document.styleSheets[i] = copy
        })
    }
    for (var i = 0; i < styleSheetsCount; i++) {
        document.styleSheets[i].disabled = false
    }
    var customStyles = {};
    $(this.svg).find("*").each(function(idx) {
        var computedStyle = window.getComputedStyle(this, null);
        var defaultComputedStyle = defaultComputedStyles[idx];
        var customStyle = {};
        _.each(computedStyle, function(property) {
            if (computedStyle.getPropertyValue(property) !== defaultComputedStyle[property]) {
                customStyle[property] = computedStyle.getPropertyValue(property)
            }
        });
        customStyles[idx] = customStyle
    });
    var images = [];
    $(svgClone).find("*").each(function(idx) {
        $(this).css(customStyles[idx]);
        if (this.tagName.toLowerCase() === "image") {
            images.push(this)
        }
    });
    function serialize() {
        return (new XMLSerializer).serializeToString(svgClone)
    }
    if (opt.convertImagesToDataUris && images.length) {
        function convertImages(done) {
            var image = V(images.shift());
            if (!image)
                return done();
            var url = image.attr("xlink:href") || image.attr("href");
            joint.util.imageToDataUri(url, function(err, dataUri) {
                image.attr("xlink:href", dataUri);
                convertImages(done)
            })
        }
        convertImages(function() {
            callback(serialize())
        })
    } else {
        return callback(serialize())
    }
};
joint.dia.Paper.prototype.openAsSVG = function(opt) {
    var windowFeatures = "menubar=yes,location=yes,resizable=yes,scrollbars=yes,status=yes";
    var windowName = _.uniqueId("svg_output");
    this.toSVG(function(svg) {
        var imageWindow = window.open("", windowName, windowFeatures);
        var dataImageUri = "data:image/svg+xml," + encodeURIComponent(svg);
        imageWindow.document.write('<img src="' + dataImageUri + '" style="max-height:100%" />')
    }, _.extend({convertImagesToDataUris: true}, opt))
};
(function() {
    this.canvg = function(target, s, opts) {
        if (target == null && s == null && opts == null) {
            var svgTags = document.querySelectorAll("svg");
            for (var i = 0; i < svgTags.length; i++) {
                var svgTag = svgTags[i];
                var c = document.createElement("canvas");
                c.width = svgTag.clientWidth;
                c.height = svgTag.clientHeight;
                svgTag.parentNode.insertBefore(c, svgTag);
                svgTag.parentNode.removeChild(svgTag);
                var div = document.createElement("div");
                div.appendChild(svgTag);
                canvg(c, div.innerHTML)
            }
            return
        }
        if (typeof target == "string") {
            target = document.getElementById(target)
        }
        if (target.svg != null)
            target.svg.stop();
        var svg = build(opts || {});
        if (!(target.childNodes.length == 1 && target.childNodes[0].nodeName == "OBJECT"))
            target.svg = svg;
        var ctx = target.getContext("2d");
        if (typeof s.documentElement != "undefined") {
            svg.loadXmlDoc(ctx, s)
        } else if (s.substr(0, 1) == "<") {
            svg.loadXml(ctx, s)
        } else {
            svg.load(ctx, s)
        }
    };
    function build(opts) {
        var svg = {opts: opts};
        svg.FRAMERATE = 30;
        svg.MAX_VIRTUAL_PIXELS = 3e4;
        svg.log = function(msg) {
        };
        if (svg.opts["log"] == true && typeof console != "undefined") {
            svg.log = function(msg) {
                console.log(msg)
            }
        }
        svg.init = function(ctx) {
            var uniqueId = 0;
            svg.UniqueId = function() {
                uniqueId++;
                return "canvg" + uniqueId
            };
            svg.Definitions = {};
            svg.Styles = {};
            svg.Animations = [];
            svg.Images = [];
            svg.ctx = ctx;
            svg.ViewPort = new function() {
                this.viewPorts = [];
                this.Clear = function() {
                    this.viewPorts = []
                };
                this.SetCurrent = function(width, height) {
                    this.viewPorts.push({width: width,height: height})
                };
                this.RemoveCurrent = function() {
                    this.viewPorts.pop()
                };
                this.Current = function() {
                    return this.viewPorts[this.viewPorts.length - 1]
                };
                this.width = function() {
                    return this.Current().width
                };
                this.height = function() {
                    return this.Current().height
                };
                this.ComputeSize = function(d) {
                    if (d != null && typeof d == "number")
                        return d;
                    if (d == "x")
                        return this.width();
                    if (d == "y")
                        return this.height();
                    return Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2)
                }
            }
        };
        svg.init();
        svg.ImagesLoaded = function() {
            for (var i = 0; i < svg.Images.length; i++) {
                if (!svg.Images[i].loaded)
                    return false
            }
            return true
        };
        svg.trim = function(s) {
            return s.replace(/^\s+|\s+$/g, "")
        };
        svg.compressSpaces = function(s) {
            return s.replace(/[\s\r\t\n]+/gm, " ")
        };
        svg.ajax = function(url) {
            var AJAX;
            if (window.XMLHttpRequest) {
                AJAX = new XMLHttpRequest
            } else {
                AJAX = new ActiveXObject("Microsoft.XMLHTTP")
            }
            if (AJAX) {
                AJAX.open("GET", url, false);
                AJAX.send(null);
                return AJAX.responseText
            }
            return null
        };
        svg.parseXml = function(xml) {
            if (typeof Windows != "undefined" && typeof Windows.Data != "undefined" && typeof Windows.Data.Xml != "undefined") {
                var xmlDoc = new Windows.Data.Xml.Dom.XmlDocument;
                var settings = new Windows.Data.Xml.Dom.XmlLoadSettings;
                settings.prohibitDtd = false;
                xmlDoc.loadXml(xml, settings);
                return xmlDoc
            } else if (window.DOMParser) {
                var parser = new DOMParser;
                return parser.parseFromString(xml, "text/xml")
            } else {
                xml = xml.replace(/<!DOCTYPE svg[^>]*>/, "");
                var xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                xmlDoc.async = "false";
                xmlDoc.loadXML(xml);
                return xmlDoc
            }
        };
        svg.Property = function(name, value) {
            this.name = name;
            this.value = value
        };
        svg.Property.prototype.getValue = function() {
            return this.value
        };
        svg.Property.prototype.hasValue = function() {
            return this.value != null && this.value !== ""
        };
        svg.Property.prototype.numValue = function() {
            if (!this.hasValue())
                return 0;
            var n = parseFloat(this.value);
            if ((this.value + "").match(/%$/)) {
                n = n / 100
            }
            return n
        };
        svg.Property.prototype.valueOrDefault = function(def) {
            if (this.hasValue())
                return this.value;
            return def
        };
        svg.Property.prototype.numValueOrDefault = function(def) {
            if (this.hasValue())
                return this.numValue();
            return def
        };
        svg.Property.prototype.addOpacity = function(opacityProp) {
            var newValue = this.value;
            if (opacityProp.value != null && opacityProp.value != "" && typeof this.value == "string") {
                var color = new RGBColor(this.value);
                if (color.ok) {
                    newValue = "rgba(" + color.r + ", " + color.g + ", " + color.b + ", " + opacityProp.numValue() + ")"
                }
            }
            return new svg.Property(this.name, newValue)
        };
        svg.Property.prototype.getDefinition = function() {
            var name = this.value.match(/#([^\)'"]+)/);
            if (name) {
                name = name[1]
            }
            if (!name) {
                name = this.value
            }
            return svg.Definitions[name]
        };
        svg.Property.prototype.isUrlDefinition = function() {
            return this.value.indexOf("url(") == 0
        };
        svg.Property.prototype.getFillStyleDefinition = function(e, opacityProp) {
            var def = this.getDefinition();
            if (def != null && def.createGradient) {
                return def.createGradient(svg.ctx, e, opacityProp)
            }
            if (def != null && def.createPattern) {
                if (def.getHrefAttribute().hasValue()) {
                    var pt = def.attribute("patternTransform");
                    def = def.getHrefAttribute().getDefinition();
                    if (pt.hasValue()) {
                        def.attribute("patternTransform", true).value = pt.value
                    }
                }
                return def.createPattern(svg.ctx, e)
            }
            return null
        };
        svg.Property.prototype.getDPI = function(viewPort) {
            return 96
        };
        svg.Property.prototype.getEM = function(viewPort) {
            var em = 12;
            var fontSize = new svg.Property("fontSize", svg.Font.Parse(svg.ctx.font).fontSize);
            if (fontSize.hasValue())
                em = fontSize.toPixels(viewPort);
            return em
        };
        svg.Property.prototype.getUnits = function() {
            var s = this.value + "";
            return s.replace(/[0-9\.\-]/g, "")
        };
        svg.Property.prototype.toPixels = function(viewPort, processPercent) {
            if (!this.hasValue())
                return 0;
            var s = this.value + "";
            if (s.match(/em$/))
                return this.numValue() * this.getEM(viewPort);
            if (s.match(/ex$/))
                return this.numValue() * this.getEM(viewPort) / 2;
            if (s.match(/px$/))
                return this.numValue();
            if (s.match(/pt$/))
                return this.numValue() * this.getDPI(viewPort) * (1 / 72);
            if (s.match(/pc$/))
                return this.numValue() * 15;
            if (s.match(/cm$/))
                return this.numValue() * this.getDPI(viewPort) / 2.54;
            if (s.match(/mm$/))
                return this.numValue() * this.getDPI(viewPort) / 25.4;
            if (s.match(/in$/))
                return this.numValue() * this.getDPI(viewPort);
            if (s.match(/%$/))
                return this.numValue() * svg.ViewPort.ComputeSize(viewPort);
            var n = this.numValue();
            if (processPercent && n < 1)
                return n * svg.ViewPort.ComputeSize(viewPort);
            return n
        };
        svg.Property.prototype.toMilliseconds = function() {
            if (!this.hasValue())
                return 0;
            var s = this.value + "";
            if (s.match(/s$/))
                return this.numValue() * 1e3;
            if (s.match(/ms$/))
                return this.numValue();
            return this.numValue()
        };
        svg.Property.prototype.toRadians = function() {
            if (!this.hasValue())
                return 0;
            var s = this.value + "";
            if (s.match(/deg$/))
                return this.numValue() * (Math.PI / 180);
            if (s.match(/grad$/))
                return this.numValue() * (Math.PI / 200);
            if (s.match(/rad$/))
                return this.numValue();
            return this.numValue() * (Math.PI / 180)
        };
        var textBaselineMapping = {baseline: "alphabetic","before-edge": "top","text-before-edge": "top",middle: "middle",central: "middle","after-edge": "bottom","text-after-edge": "bottom",ideographic: "ideographic",alphabetic: "alphabetic",hanging: "hanging",mathematical: "alphabetic"};
        svg.Property.prototype.toTextBaseline = function() {
            if (!this.hasValue())
                return null;
            return textBaselineMapping[this.value]
        };
        svg.Font = new function() {
            this.Styles = "normal|italic|oblique|inherit";
            this.Variants = "normal|small-caps|inherit";
            this.Weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit";
            this.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
                var f = inherit != null ? this.Parse(inherit) : this.CreateFont("", "", "", "", "", svg.ctx.font);
                return {fontFamily: fontFamily || f.fontFamily,fontSize: fontSize || f.fontSize,fontStyle: fontStyle || f.fontStyle,fontWeight: fontWeight || f.fontWeight,fontVariant: fontVariant || f.fontVariant,toString: function() {
                    return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(" ")
                }}
            };
            var that = this;
            this.Parse = function(s) {
                var f = {};
                var d = svg.trim(svg.compressSpaces(s || "")).split(" ");
                var set = {fontSize: false,fontStyle: false,fontWeight: false,fontVariant: false};
                var ff = "";
                for (var i = 0; i < d.length; i++) {
                    if (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) {
                        if (d[i] != "inherit")
                            f.fontStyle = d[i];
                        set.fontStyle = true
                    } else if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) {
                        if (d[i] != "inherit")
                            f.fontVariant = d[i];
                        set.fontStyle = set.fontVariant = true
                    } else if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) {
                        if (d[i] != "inherit")
                            f.fontWeight = d[i];
                        set.fontStyle = set.fontVariant = set.fontWeight = true
                    } else if (!set.fontSize) {
                        if (d[i] != "inherit")
                            f.fontSize = d[i].split("/")[0];
                        set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true
                    } else {
                        if (d[i] != "inherit")
                            ff += d[i]
                    }
                }
                if (ff != "")
                    f.fontFamily = ff;
                return f
            }
        };
        svg.ToNumberArray = function(s) {
            var a = svg.trim(svg.compressSpaces((s || "").replace(/,/g, " "))).split(" ");
            for (var i = 0; i < a.length; i++) {
                a[i] = parseFloat(a[i])
            }
            return a
        };
        svg.Point = function(x, y) {
            this.x = x;
            this.y = y
        };
        svg.Point.prototype.angleTo = function(p) {
            return Math.atan2(p.y - this.y, p.x - this.x)
        };
        svg.Point.prototype.applyTransform = function(v) {
            var xp = this.x * v[0] + this.y * v[2] + v[4];
            var yp = this.x * v[1] + this.y * v[3] + v[5];
            this.x = xp;
            this.y = yp
        };
        svg.CreatePoint = function(s) {
            var a = svg.ToNumberArray(s);
            return new svg.Point(a[0], a[1])
        };
        svg.CreatePath = function(s) {
            var a = svg.ToNumberArray(s);
            var path = [];
            for (var i = 0; i < a.length; i += 2) {
                path.push(new svg.Point(a[i], a[i + 1]))
            }
            return path
        };
        svg.BoundingBox = function(x1, y1, x2, y2) {
            this.x1 = Number.NaN;
            this.y1 = Number.NaN;
            this.x2 = Number.NaN;
            this.y2 = Number.NaN;
            this.x = function() {
                return this.x1
            };
            this.y = function() {
                return this.y1
            };
            this.width = function() {
                return this.x2 - this.x1
            };
            this.height = function() {
                return this.y2 - this.y1
            };
            this.addPoint = function(x, y) {
                if (x != null) {
                    if (isNaN(this.x1) || isNaN(this.x2)) {
                        this.x1 = x;
                        this.x2 = x
                    }
                    if (x < this.x1)
                        this.x1 = x;
                    if (x > this.x2)
                        this.x2 = x
                }
                if (y != null) {
                    if (isNaN(this.y1) || isNaN(this.y2)) {
                        this.y1 = y;
                        this.y2 = y
                    }
                    if (y < this.y1)
                        this.y1 = y;
                    if (y > this.y2)
                        this.y2 = y
                }
            };
            this.addX = function(x) {
                this.addPoint(x, null)
            };
            this.addY = function(y) {
                this.addPoint(null, y)
            };
            this.addBoundingBox = function(bb) {
                this.addPoint(bb.x1, bb.y1);
                this.addPoint(bb.x2, bb.y2)
            };
            this.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y) {
                var cp1x = p0x + 2 / 3 * (p1x - p0x);
                var cp1y = p0y + 2 / 3 * (p1y - p0y);
                var cp2x = cp1x + 1 / 3 * (p2x - p0x);
                var cp2y = cp1y + 1 / 3 * (p2y - p0y);
                this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y)
            };
            this.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
                var p0 = [p0x, p0y], p1 = [p1x, p1y], p2 = [p2x, p2y], p3 = [p3x, p3y];
                this.addPoint(p0[0], p0[1]);
                this.addPoint(p3[0], p3[1]);
                for (i = 0; i <= 1; i++) {
                    var f = function(t) {
                        return Math.pow(1 - t, 3) * p0[i] + 3 * Math.pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * Math.pow(t, 2) * p2[i] + Math.pow(t, 3) * p3[i]
                    };
                    var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
                    var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
                    var c = 3 * p1[i] - 3 * p0[i];
                    if (a == 0) {
                        if (b == 0)
                            continue;
                        var t = -c / b;
                        if (0 < t && t < 1) {
                            if (i == 0)
                                this.addX(f(t));
                            if (i == 1)
                                this.addY(f(t))
                        }
                        continue
                    }
                    var b2ac = Math.pow(b, 2) - 4 * c * a;
                    if (b2ac < 0)
                        continue;
                    var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t1 && t1 < 1) {
                        if (i == 0)
                            this.addX(f(t1));
                        if (i == 1)
                            this.addY(f(t1))
                    }
                    var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t2 && t2 < 1) {
                        if (i == 0)
                            this.addX(f(t2));
                        if (i == 1)
                            this.addY(f(t2))
                    }
                }
            };
            this.isPointInBox = function(x, y) {
                return this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2
            };
            this.addPoint(x1, y1);
            this.addPoint(x2, y2)
        };
        svg.Transform = function(v) {
            var that = this;
            this.Type = {};
            this.Type.translate = function(s) {
                this.p = svg.CreatePoint(s);
                this.apply = function(ctx) {
                    ctx.translate(this.p.x || 0, this.p.y || 0)
                };
                this.unapply = function(ctx) {
                    ctx.translate(-1 * this.p.x || 0, -1 * this.p.y || 0)
                };
                this.applyToPoint = function(p) {
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0, this.p.y || 0])
                }
            };
            this.Type.rotate = function(s) {
                var a = svg.ToNumberArray(s);
                this.angle = new svg.Property("angle", a[0]);
                this.cx = a[1] || 0;
                this.cy = a[2] || 0;
                this.apply = function(ctx) {
                    ctx.translate(this.cx, this.cy);
                    ctx.rotate(this.angle.toRadians());
                    ctx.translate(-this.cx, -this.cy)
                };
                this.unapply = function(ctx) {
                    ctx.translate(this.cx, this.cy);
                    ctx.rotate(-1 * this.angle.toRadians());
                    ctx.translate(-this.cx, -this.cy)
                };
                this.applyToPoint = function(p) {
                    var a = this.angle.toRadians();
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0, this.p.y || 0]);
                    p.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);
                    p.applyTransform([1, 0, 0, 1, -this.p.x || 0, -this.p.y || 0])
                }
            };
            this.Type.scale = function(s) {
                this.p = svg.CreatePoint(s);
                this.apply = function(ctx) {
                    ctx.scale(this.p.x || 1, this.p.y || this.p.x || 1)
                };
                this.unapply = function(ctx) {
                    ctx.scale(1 / this.p.x || 1, 1 / this.p.y || this.p.x || 1)
                };
                this.applyToPoint = function(p) {
                    p.applyTransform([this.p.x || 0, 0, 0, this.p.y || 0, 0, 0])
                }
            };
            this.Type.matrix = function(s) {
                this.m = svg.ToNumberArray(s);
                this.apply = function(ctx) {
                    ctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5])
                };
                this.unapply = function(ctx) {
                    var a = this.m[0];
                    var b = this.m[2];
                    var c = this.m[4];
                    var d = this.m[1];
                    var e = this.m[3];
                    var f = this.m[5];
                    var g = 0;
                    var h = 0;
                    var i = 1;
                    var det = 1 / (a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g));
                    ctx.transform(det * (e * i - f * h), det * (f * g - d * i), det * (c * h - b * i), det * (a * i - c * g), det * (b * f - c * e), det * (c * d - a * f))
                };
                this.applyToPoint = function(p) {
                    p.applyTransform(this.m)
                }
            };
            this.Type.SkewBase = function(s) {
                this.base = that.Type.matrix;
                this.base(s);
                this.angle = new svg.Property("angle", s)
            };
            this.Type.SkewBase.prototype = new this.Type.matrix;
            this.Type.skewX = function(s) {
                this.base = that.Type.SkewBase;
                this.base(s);
                this.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0]
            };
            this.Type.skewX.prototype = new this.Type.SkewBase;
            this.Type.skewY = function(s) {
                this.base = that.Type.SkewBase;
                this.base(s);
                this.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0]
            };
            this.Type.skewY.prototype = new this.Type.SkewBase;
            this.transforms = [];
            this.apply = function(ctx) {
                for (var i = 0; i < this.transforms.length; i++) {
                    this.transforms[i].apply(ctx)
                }
            };
            this.unapply = function(ctx) {
                for (var i = this.transforms.length - 1; i >= 0; i--) {
                    this.transforms[i].unapply(ctx)
                }
            };
            this.applyToPoint = function(p) {
                for (var i = 0; i < this.transforms.length; i++) {
                    this.transforms[i].applyToPoint(p)
                }
            };
            var data = svg.trim(svg.compressSpaces(v)).replace(/\)([a-zA-Z])/g, ") $1").replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/);
            for (var i = 0; i < data.length; i++) {
                var type = svg.trim(data[i].split("(")[0]);
                var s = data[i].split("(")[1].replace(")", "");
                var transform = new this.Type[type](s);
                transform.type = type;
                this.transforms.push(transform)
            }
        };
        svg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {
            aspectRatio = svg.compressSpaces(aspectRatio);
            aspectRatio = aspectRatio.replace(/^defer\s/, "");
            var align = aspectRatio.split(" ")[0] || "xMidYMid";
            var meetOrSlice = aspectRatio.split(" ")[1] || "meet";
            var scaleX = width / desiredWidth;
            var scaleY = height / desiredHeight;
            var scaleMin = Math.min(scaleX, scaleY);
            var scaleMax = Math.max(scaleX, scaleY);
            if (meetOrSlice == "meet") {
                desiredWidth *= scaleMin;
                desiredHeight *= scaleMin
            }
            if (meetOrSlice == "slice") {
                desiredWidth *= scaleMax;
                desiredHeight *= scaleMax
            }
            refX = new svg.Property("refX", refX);
            refY = new svg.Property("refY", refY);
            if (refX.hasValue() && refY.hasValue()) {
                ctx.translate(-scaleMin * refX.toPixels("x"), -scaleMin * refY.toPixels("y"))
            } else {
                if (align.match(/^xMid/) && (meetOrSlice == "meet" && scaleMin == scaleY || meetOrSlice == "slice" && scaleMax == scaleY))
                    ctx.translate(width / 2 - desiredWidth / 2, 0);
                if (align.match(/YMid$/) && (meetOrSlice == "meet" && scaleMin == scaleX || meetOrSlice == "slice" && scaleMax == scaleX))
                    ctx.translate(0, height / 2 - desiredHeight / 2);
                if (align.match(/^xMax/) && (meetOrSlice == "meet" && scaleMin == scaleY || meetOrSlice == "slice" && scaleMax == scaleY))
                    ctx.translate(width - desiredWidth, 0);
                if (align.match(/YMax$/) && (meetOrSlice == "meet" && scaleMin == scaleX || meetOrSlice == "slice" && scaleMax == scaleX))
                    ctx.translate(0, height - desiredHeight)
            }
            if (align == "none")
                ctx.scale(scaleX, scaleY);
            else if (meetOrSlice == "meet")
                ctx.scale(scaleMin, scaleMin);
            else if (meetOrSlice == "slice")
                ctx.scale(scaleMax, scaleMax);
            ctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY)
        };
        svg.Element = {};
        svg.EmptyProperty = new svg.Property("EMPTY", "");
        svg.Element.ElementBase = function(node) {
            this.attributes = {};
            this.styles = {};
            this.children = [];
            this.attribute = function(name, createIfNotExists) {
                var a = this.attributes[name];
                if (a != null)
                    return a;
                if (createIfNotExists == true) {
                    a = new svg.Property(name, "");
                    this.attributes[name] = a
                }
                return a || svg.EmptyProperty
            };
            this.getHrefAttribute = function() {
                for (var a in this.attributes) {
                    if (a.match(/:href$/)) {
                        return this.attributes[a]
                    }
                }
                return svg.EmptyProperty
            };
            this.style = function(name, createIfNotExists, skipAncestors) {
                var s = this.styles[name];
                if (s != null)
                    return s;
                var a = this.attribute(name);
                if (a != null && a.hasValue()) {
                    this.styles[name] = a;
                    return a
                }
                if (skipAncestors != true) {
                    var p = this.parent;
                    if (p != null) {
                        var ps = p.style(name);
                        if (ps != null && ps.hasValue()) {
                            return ps
                        }
                    }
                }
                if (createIfNotExists == true) {
                    s = new svg.Property(name, "");
                    this.styles[name] = s
                }
                return s || svg.EmptyProperty
            };
            this.render = function(ctx) {
                if (this.style("display").value == "none")
                    return;
                if (this.style("visibility").value == "hidden")
                    return;
                ctx.save();
                if (this.attribute("mask").hasValue()) {
                    var mask = this.attribute("mask").getDefinition();
                    if (mask != null)
                        mask.apply(ctx, this)
                } else if (this.style("filter").hasValue()) {
                    var filter = this.style("filter").getDefinition();
                    if (filter != null)
                        filter.apply(ctx, this)
                } else {
                    this.setContext(ctx);
                    this.renderChildren(ctx);
                    this.clearContext(ctx)
                }
                ctx.restore()
            };
            this.setContext = function(ctx) {
            };
            this.clearContext = function(ctx) {
            };
            this.renderChildren = function(ctx) {
                for (var i = 0; i < this.children.length; i++) {
                    this.children[i].render(ctx)
                }
            };
            this.addChild = function(childNode, create) {
                var child = childNode;
                if (create)
                    child = svg.CreateElement(childNode);
                child.parent = this;
                if (child.type != "title") {
                    this.children.push(child)
                }
            };
            if (node != null && node.nodeType == 1) {
                for (var i = 0; i < node.attributes.length; i++) {
                    var attribute = node.attributes[i];
                    this.attributes[attribute.nodeName] = new svg.Property(attribute.nodeName, attribute.nodeValue)
                }
                var styles = svg.Styles[node.nodeName];
                if (styles != null) {
                    for (var name in styles) {
                        this.styles[name] = styles[name]
                    }
                }
                if (this.attribute("class").hasValue()) {
                    var classes = svg.compressSpaces(this.attribute("class").value).split(" ");
                    for (var j = 0; j < classes.length; j++) {
                        styles = svg.Styles["." + classes[j]];
                        if (styles != null) {
                            for (var name in styles) {
                                this.styles[name] = styles[name]
                            }
                        }
                        styles = svg.Styles[node.nodeName + "." + classes[j]];
                        if (styles != null) {
                            for (var name in styles) {
                                this.styles[name] = styles[name]
                            }
                        }
                    }
                }
                if (this.attribute("id").hasValue()) {
                    var styles = svg.Styles["#" + this.attribute("id").value];
                    if (styles != null) {
                        for (var name in styles) {
                            this.styles[name] = styles[name]
                        }
                    }
                }
                if (this.attribute("style").hasValue()) {
                    var styles = this.attribute("style").value.split(";");
                    for (var i = 0; i < styles.length; i++) {
                        if (svg.trim(styles[i]) != "") {
                            var style = styles[i].split(":");
                            var name = svg.trim(style[0]);
                            var value = svg.trim(style[1]);
                            this.styles[name] = new svg.Property(name, value)
                        }
                    }
                }
                if (this.attribute("id").hasValue()) {
                    if (svg.Definitions[this.attribute("id").value] == null) {
                        svg.Definitions[this.attribute("id").value] = this
                    }
                }
                for (var i = 0; i < node.childNodes.length; i++) {
                    var childNode = node.childNodes[i];
                    if (childNode.nodeType == 1)
                        this.addChild(childNode, true);
                    if (this.captureTextNodes && (childNode.nodeType == 3 || childNode.nodeType == 4)) {
                        var text = childNode.nodeValue || childNode.text || "";
                        if (svg.trim(svg.compressSpaces(text)) != "") {
                            this.addChild(new svg.Element.tspan(childNode), false)
                        }
                    }
                }
            }
        };
        svg.Element.RenderedElementBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.setContext = function(ctx) {
                if (this.style("fill").isUrlDefinition()) {
                    var fs = this.style("fill").getFillStyleDefinition(this, this.style("fill-opacity"));
                    if (fs != null)
                        ctx.fillStyle = fs
                } else if (this.style("fill").hasValue()) {
                    var fillStyle = this.style("fill");
                    if (fillStyle.value == "currentColor")
                        fillStyle.value = this.style("color").value;
                    ctx.fillStyle = fillStyle.value == "none" ? "rgba(0,0,0,0)" : fillStyle.value
                }
                if (this.style("fill-opacity").hasValue()) {
                    var fillStyle = new svg.Property("fill", ctx.fillStyle);
                    fillStyle = fillStyle.addOpacity(this.style("fill-opacity"));
                    ctx.fillStyle = fillStyle.value
                }
                if (this.style("stroke").isUrlDefinition()) {
                    var fs = this.style("stroke").getFillStyleDefinition(this, this.style("stroke-opacity"));
                    if (fs != null)
                        ctx.strokeStyle = fs
                } else if (this.style("stroke").hasValue()) {
                    var strokeStyle = this.style("stroke");
                    if (strokeStyle.value == "currentColor")
                        strokeStyle.value = this.style("color").value;
                    ctx.strokeStyle = strokeStyle.value == "none" ? "rgba(0,0,0,0)" : strokeStyle.value
                }
                if (this.style("stroke-opacity").hasValue()) {
                    var strokeStyle = new svg.Property("stroke", ctx.strokeStyle);
                    strokeStyle = strokeStyle.addOpacity(this.style("stroke-opacity"));
                    ctx.strokeStyle = strokeStyle.value
                }
                if (this.style("stroke-width").hasValue()) {
                    var newLineWidth = this.style("stroke-width").toPixels();
                    ctx.lineWidth = newLineWidth == 0 ? .001 : newLineWidth
                }
                if (this.style("stroke-linecap").hasValue())
                    ctx.lineCap = this.style("stroke-linecap").value;
                if (this.style("stroke-linejoin").hasValue())
                    ctx.lineJoin = this.style("stroke-linejoin").value;
                if (this.style("stroke-miterlimit").hasValue())
                    ctx.miterLimit = this.style("stroke-miterlimit").value;
                if (this.style("stroke-dasharray").hasValue() && this.style("stroke-dasharray").value != "none") {
                    var gaps = svg.ToNumberArray(this.style("stroke-dasharray").value);
                    if (typeof ctx.setLineDash != "undefined") {
                        ctx.setLineDash(gaps)
                    } else if (typeof ctx.webkitLineDash != "undefined") {
                        ctx.webkitLineDash = gaps
                    } else if (typeof ctx.mozDash != "undefined" && !(gaps.length == 1 && gaps[0] == 0)) {
                        ctx.mozDash = gaps
                    }
                    var offset = this.style("stroke-dashoffset").numValueOrDefault(1);
                    if (typeof ctx.lineDashOffset != "undefined") {
                        ctx.lineDashOffset = offset
                    } else if (typeof ctx.webkitLineDashOffset != "undefined") {
                        ctx.webkitLineDashOffset = offset
                    } else if (typeof ctx.mozDashOffset != "undefined") {
                        ctx.mozDashOffset = offset
                    }
                }
                if (typeof ctx.font != "undefined") {
                    ctx.font = svg.Font.CreateFont(this.style("font-style").value, this.style("font-variant").value, this.style("font-weight").value, this.style("font-size").hasValue() ? this.style("font-size").toPixels() + "px" : "", this.style("font-family").value).toString()
                }
                if (this.attribute("transform").hasValue()) {
                    var transform = new svg.Transform(this.attribute("transform").value);
                    transform.apply(ctx)
                }
                if (this.style("clip-path", false, true).hasValue()) {
                    var clip = this.style("clip-path", false, true).getDefinition();
                    if (clip != null)
                        clip.apply(ctx)
                }
                if (this.style("opacity").hasValue()) {
                    ctx.globalAlpha = this.style("opacity").numValue()
                }
            }
        };
        svg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;
        svg.Element.PathElementBase = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.path = function(ctx) {
                if (ctx != null)
                    ctx.beginPath();
                return new svg.BoundingBox
            };
            this.renderChildren = function(ctx) {
                this.path(ctx);
                svg.Mouse.checkPath(this, ctx);
                if (ctx.fillStyle != "") {
                    if (this.style("fill-rule").valueOrDefault("inherit") != "inherit") {
                        ctx.fill(this.style("fill-rule").value)
                    } else {
                        ctx.fill()
                    }
                }
                if (ctx.strokeStyle != "")
                    ctx.stroke();
                var markers = this.getMarkers();
                if (markers != null) {
                    if (this.style("marker-start").isUrlDefinition()) {
                        var marker = this.style("marker-start").getDefinition();
                        marker.render(ctx, markers[0][0], markers[0][1])
                    }
                    if (this.style("marker-mid").isUrlDefinition()) {
                        var marker = this.style("marker-mid").getDefinition();
                        for (var i = 1; i < markers.length - 1; i++) {
                            marker.render(ctx, markers[i][0], markers[i][1])
                        }
                    }
                    if (this.style("marker-end").isUrlDefinition()) {
                        var marker = this.style("marker-end").getDefinition();
                        marker.render(ctx, markers[markers.length - 1][0], markers[markers.length - 1][1])
                    }
                }
            };
            this.getBoundingBox = function() {
                return this.path()
            };
            this.getMarkers = function() {
                return null
            }
        };
        svg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;
        svg.Element.svg = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.baseClearContext = this.clearContext;
            this.clearContext = function(ctx) {
                this.baseClearContext(ctx);
                svg.ViewPort.RemoveCurrent()
            };
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                ctx.strokeStyle = "rgba(0,0,0,0)";
                ctx.lineCap = "butt";
                ctx.lineJoin = "miter";
                ctx.miterLimit = 4;
                if (typeof ctx.font != "undefined" && typeof window.getComputedStyle != "undefined") {
                    ctx.font = window.getComputedStyle(ctx.canvas).getPropertyValue("font")
                }
                this.baseSetContext(ctx);
                if (!this.attribute("x").hasValue())
                    this.attribute("x", true).value = 0;
                if (!this.attribute("y").hasValue())
                    this.attribute("y", true).value = 0;
                ctx.translate(this.attribute("x").toPixels("x"), this.attribute("y").toPixels("y"));
                var width = svg.ViewPort.width();
                var height = svg.ViewPort.height();
                if (!this.attribute("width").hasValue())
                    this.attribute("width", true).value = "100%";
                if (!this.attribute("height").hasValue())
                    this.attribute("height", true).value = "100%";
                if (typeof this.root == "undefined") {
                    width = this.attribute("width").toPixels("x");
                    height = this.attribute("height").toPixels("y");
                    var x = 0;
                    var y = 0;
                    if (this.attribute("refX").hasValue() && this.attribute("refY").hasValue()) {
                        x = -this.attribute("refX").toPixels("x");
                        y = -this.attribute("refY").toPixels("y")
                    }
                    if (this.attribute("overflow").valueOrDefault("hidden") != "visible") {
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(width, y);
                        ctx.lineTo(width, height);
                        ctx.lineTo(x, height);
                        ctx.closePath();
                        ctx.clip()
                    }
                }
                svg.ViewPort.SetCurrent(width, height);
                if (this.attribute("viewBox").hasValue()) {
                    var viewBox = svg.ToNumberArray(this.attribute("viewBox").value);
                    var minX = viewBox[0];
                    var minY = viewBox[1];
                    width = viewBox[2];
                    height = viewBox[3];
                    svg.AspectRatio(ctx, this.attribute("preserveAspectRatio").value, svg.ViewPort.width(), width, svg.ViewPort.height(), height, minX, minY, this.attribute("refX").value, this.attribute("refY").value);
                    svg.ViewPort.RemoveCurrent();
                    svg.ViewPort.SetCurrent(viewBox[2], viewBox[3])
                }
            }
        };
        svg.Element.svg.prototype = new svg.Element.RenderedElementBase;
        svg.Element.rect = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            this.path = function(ctx) {
                var x = this.attribute("x").toPixels("x");
                var y = this.attribute("y").toPixels("y");
                var width = this.attribute("width").toPixels("x");
                var height = this.attribute("height").toPixels("y");
                var rx = this.attribute("rx").toPixels("x");
                var ry = this.attribute("ry").toPixels("y");
                if (this.attribute("rx").hasValue() && !this.attribute("ry").hasValue())
                    ry = rx;
                if (this.attribute("ry").hasValue() && !this.attribute("rx").hasValue())
                    rx = ry;
                rx = Math.min(rx, width / 2);
                ry = Math.min(ry, height / 2);
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(x + rx, y);
                    ctx.lineTo(x + width - rx, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + ry);
                    ctx.lineTo(x + width, y + height - ry);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);
                    ctx.lineTo(x + rx, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - ry);
                    ctx.lineTo(x, y + ry);
                    ctx.quadraticCurveTo(x, y, x + rx, y);
                    ctx.closePath()
                }
                return new svg.BoundingBox(x, y, x + width, y + height)
            }
        };
        svg.Element.rect.prototype = new svg.Element.PathElementBase;
        svg.Element.circle = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            this.path = function(ctx) {
                var cx = this.attribute("cx").toPixels("x");
                var cy = this.attribute("cy").toPixels("y");
                var r = this.attribute("r").toPixels();
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, Math.PI * 2, true);
                    ctx.closePath()
                }
                return new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r)
            }
        };
        svg.Element.circle.prototype = new svg.Element.PathElementBase;
        svg.Element.ellipse = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            this.path = function(ctx) {
                var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
                var rx = this.attribute("rx").toPixels("x");
                var ry = this.attribute("ry").toPixels("y");
                var cx = this.attribute("cx").toPixels("x");
                var cy = this.attribute("cy").toPixels("y");
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - ry);
                    ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);
                    ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);
                    ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);
                    ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);
                    ctx.closePath()
                }
                return new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry)
            }
        };
        svg.Element.ellipse.prototype = new svg.Element.PathElementBase;
        svg.Element.line = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            this.getPoints = function() {
                return [new svg.Point(this.attribute("x1").toPixels("x"), this.attribute("y1").toPixels("y")), new svg.Point(this.attribute("x2").toPixels("x"), this.attribute("y2").toPixels("y"))]
            };
            this.path = function(ctx) {
                var points = this.getPoints();
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(points[1].x, points[1].y)
                }
                return new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y)
            };
            this.getMarkers = function() {
                var points = this.getPoints();
                var a = points[0].angleTo(points[1]);
                return [[points[0], a], [points[1], a]]
            }
        };
        svg.Element.line.prototype = new svg.Element.PathElementBase;
        svg.Element.polyline = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            this.points = svg.CreatePath(this.attribute("points").value);
            this.path = function(ctx) {
                var bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(this.points[0].x, this.points[0].y)
                }
                for (var i = 1; i < this.points.length; i++) {
                    bb.addPoint(this.points[i].x, this.points[i].y);
                    if (ctx != null)
                        ctx.lineTo(this.points[i].x, this.points[i].y)
                }
                return bb
            };
            this.getMarkers = function() {
                var markers = [];
                for (var i = 0; i < this.points.length - 1; i++) {
                    markers.push([this.points[i], this.points[i].angleTo(this.points[i + 1])])
                }
                markers.push([this.points[this.points.length - 1], markers[markers.length - 1][1]]);
                return markers
            }
        };
        svg.Element.polyline.prototype = new svg.Element.PathElementBase;
        svg.Element.polygon = function(node) {
            this.base = svg.Element.polyline;
            this.base(node);
            this.basePath = this.path;
            this.path = function(ctx) {
                var bb = this.basePath(ctx);
                if (ctx != null) {
                    ctx.lineTo(this.points[0].x, this.points[0].y);
                    ctx.closePath()
                }
                return bb
            }
        };
        svg.Element.polygon.prototype = new svg.Element.polyline;
        svg.Element.path = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            var d = this.attribute("d").value;
            d = d.replace(/,/gm, " ");
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2");
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2");
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm, "$1 $2");
            d = d.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2");
            d = d.replace(/([0-9])([+\-])/gm, "$1 $2");
            d = d.replace(/(\.[0-9]*)(\.)/gm, "$1 $2");
            d = d.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm, "$1 $3 $4 ");
            d = svg.compressSpaces(d);
            d = svg.trim(d);
            this.PathParser = new function(d) {
                this.tokens = d.split(" ");
                this.reset = function() {
                    this.i = -1;
                    this.command = "";
                    this.previousCommand = "";
                    this.start = new svg.Point(0, 0);
                    this.control = new svg.Point(0, 0);
                    this.current = new svg.Point(0, 0);
                    this.points = [];
                    this.angles = []
                };
                this.isEnd = function() {
                    return this.i >= this.tokens.length - 1
                };
                this.isCommandOrEnd = function() {
                    if (this.isEnd())
                        return true;
                    return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null
                };
                this.isRelativeCommand = function() {
                    switch (this.command) {
                        case "m":
                        case "l":
                        case "h":
                        case "v":
                        case "c":
                        case "s":
                        case "q":
                        case "t":
                        case "a":
                        case "z":
                            return true;
                            break
                    }
                    return false
                };
                this.getToken = function() {
                    this.i++;
                    return this.tokens[this.i]
                };
                this.getScalar = function() {
                    return parseFloat(this.getToken())
                };
                this.nextCommand = function() {
                    this.previousCommand = this.command;
                    this.command = this.getToken()
                };
                this.getPoint = function() {
                    var p = new svg.Point(this.getScalar(), this.getScalar());
                    return this.makeAbsolute(p)
                };
                this.getAsControlPoint = function() {
                    var p = this.getPoint();
                    this.control = p;
                    return p
                };
                this.getAsCurrentPoint = function() {
                    var p = this.getPoint();
                    this.current = p;
                    return p
                };
                this.getReflectedControlPoint = function() {
                    if (this.previousCommand.toLowerCase() != "c" && this.previousCommand.toLowerCase() != "s" && this.previousCommand.toLowerCase() != "q" && this.previousCommand.toLowerCase() != "t") {
                        return this.current
                    }
                    var p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);
                    return p
                };
                this.makeAbsolute = function(p) {
                    if (this.isRelativeCommand()) {
                        p.x += this.current.x;
                        p.y += this.current.y
                    }
                    return p
                };
                this.addMarker = function(p, from, priorTo) {
                    if (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length - 1] == null) {
                        this.angles[this.angles.length - 1] = this.points[this.points.length - 1].angleTo(priorTo)
                    }
                    this.addMarkerAngle(p, from == null ? null : from.angleTo(p))
                };
                this.addMarkerAngle = function(p, a) {
                    this.points.push(p);
                    this.angles.push(a)
                };
                this.getMarkerPoints = function() {
                    return this.points
                };
                this.getMarkerAngles = function() {
                    for (var i = 0; i < this.angles.length; i++) {
                        if (this.angles[i] == null) {
                            for (var j = i + 1; j < this.angles.length; j++) {
                                if (this.angles[j] != null) {
                                    this.angles[i] = this.angles[j];
                                    break
                                }
                            }
                        }
                    }
                    return this.angles
                }
            }(d);
            this.path = function(ctx) {
                var pp = this.PathParser;
                pp.reset();
                var bb = new svg.BoundingBox;
                if (ctx != null)
                    ctx.beginPath();
                while (!pp.isEnd()) {
                    pp.nextCommand();
                    switch (pp.command) {
                        case "M":
                        case "m":
                            var p = pp.getAsCurrentPoint();
                            pp.addMarker(p);
                            bb.addPoint(p.x, p.y);
                            if (ctx != null)
                                ctx.moveTo(p.x, p.y);
                            pp.start = pp.current;
                            while (!pp.isCommandOrEnd()) {
                                var p = pp.getAsCurrentPoint();
                                pp.addMarker(p, pp.start);
                                bb.addPoint(p.x, p.y);
                                if (ctx != null)
                                    ctx.lineTo(p.x, p.y)
                            }
                            break;
                        case "L":
                        case "l":
                            while (!pp.isCommandOrEnd()) {
                                var c = pp.current;
                                var p = pp.getAsCurrentPoint();
                                pp.addMarker(p, c);
                                bb.addPoint(p.x, p.y);
                                if (ctx != null)
                                    ctx.lineTo(p.x, p.y)
                            }
                            break;
                        case "H":
                        case "h":
                            while (!pp.isCommandOrEnd()) {
                                var newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
                                pp.addMarker(newP, pp.current);
                                pp.current = newP;
                                bb.addPoint(pp.current.x, pp.current.y);
                                if (ctx != null)
                                    ctx.lineTo(pp.current.x, pp.current.y)
                            }
                            break;
                        case "V":
                        case "v":
                            while (!pp.isCommandOrEnd()) {
                                var newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
                                pp.addMarker(newP, pp.current);
                                pp.current = newP;
                                bb.addPoint(pp.current.x, pp.current.y);
                                if (ctx != null)
                                    ctx.lineTo(pp.current.x, pp.current.y)
                            }
                            break;
                        case "C":
                        case "c":
                            while (!pp.isCommandOrEnd()) {
                                var curr = pp.current;
                                var p1 = pp.getPoint();
                                var cntrl = pp.getAsControlPoint();
                                var cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, p1);
                                bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                if (ctx != null)
                                    ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y)
                            }
                            break;
                        case "S":
                        case "s":
                            while (!pp.isCommandOrEnd()) {
                                var curr = pp.current;
                                var p1 = pp.getReflectedControlPoint();
                                var cntrl = pp.getAsControlPoint();
                                var cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, p1);
                                bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                if (ctx != null)
                                    ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y)
                            }
                            break;
                        case "Q":
                        case "q":
                            while (!pp.isCommandOrEnd()) {
                                var curr = pp.current;
                                var cntrl = pp.getAsControlPoint();
                                var cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, cntrl);
                                bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                if (ctx != null)
                                    ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y)
                            }
                            break;
                        case "T":
                        case "t":
                            while (!pp.isCommandOrEnd()) {
                                var curr = pp.current;
                                var cntrl = pp.getReflectedControlPoint();
                                pp.control = cntrl;
                                var cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, cntrl);
                                bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                if (ctx != null)
                                    ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y)
                            }
                            break;
                        case "A":
                        case "a":
                            while (!pp.isCommandOrEnd()) {
                                var curr = pp.current;
                                var rx = pp.getScalar();
                                var ry = pp.getScalar();
                                var xAxisRotation = pp.getScalar() * (Math.PI / 180);
                                var largeArcFlag = pp.getScalar();
                                var sweepFlag = pp.getScalar();
                                var cp = pp.getAsCurrentPoint();
                                var currp = new svg.Point(Math.cos(xAxisRotation) * (curr.x - cp.x) / 2 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2, -Math.sin(xAxisRotation) * (curr.x - cp.x) / 2 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2);
                                var l = Math.pow(currp.x, 2) / Math.pow(rx, 2) + Math.pow(currp.y, 2) / Math.pow(ry, 2);
                                if (l > 1) {
                                    rx *= Math.sqrt(l);
                                    ry *= Math.sqrt(l)
                                }
                                var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(currp.y, 2) - Math.pow(ry, 2) * Math.pow(currp.x, 2)) / (Math.pow(rx, 2) * Math.pow(currp.y, 2) + Math.pow(ry, 2) * Math.pow(currp.x, 2)));
                                if (isNaN(s))
                                    s = 0;
                                var cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
                                var centp = new svg.Point((curr.x + cp.x) / 2 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (curr.y + cp.y) / 2 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y);
                                var m = function(v) {
                                    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2))
                                };
                                var r = function(u, v) {
                                    return (u[0] * v[0] + u[1] * v[1]) / (m(u) * m(v))
                                };
                                var a = function(u, v) {
                                    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(r(u, v))
                                };
                                var a1 = a([1, 0], [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry]);
                                var u = [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry];
                                var v = [(-currp.x - cpp.x) / rx, (-currp.y - cpp.y) / ry];
                                var ad = a(u, v);
                                if (r(u, v) <= -1)
                                    ad = Math.PI;
                                if (r(u, v) >= 1)
                                    ad = 0;
                                var dir = 1 - sweepFlag ? 1 : -1;
                                var ah = a1 + dir * (ad / 2);
                                var halfWay = new svg.Point(centp.x + rx * Math.cos(ah), centp.y + ry * Math.sin(ah));
                                pp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
                                pp.addMarkerAngle(cp, ah - dir * Math.PI);
                                bb.addPoint(cp.x, cp.y);
                                if (ctx != null) {
                                    var r = rx > ry ? rx : ry;
                                    var sx = rx > ry ? 1 : rx / ry;
                                    var sy = rx > ry ? ry / rx : 1;
                                    ctx.translate(centp.x, centp.y);
                                    ctx.rotate(xAxisRotation);
                                    ctx.scale(sx, sy);
                                    ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
                                    ctx.scale(1 / sx, 1 / sy);
                                    ctx.rotate(-xAxisRotation);
                                    ctx.translate(-centp.x, -centp.y)
                                }
                            }
                            break;
                        case "Z":
                        case "z":
                            if (ctx != null)
                                ctx.closePath();
                            pp.current = pp.start
                    }
                }
                return bb
            };
            this.getMarkers = function() {
                var points = this.PathParser.getMarkerPoints();
                var angles = this.PathParser.getMarkerAngles();
                var markers = [];
                for (var i = 0; i < points.length; i++) {
                    markers.push([points[i], angles[i]])
                }
                return markers
            }
        };
        svg.Element.path.prototype = new svg.Element.PathElementBase;
        svg.Element.pattern = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.createPattern = function(ctx, element) {
                var width = this.attribute("width").toPixels("x", true);
                var height = this.attribute("height").toPixels("y", true);
                var tempSvg = new svg.Element.svg;
                tempSvg.attributes["viewBox"] = new svg.Property("viewBox", this.attribute("viewBox").value);
                tempSvg.attributes["width"] = new svg.Property("width", width + "px");
                tempSvg.attributes["height"] = new svg.Property("height", height + "px");
                tempSvg.attributes["transform"] = new svg.Property("transform", this.attribute("patternTransform").value);
                tempSvg.children = this.children;
                var c = document.createElement("canvas");
                c.width = width;
                c.height = height;
                var cctx = c.getContext("2d");
                if (this.attribute("x").hasValue() && this.attribute("y").hasValue()) {
                    cctx.translate(this.attribute("x").toPixels("x", true), this.attribute("y").toPixels("y", true))
                }
                for (var x = -1; x <= 1; x++) {
                    for (var y = -1; y <= 1; y++) {
                        cctx.save();
                        cctx.translate(x * c.width, y * c.height);
                        tempSvg.render(cctx);
                        cctx.restore()
                    }
                }
                var pattern = ctx.createPattern(c, "repeat");
                return pattern
            }
        };
        svg.Element.pattern.prototype = new svg.Element.ElementBase;
        svg.Element.marker = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.baseRender = this.render;
            this.render = function(ctx, point, angle) {
                ctx.translate(point.x, point.y);
                if (this.attribute("orient").valueOrDefault("auto") == "auto")
                    ctx.rotate(angle);
                if (this.attribute("markerUnits").valueOrDefault("strokeWidth") == "strokeWidth")
                    ctx.scale(ctx.lineWidth, ctx.lineWidth);
                ctx.save();
                var tempSvg = new svg.Element.svg;
                tempSvg.attributes["viewBox"] = new svg.Property("viewBox", this.attribute("viewBox").value);
                tempSvg.attributes["refX"] = new svg.Property("refX", this.attribute("refX").value);
                tempSvg.attributes["refY"] = new svg.Property("refY", this.attribute("refY").value);
                tempSvg.attributes["width"] = new svg.Property("width", this.attribute("markerWidth").value);
                tempSvg.attributes["height"] = new svg.Property("height", this.attribute("markerHeight").value);
                tempSvg.attributes["fill"] = new svg.Property("fill", this.attribute("fill").valueOrDefault("black"));
                tempSvg.attributes["stroke"] = new svg.Property("stroke", this.attribute("stroke").valueOrDefault("none"));
                tempSvg.children = this.children;
                tempSvg.render(ctx);
                ctx.restore();
                if (this.attribute("markerUnits").valueOrDefault("strokeWidth") == "strokeWidth")
                    ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);
                if (this.attribute("orient").valueOrDefault("auto") == "auto")
                    ctx.rotate(-angle);
                ctx.translate(-point.x, -point.y)
            }
        };
        svg.Element.marker.prototype = new svg.Element.ElementBase;
        svg.Element.defs = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.render = function(ctx) {
            }
        };
        svg.Element.defs.prototype = new svg.Element.ElementBase;
        svg.Element.GradientBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.gradientUnits = this.attribute("gradientUnits").valueOrDefault("objectBoundingBox");
            this.stops = [];
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (child.type == "stop")
                    this.stops.push(child)
            }
            this.getGradient = function() {
            };
            this.createGradient = function(ctx, element, parentOpacityProp) {
                var stopsContainer = this;
                if (this.getHrefAttribute().hasValue()) {
                    stopsContainer = this.getHrefAttribute().getDefinition()
                }
                var addParentOpacity = function(color) {
                    if (parentOpacityProp.hasValue()) {
                        var p = new svg.Property("color", color);
                        return p.addOpacity(parentOpacityProp).value
                    }
                    return color
                };
                var g = this.getGradient(ctx, element);
                if (g == null)
                    return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);
                for (var i = 0; i < stopsContainer.stops.length; i++) {
                    g.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color))
                }
                if (this.attribute("gradientTransform").hasValue()) {
                    var rootView = svg.ViewPort.viewPorts[0];
                    var rect = new svg.Element.rect;
                    rect.attributes["x"] = new svg.Property("x", -svg.MAX_VIRTUAL_PIXELS / 3);
                    rect.attributes["y"] = new svg.Property("y", -svg.MAX_VIRTUAL_PIXELS / 3);
                    rect.attributes["width"] = new svg.Property("width", svg.MAX_VIRTUAL_PIXELS);
                    rect.attributes["height"] = new svg.Property("height", svg.MAX_VIRTUAL_PIXELS);
                    var group = new svg.Element.g;
                    group.attributes["transform"] = new svg.Property("transform", this.attribute("gradientTransform").value);
                    group.children = [rect];
                    var tempSvg = new svg.Element.svg;
                    tempSvg.attributes["x"] = new svg.Property("x", 0);
                    tempSvg.attributes["y"] = new svg.Property("y", 0);
                    tempSvg.attributes["width"] = new svg.Property("width", rootView.width);
                    tempSvg.attributes["height"] = new svg.Property("height", rootView.height);
                    tempSvg.children = [group];
                    var c = document.createElement("canvas");
                    c.width = rootView.width;
                    c.height = rootView.height;
                    var tempCtx = c.getContext("2d");
                    tempCtx.fillStyle = g;
                    tempSvg.render(tempCtx);
                    return tempCtx.createPattern(c, "no-repeat")
                }
                return g
            }
        };
        svg.Element.GradientBase.prototype = new svg.Element.ElementBase;
        svg.Element.linearGradient = function(node) {
            this.base = svg.Element.GradientBase;
            this.base(node);
            this.getGradient = function(ctx, element) {
                var bb = this.gradientUnits == "objectBoundingBox" ? element.getBoundingBox() : null;
                if (!this.attribute("x1").hasValue() && !this.attribute("y1").hasValue() && !this.attribute("x2").hasValue() && !this.attribute("y2").hasValue()) {
                    this.attribute("x1", true).value = 0;
                    this.attribute("y1", true).value = 0;
                    this.attribute("x2", true).value = 1;
                    this.attribute("y2", true).value = 0
                }
                var x1 = this.gradientUnits == "objectBoundingBox" ? bb.x() + bb.width() * this.attribute("x1").numValue() : this.attribute("x1").toPixels("x");
                var y1 = this.gradientUnits == "objectBoundingBox" ? bb.y() + bb.height() * this.attribute("y1").numValue() : this.attribute("y1").toPixels("y");
                var x2 = this.gradientUnits == "objectBoundingBox" ? bb.x() + bb.width() * this.attribute("x2").numValue() : this.attribute("x2").toPixels("x");
                var y2 = this.gradientUnits == "objectBoundingBox" ? bb.y() + bb.height() * this.attribute("y2").numValue() : this.attribute("y2").toPixels("y");
                if (x1 == x2 && y1 == y2)
                    return null;
                return ctx.createLinearGradient(x1, y1, x2, y2)
            }
        };
        svg.Element.linearGradient.prototype = new svg.Element.GradientBase;
        svg.Element.radialGradient = function(node) {
            this.base = svg.Element.GradientBase;
            this.base(node);
            this.getGradient = function(ctx, element) {
                var bb = element.getBoundingBox();
                if (!this.attribute("cx").hasValue())
                    this.attribute("cx", true).value = "50%";
                if (!this.attribute("cy").hasValue())
                    this.attribute("cy", true).value = "50%";
                if (!this.attribute("r").hasValue())
                    this.attribute("r", true).value = "50%";
                var cx = this.gradientUnits == "objectBoundingBox" ? bb.x() + bb.width() * this.attribute("cx").numValue() : this.attribute("cx").toPixels("x");
                var cy = this.gradientUnits == "objectBoundingBox" ? bb.y() + bb.height() * this.attribute("cy").numValue() : this.attribute("cy").toPixels("y");
                var fx = cx;
                var fy = cy;
                if (this.attribute("fx").hasValue()) {
                    fx = this.gradientUnits == "objectBoundingBox" ? bb.x() + bb.width() * this.attribute("fx").numValue() : this.attribute("fx").toPixels("x")
                }
                if (this.attribute("fy").hasValue()) {
                    fy = this.gradientUnits == "objectBoundingBox" ? bb.y() + bb.height() * this.attribute("fy").numValue() : this.attribute("fy").toPixels("y")
                }
                var r = this.gradientUnits == "objectBoundingBox" ? (bb.width() + bb.height()) / 2 * this.attribute("r").numValue() : this.attribute("r").toPixels();
                return ctx.createRadialGradient(fx, fy, 0, cx, cy, r)
            }
        };
        svg.Element.radialGradient.prototype = new svg.Element.GradientBase;
        svg.Element.stop = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.offset = this.attribute("offset").numValue();
            if (this.offset < 0)
                this.offset = 0;
            if (this.offset > 1)
                this.offset = 1;
            var stopColor = this.style("stop-color");
            if (this.style("stop-opacity").hasValue())
                stopColor = stopColor.addOpacity(this.style("stop-opacity"));
            this.color = stopColor.value
        };
        svg.Element.stop.prototype = new svg.Element.ElementBase;
        svg.Element.AnimateBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            svg.Animations.push(this);
            this.duration = 0;
            this.begin = this.attribute("begin").toMilliseconds();
            this.maxDuration = this.begin + this.attribute("dur").toMilliseconds();
            this.getProperty = function() {
                var attributeType = this.attribute("attributeType").value;
                var attributeName = this.attribute("attributeName").value;
                if (attributeType == "CSS") {
                    return this.parent.style(attributeName, true)
                }
                return this.parent.attribute(attributeName, true)
            };
            this.initialValue = null;
            this.initialUnits = "";
            this.removed = false;
            this.calcValue = function() {
                return ""
            };
            this.update = function(delta) {
                if (this.initialValue == null) {
                    this.initialValue = this.getProperty().value;
                    this.initialUnits = this.getProperty().getUnits()
                }
                if (this.duration > this.maxDuration) {
                    if (this.attribute("repeatCount").value == "indefinite" || this.attribute("repeatDur").value == "indefinite") {
                        this.duration = 0
                    } else if (this.attribute("fill").valueOrDefault("remove") == "freeze" && !this.frozen) {
                        this.frozen = true;
                        this.parent.animationFrozen = true;
                        this.parent.animationFrozenValue = this.getProperty().value
                    } else if (this.attribute("fill").valueOrDefault("remove") == "remove" && !this.removed) {
                        this.removed = true;
                        this.getProperty().value = this.parent.animationFrozen ? this.parent.animationFrozenValue : this.initialValue;
                        return true
                    }
                    return false
                }
                this.duration = this.duration + delta;
                var updated = false;
                if (this.begin < this.duration) {
                    var newValue = this.calcValue();
                    if (this.attribute("type").hasValue()) {
                        var type = this.attribute("type").value;
                        newValue = type + "(" + newValue + ")"
                    }
                    this.getProperty().value = newValue;
                    updated = true
                }
                return updated
            };
            this.from = this.attribute("from");
            this.to = this.attribute("to");
            this.values = this.attribute("values");
            if (this.values.hasValue())
                this.values.value = this.values.value.split(";");
            this.progress = function() {
                var ret = {progress: (this.duration - this.begin) / (this.maxDuration - this.begin)};
                if (this.values.hasValue()) {
                    var p = ret.progress * (this.values.value.length - 1);
                    var lb = Math.floor(p), ub = Math.ceil(p);
                    ret.from = new svg.Property("from", parseFloat(this.values.value[lb]));
                    ret.to = new svg.Property("to", parseFloat(this.values.value[ub]));
                    ret.progress = (p - lb) / (ub - lb)
                } else {
                    ret.from = this.from;
                    ret.to = this.to
                }
                return ret
            }
        };
        svg.Element.AnimateBase.prototype = new svg.Element.ElementBase;
        svg.Element.animate = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);
            this.calcValue = function() {
                var p = this.progress();
                var newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress;
                return newValue + this.initialUnits
            }
        };
        svg.Element.animate.prototype = new svg.Element.AnimateBase;
        svg.Element.animateColor = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);
            this.calcValue = function() {
                var p = this.progress();
                var from = new RGBColor(p.from.value);
                var to = new RGBColor(p.to.value);
                if (from.ok && to.ok) {
                    var r = from.r + (to.r - from.r) * p.progress;
                    var g = from.g + (to.g - from.g) * p.progress;
                    var b = from.b + (to.b - from.b) * p.progress;
                    return "rgb(" + parseInt(r, 10) + "," + parseInt(g, 10) + "," + parseInt(b, 10) + ")"
                }
                return this.attribute("from").value
            }
        };
        svg.Element.animateColor.prototype = new svg.Element.AnimateBase;
        svg.Element.animateTransform = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);
            this.calcValue = function() {
                var p = this.progress();
                var from = svg.ToNumberArray(p.from.value);
                var to = svg.ToNumberArray(p.to.value);
                var newValue = "";
                for (var i = 0; i < from.length; i++) {
                    newValue += from[i] + (to[i] - from[i]) * p.progress + " "
                }
                return newValue
            }
        };
        svg.Element.animateTransform.prototype = new svg.Element.animate;
        svg.Element.font = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.horizAdvX = this.attribute("horiz-adv-x").numValue();
            this.isRTL = false;
            this.isArabic = false;
            this.fontFace = null;
            this.missingGlyph = null;
            this.glyphs = [];
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (child.type == "font-face") {
                    this.fontFace = child;
                    if (child.style("font-family").hasValue()) {
                        svg.Definitions[child.style("font-family").value] = this
                    }
                } else if (child.type == "missing-glyph")
                    this.missingGlyph = child;
                else if (child.type == "glyph") {
                    if (child.arabicForm != "") {
                        this.isRTL = true;
                        this.isArabic = true;
                        if (typeof this.glyphs[child.unicode] == "undefined")
                            this.glyphs[child.unicode] = [];
                        this.glyphs[child.unicode][child.arabicForm] = child
                    } else {
                        this.glyphs[child.unicode] = child
                    }
                }
            }
        };
        svg.Element.font.prototype = new svg.Element.ElementBase;
        svg.Element.fontface = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.ascent = this.attribute("ascent").value;
            this.descent = this.attribute("descent").value;
            this.unitsPerEm = this.attribute("units-per-em").numValue()
        };
        svg.Element.fontface.prototype = new svg.Element.ElementBase;
        svg.Element.missingglyph = function(node) {
            this.base = svg.Element.path;
            this.base(node);
            this.horizAdvX = 0
        };
        svg.Element.missingglyph.prototype = new svg.Element.path;
        svg.Element.glyph = function(node) {
            this.base = svg.Element.path;
            this.base(node);
            this.horizAdvX = this.attribute("horiz-adv-x").numValue();
            this.unicode = this.attribute("unicode").value;
            this.arabicForm = this.attribute("arabic-form").value
        };
        svg.Element.glyph.prototype = new svg.Element.path;
        svg.Element.text = function(node) {
            this.captureTextNodes = true;
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                this.baseSetContext(ctx);
                var textBaseline = this.style("dominant-baseline").toTextBaseline();
                if (textBaseline == null)
                    textBaseline = this.style("alignment-baseline").toTextBaseline();
                if (textBaseline != null)
                    ctx.textBaseline = textBaseline
            };
            this.getBoundingBox = function() {
                var x = this.attribute("x").toPixels("x");
                var y = this.attribute("y").toPixels("y");
                var fontSize = this.parent.style("font-size").numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                return new svg.BoundingBox(x, y - fontSize, x + Math.floor(fontSize * 2 / 3) * this.children[0].getText().length, y)
            };
            this.renderChildren = function(ctx) {
                this.x = this.attribute("x").toPixels("x");
                this.y = this.attribute("y").toPixels("y");
                this.x += this.getAnchorDelta(ctx, this, 0);
                for (var i = 0; i < this.children.length; i++) {
                    this.renderChild(ctx, this, i)
                }
            };
            this.getAnchorDelta = function(ctx, parent, startI) {
                var textAnchor = this.style("text-anchor").valueOrDefault("start");
                if (textAnchor != "start") {
                    var width = 0;
                    for (var i = startI; i < parent.children.length; i++) {
                        var child = parent.children[i];
                        if (i > startI && child.attribute("x").hasValue())
                            break;
                        width += child.measureTextRecursive(ctx)
                    }
                    return -1 * (textAnchor == "end" ? width : width / 2)
                }
                return 0
            };
            this.renderChild = function(ctx, parent, i) {
                var child = parent.children[i];
                if (child.attribute("x").hasValue()) {
                    child.x = child.attribute("x").toPixels("x") + this.getAnchorDelta(ctx, parent, i);
                    if (child.attribute("dx").hasValue())
                        child.x += child.attribute("dx").toPixels("x")
                } else {
                    if (this.attribute("dx").hasValue())
                        this.x += this.attribute("dx").toPixels("x");
                    if (child.attribute("dx").hasValue())
                        this.x += child.attribute("dx").toPixels("x");
                    child.x = this.x
                }
                this.x = child.x + child.measureText(ctx);
                if (child.attribute("y").hasValue()) {
                    child.y = child.attribute("y").toPixels("y");
                    if (child.attribute("dy").hasValue())
                        child.y += child.attribute("dy").toPixels("y")
                } else {
                    if (this.attribute("dy").hasValue())
                        this.y += this.attribute("dy").toPixels("y");
                    if (child.attribute("dy").hasValue())
                        this.y += child.attribute("dy").toPixels("y");
                    child.y = this.y
                }
                this.y = child.y;
                child.render(ctx);
                for (var i = 0; i < child.children.length; i++) {
                    this.renderChild(ctx, child, i)
                }
            }
        };
        svg.Element.text.prototype = new svg.Element.RenderedElementBase;
        svg.Element.TextElementBase = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.getGlyph = function(font, text, i) {
                var c = text[i];
                var glyph = null;
                if (font.isArabic) {
                    var arabicForm = "isolated";
                    if ((i == 0 || text[i - 1] == " ") && i < text.length - 2 && text[i + 1] != " ")
                        arabicForm = "terminal";
                    if (i > 0 && text[i - 1] != " " && i < text.length - 2 && text[i + 1] != " ")
                        arabicForm = "medial";
                    if (i > 0 && text[i - 1] != " " && (i == text.length - 1 || text[i + 1] == " "))
                        arabicForm = "initial";
                    if (typeof font.glyphs[c] != "undefined") {
                        glyph = font.glyphs[c][arabicForm];
                        if (glyph == null && font.glyphs[c].type == "glyph")
                            glyph = font.glyphs[c]
                    }
                } else {
                    glyph = font.glyphs[c]
                }
                if (glyph == null)
                    glyph = font.missingGlyph;
                return glyph
            };
            this.renderChildren = function(ctx) {
                var customFont = this.parent.style("font-family").getDefinition();
                if (customFont != null) {
                    var fontSize = this.parent.style("font-size").numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                    var fontStyle = this.parent.style("font-style").valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);
                    var text = this.getText();
                    if (customFont.isRTL)
                        text = text.split("").reverse().join("");
                    var dx = svg.ToNumberArray(this.parent.attribute("dx").value);
                    for (var i = 0; i < text.length; i++) {
                        var glyph = this.getGlyph(customFont, text, i);
                        var scale = fontSize / customFont.fontFace.unitsPerEm;
                        ctx.translate(this.x, this.y);
                        ctx.scale(scale, -scale);
                        var lw = ctx.lineWidth;
                        ctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;
                        if (fontStyle == "italic")
                            ctx.transform(1, 0, .4, 1, 0, 0);
                        glyph.render(ctx);
                        if (fontStyle == "italic")
                            ctx.transform(1, 0, -.4, 1, 0, 0);
                        ctx.lineWidth = lw;
                        ctx.scale(1 / scale, -1 / scale);
                        ctx.translate(-this.x, -this.y);
                        this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;
                        if (typeof dx[i] != "undefined" && !isNaN(dx[i])) {
                            this.x += dx[i]
                        }
                    }
                    return
                }
                if (ctx.fillStyle != "")
                    ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);
                if (ctx.strokeStyle != "")
                    ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y)
            };
            this.getText = function() {
            };
            this.measureTextRecursive = function(ctx) {
                var width = this.measureText(ctx);
                for (var i = 0; i < this.children.length; i++) {
                    width += this.children[i].measureTextRecursive(ctx)
                }
                return width
            };
            this.measureText = function(ctx) {
                var customFont = this.parent.style("font-family").getDefinition();
                if (customFont != null) {
                    var fontSize = this.parent.style("font-size").numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                    var measure = 0;
                    var text = this.getText();
                    if (customFont.isRTL)
                        text = text.split("").reverse().join("");
                    var dx = svg.ToNumberArray(this.parent.attribute("dx").value);
                    for (var i = 0; i < text.length; i++) {
                        var glyph = this.getGlyph(customFont, text, i);
                        measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
                        if (typeof dx[i] != "undefined" && !isNaN(dx[i])) {
                            measure += dx[i]
                        }
                    }
                    return measure
                }
                var textToMeasure = svg.compressSpaces(this.getText());
                if (!ctx.measureText)
                    return textToMeasure.length * 10;
                ctx.save();
                this.setContext(ctx);
                var width = ctx.measureText(textToMeasure).width;
                ctx.restore();
                return width
            }
        };
        svg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;
        svg.Element.tspan = function(node) {
            this.captureTextNodes = true;
            this.base = svg.Element.TextElementBase;
            this.base(node);
            this.text = node.nodeValue || node.text || "";
            this.getText = function() {
                return this.text
            }
        };
        svg.Element.tspan.prototype = new svg.Element.TextElementBase;
        svg.Element.tref = function(node) {
            this.base = svg.Element.TextElementBase;
            this.base(node);
            this.getText = function() {
                var element = this.getHrefAttribute().getDefinition();
                if (element != null)
                    return element.children[0].getText()
            }
        };
        svg.Element.tref.prototype = new svg.Element.TextElementBase;
        svg.Element.a = function(node) {
            this.base = svg.Element.TextElementBase;
            this.base(node);
            this.hasText = true;
            for (var i = 0; i < node.childNodes.length; i++) {
                if (node.childNodes[i].nodeType != 3)
                    this.hasText = false
            }
            this.text = this.hasText ? node.childNodes[0].nodeValue : "";
            this.getText = function() {
                return this.text
            };
            this.baseRenderChildren = this.renderChildren;
            this.renderChildren = function(ctx) {
                if (this.hasText) {
                    this.baseRenderChildren(ctx);
                    var fontSize = new svg.Property("fontSize", svg.Font.Parse(svg.ctx.font).fontSize);
                    svg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels("y"), this.x + this.measureText(ctx), this.y))
                } else {
                    var g = new svg.Element.g;
                    g.children = this.children;
                    g.parent = this;
                    g.render(ctx)
                }
            };
            this.onclick = function() {
                window.open(this.getHrefAttribute().value)
            };
            this.onmousemove = function() {
                svg.ctx.canvas.style.cursor = "pointer"
            }
        };
        svg.Element.a.prototype = new svg.Element.TextElementBase;
        svg.Element.image = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            var href = this.getHrefAttribute().value;
            if (href == "") {
                return
            }
            var isSvg = href.match(/\.svg$/);
            svg.Images.push(this);
            this.loaded = false;
            if (!isSvg) {
                this.img = document.createElement("img");
                if (svg.opts["useCORS"] == true) {
                    this.img.crossOrigin = "Anonymous"
                }
                var self = this;
                this.img.onload = function() {
                    self.loaded = true
                };
                this.img.onerror = function() {
                    svg.log('ERROR: image "' + href + '" not found');
                    self.loaded = true
                };
                this.img.src = href
            } else {
                this.img = svg.ajax(href);
                this.loaded = true
            }
            this.renderChildren = function(ctx) {
                var x = this.attribute("x").toPixels("x");
                var y = this.attribute("y").toPixels("y");
                var width = this.attribute("width").toPixels("x");
                var height = this.attribute("height").toPixels("y");
                if (width == 0 || height == 0)
                    return;
                ctx.save();
                if (isSvg) {
                    ctx.drawSvg(this.img, x, y, width, height)
                } else {
                    ctx.translate(x, y);
                    svg.AspectRatio(ctx, this.attribute("preserveAspectRatio").value, width, this.img.width, height, this.img.height, 0, 0);
                    ctx.drawImage(this.img, 0, 0)
                }
                ctx.restore()
            };
            this.getBoundingBox = function() {
                var x = this.attribute("x").toPixels("x");
                var y = this.attribute("y").toPixels("y");
                var width = this.attribute("width").toPixels("x");
                var height = this.attribute("height").toPixels("y");
                return new svg.BoundingBox(x, y, x + width, y + height)
            }
        };
        svg.Element.image.prototype = new svg.Element.RenderedElementBase;
        svg.Element.g = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.getBoundingBox = function() {
                var bb = new svg.BoundingBox;
                for (var i = 0; i < this.children.length; i++) {
                    bb.addBoundingBox(this.children[i].getBoundingBox())
                }
                return bb
            }
        };
        svg.Element.g.prototype = new svg.Element.RenderedElementBase;
        svg.Element.symbol = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.render = function(ctx) {
            }
        };
        svg.Element.symbol.prototype = new svg.Element.RenderedElementBase;
        svg.Element.style = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            var css = "";
            for (var i = 0; i < node.childNodes.length; i++) {
                css += node.childNodes[i].nodeValue
            }
            css = css.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, "");
            css = svg.compressSpaces(css);
            var cssDefs = css.split("}");
            for (var i = 0; i < cssDefs.length; i++) {
                if (svg.trim(cssDefs[i]) != "") {
                    var cssDef = cssDefs[i].split("{");
                    var cssClasses = cssDef[0].split(",");
                    var cssProps = cssDef[1].split(";");
                    for (var j = 0; j < cssClasses.length; j++) {
                        var cssClass = svg.trim(cssClasses[j]);
                        if (cssClass != "") {
                            var props = {};
                            for (var k = 0; k < cssProps.length; k++) {
                                var prop = cssProps[k].indexOf(":");
                                var name = cssProps[k].substr(0, prop);
                                var value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);
                                if (name != null && value != null) {
                                    props[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value))
                                }
                            }
                            svg.Styles[cssClass] = props;
                            if (cssClass == "@font-face") {
                                var fontFamily = props["font-family"].value.replace(/"/g, "");
                                var srcs = props["src"].value.split(",");
                                for (var s = 0; s < srcs.length; s++) {
                                    if (srcs[s].indexOf('format("svg")') > 0) {
                                        var urlStart = srcs[s].indexOf("url");
                                        var urlEnd = srcs[s].indexOf(")", urlStart);
                                        var url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);
                                        var doc = svg.parseXml(svg.ajax(url));
                                        var fonts = doc.getElementsByTagName("font");
                                        for (var f = 0; f < fonts.length; f++) {
                                            var font = svg.CreateElement(fonts[f]);
                                            svg.Definitions[fontFamily] = font
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        svg.Element.style.prototype = new svg.Element.ElementBase;
        svg.Element.use = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                this.baseSetContext(ctx);
                if (this.attribute("x").hasValue())
                    ctx.translate(this.attribute("x").toPixels("x"), 0);
                if (this.attribute("y").hasValue())
                    ctx.translate(0, this.attribute("y").toPixels("y"))
            };
            var element = this.getHrefAttribute().getDefinition();
            this.path = function(ctx) {
                if (element != null)
                    element.path(ctx)
            };
            this.getBoundingBox = function() {
                if (element != null)
                    return element.getBoundingBox()
            };
            this.renderChildren = function(ctx) {
                if (element != null) {
                    var tempSvg = element;
                    if (element.type == "symbol") {
                        tempSvg = new svg.Element.svg;
                        tempSvg.type = "svg";
                        tempSvg.attributes["viewBox"] = new svg.Property("viewBox", element.attribute("viewBox").value);
                        tempSvg.attributes["preserveAspectRatio"] = new svg.Property("preserveAspectRatio", element.attribute("preserveAspectRatio").value);
                        tempSvg.attributes["overflow"] = new svg.Property("overflow", element.attribute("overflow").value);
                        tempSvg.children = element.children
                    }
                    if (tempSvg.type == "svg") {
                        if (this.attribute("width").hasValue())
                            tempSvg.attributes["width"] = new svg.Property("width", this.attribute("width").value);
                        if (this.attribute("height").hasValue())
                            tempSvg.attributes["height"] = new svg.Property("height", this.attribute("height").value)
                    }
                    var oldParent = tempSvg.parent;
                    tempSvg.parent = null;
                    tempSvg.render(ctx);
                    tempSvg.parent = oldParent
                }
            }
        };
        svg.Element.use.prototype = new svg.Element.RenderedElementBase;
        svg.Element.mask = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.apply = function(ctx, element) {
                var x = this.attribute("x").toPixels("x");
                var y = this.attribute("y").toPixels("y");
                var width = this.attribute("width").toPixels("x");
                var height = this.attribute("height").toPixels("y");
                if (width == 0 && height == 0) {
                    var bb = new svg.BoundingBox;
                    for (var i = 0; i < this.children.length; i++) {
                        bb.addBoundingBox(this.children[i].getBoundingBox())
                    }
                    var x = Math.floor(bb.x1);
                    var y = Math.floor(bb.y1);
                    var width = Math.floor(bb.width());
                    var height = Math.floor(bb.height())
                }
                var mask = element.attribute("mask").value;
                element.attribute("mask").value = "";
                var cMask = document.createElement("canvas");
                cMask.width = x + width;
                cMask.height = y + height;
                var maskCtx = cMask.getContext("2d");
                this.renderChildren(maskCtx);
                var c = document.createElement("canvas");
                c.width = x + width;
                c.height = y + height;
                var tempCtx = c.getContext("2d");
                element.render(tempCtx);
                tempCtx.globalCompositeOperation = "destination-in";
                tempCtx.fillStyle = maskCtx.createPattern(cMask, "no-repeat");
                tempCtx.fillRect(0, 0, x + width, y + height);
                ctx.fillStyle = tempCtx.createPattern(c, "no-repeat");
                ctx.fillRect(0, 0, x + width, y + height);
                element.attribute("mask").value = mask
            };
            this.render = function(ctx) {
            }
        };
        svg.Element.mask.prototype = new svg.Element.ElementBase;
        svg.Element.clipPath = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.apply = function(ctx) {
                var oldBeginPath = CanvasRenderingContext2D.prototype.beginPath;
                CanvasRenderingContext2D.prototype.beginPath = function() {
                };
                var oldClosePath = CanvasRenderingContext2D.prototype.closePath;
                CanvasRenderingContext2D.prototype.closePath = function() {
                };
                oldBeginPath.call(ctx);
                for (var i = 0; i < this.children.length; i++) {
                    var child = this.children[i];
                    if (typeof child.path != "undefined") {
                        var transform = null;
                        if (child.attribute("transform").hasValue()) {
                            transform = new svg.Transform(child.attribute("transform").value);
                            transform.apply(ctx)
                        }
                        child.path(ctx);
                        CanvasRenderingContext2D.prototype.closePath = oldClosePath;
                        if (transform) {
                            transform.unapply(ctx)
                        }
                    }
                }
                oldClosePath.call(ctx);
                ctx.clip();
                CanvasRenderingContext2D.prototype.beginPath = oldBeginPath;
                CanvasRenderingContext2D.prototype.closePath = oldClosePath
            };
            this.render = function(ctx) {
            }
        };
        svg.Element.clipPath.prototype = new svg.Element.ElementBase;
        svg.Element.filter = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.apply = function(ctx, element) {
                var bb = element.getBoundingBox();
                var x = Math.floor(bb.x1);
                var y = Math.floor(bb.y1);
                var width = Math.floor(bb.width());
                var height = Math.floor(bb.height());
                var filter = element.style("filter").value;
                element.style("filter").value = "";
                var px = 0, py = 0;
                for (var i = 0; i < this.children.length; i++) {
                    var efd = this.children[i].extraFilterDistance || 0;
                    px = Math.max(px, efd);
                    py = Math.max(py, efd)
                }
                var c = document.createElement("canvas");
                c.width = width + 2 * px;
                c.height = height + 2 * py;
                var tempCtx = c.getContext("2d");
                tempCtx.translate(-x + px, -y + py);
                element.render(tempCtx);
                for (var i = 0; i < this.children.length; i++) {
                    this.children[i].apply(tempCtx, 0, 0, width + 2 * px, height + 2 * py)
                }
                ctx.drawImage(c, 0, 0, width + 2 * px, height + 2 * py, x - px, y - py, width + 2 * px, height + 2 * py);
                element.style("filter", true).value = filter
            };
            this.render = function(ctx) {
            }
        };
        svg.Element.filter.prototype = new svg.Element.ElementBase;
        svg.Element.feMorphology = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.apply = function(ctx, x, y, width, height) {
            }
        };
        svg.Element.feMorphology.prototype = new svg.Element.ElementBase;
        svg.Element.feComposite = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.apply = function(ctx, x, y, width, height) {
            }
        };
        svg.Element.feComposite.prototype = new svg.Element.ElementBase;
        svg.Element.feColorMatrix = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            var matrix = svg.ToNumberArray(this.attribute("values").value);
            switch (this.attribute("type").valueOrDefault("matrix")) {
                case "saturate":
                    var s = matrix[0];
                    matrix = [.213 + .787 * s, .715 - .715 * s, .072 - .072 * s, 0, 0, .213 - .213 * s, .715 + .285 * s, .072 - .072 * s, 0, 0, .213 - .213 * s, .715 - .715 * s, .072 + .928 * s, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
                    break;
                case "hueRotate":
                    var a = matrix[0] * Math.PI / 180;
                    var c = function(m1, m2, m3) {
                        return m1 + Math.cos(a) * m2 + Math.sin(a) * m3
                    };
                    matrix = [c(.213, .787, -.213), c(.715, -.715, -.715), c(.072, -.072, .928), 0, 0, c(.213, -.213, .143), c(.715, .285, .14), c(.072, -.072, -.283), 0, 0, c(.213, -.213, -.787), c(.715, -.715, .715), c(.072, .928, .072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
                    break;
                case "luminanceToAlpha":
                    matrix = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, .2125, .7154, .0721, 0, 0, 0, 0, 0, 0, 1];
                    break
            }
            function imGet(img, x, y, width, height, rgba) {
                return img[y * width * 4 + x * 4 + rgba]
            }
            function imSet(img, x, y, width, height, rgba, val) {
                img[y * width * 4 + x * 4 + rgba] = val
            }
            function m(i, v) {
                var mi = matrix[i];
                return mi * (mi < 0 ? v - 255 : v)
            }
            this.apply = function(ctx, x, y, width, height) {
                var srcData = ctx.getImageData(0, 0, width, height);
                for (var y = 0; y < height; y++) {
                    for (var x = 0; x < width; x++) {
                        var r = imGet(srcData.data, x, y, width, height, 0);
                        var g = imGet(srcData.data, x, y, width, height, 1);
                        var b = imGet(srcData.data, x, y, width, height, 2);
                        var a = imGet(srcData.data, x, y, width, height, 3);
                        imSet(srcData.data, x, y, width, height, 0, m(0, r) + m(1, g) + m(2, b) + m(3, a) + m(4, 1));
                        imSet(srcData.data, x, y, width, height, 1, m(5, r) + m(6, g) + m(7, b) + m(8, a) + m(9, 1));
                        imSet(srcData.data, x, y, width, height, 2, m(10, r) + m(11, g) + m(12, b) + m(13, a) + m(14, 1));
                        imSet(srcData.data, x, y, width, height, 3, m(15, r) + m(16, g) + m(17, b) + m(18, a) + m(19, 1))
                    }
                }
                ctx.clearRect(0, 0, width, height);
                ctx.putImageData(srcData, 0, 0)
            }
        };
        svg.Element.feColorMatrix.prototype = new svg.Element.ElementBase;
        svg.Element.feGaussianBlur = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.blurRadius = Math.floor(this.attribute("stdDeviation").numValue());
            this.extraFilterDistance = this.blurRadius;
            this.apply = function(ctx, x, y, width, height) {
                if (typeof stackBlurCanvasRGBA == "undefined") {
                    svg.log("ERROR: StackBlur.js must be included for blur to work");
                    return
                }
                ctx.canvas.id = svg.UniqueId();
                ctx.canvas.style.display = "none";
                document.body.appendChild(ctx.canvas);
                stackBlurCanvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius);
                document.body.removeChild(ctx.canvas)
            }
        };
        svg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase;
        svg.Element.title = function(node) {
        };
        svg.Element.title.prototype = new svg.Element.ElementBase;
        svg.Element.desc = function(node) {
        };
        svg.Element.desc.prototype = new svg.Element.ElementBase;
        svg.Element.MISSING = function(node) {
            svg.log("ERROR: Element '" + node.nodeName + "' not yet implemented.")
        };
        svg.Element.MISSING.prototype = new svg.Element.ElementBase;
        svg.CreateElement = function(node) {
            var className = node.nodeName.replace(/^[^:]+:/, "");
            className = className.replace(/\-/g, "");
            var e = null;
            if (typeof svg.Element[className] != "undefined") {
                e = new svg.Element[className](node)
            } else {
                e = new svg.Element.MISSING(node)
            }
            e.type = node.nodeName;
            return e
        };
        svg.load = function(ctx, url) {
            svg.loadXml(ctx, svg.ajax(url))
        };
        svg.loadXml = function(ctx, xml) {
            svg.loadXmlDoc(ctx, svg.parseXml(xml))
        };
        svg.loadXmlDoc = function(ctx, dom) {
            svg.init(ctx);
            var mapXY = function(p) {
                var e = ctx.canvas;
                while (e) {
                    p.x -= e.offsetLeft;
                    p.y -= e.offsetTop;
                    e = e.offsetParent
                }
                if (window.scrollX)
                    p.x += window.scrollX;
                if (window.scrollY)
                    p.y += window.scrollY;
                return p
            };
            if (svg.opts["ignoreMouse"] != true) {
                ctx.canvas.onclick = function(e) {
                    var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
                    svg.Mouse.onclick(p.x, p.y)
                };
                ctx.canvas.onmousemove = function(e) {
                    var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
                    svg.Mouse.onmousemove(p.x, p.y)
                }
            }
            var e = svg.CreateElement(dom.documentElement);
            e.root = true;
            var isFirstRender = true;
            var draw = function() {
                svg.ViewPort.Clear();
                if (ctx.canvas.parentNode)
                    svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);
                if (svg.opts["ignoreDimensions"] != true) {
                    if (e.style("width").hasValue()) {
                        ctx.canvas.width = e.style("width").toPixels("x");
                        ctx.canvas.style.width = ctx.canvas.width + "px"
                    }
                    if (e.style("height").hasValue()) {
                        ctx.canvas.height = e.style("height").toPixels("y");
                        ctx.canvas.style.height = ctx.canvas.height + "px"
                    }
                }
                var cWidth = ctx.canvas.clientWidth || ctx.canvas.width;
                var cHeight = ctx.canvas.clientHeight || ctx.canvas.height;
                if (svg.opts["ignoreDimensions"] == true && e.style("width").hasValue() && e.style("height").hasValue()) {
                    cWidth = e.style("width").toPixels("x");
                    cHeight = e.style("height").toPixels("y")
                }
                svg.ViewPort.SetCurrent(cWidth, cHeight);
                if (svg.opts["offsetX"] != null)
                    e.attribute("x", true).value = svg.opts["offsetX"];
                if (svg.opts["offsetY"] != null)
                    e.attribute("y", true).value = svg.opts["offsetY"];
                if (svg.opts["scaleWidth"] != null || svg.opts["scaleHeight"] != null) {
                    var xRatio = null, yRatio = null, viewBox = svg.ToNumberArray(e.attribute("viewBox").value);
                    if (svg.opts["scaleWidth"] != null) {
                        if (e.attribute("width").hasValue())
                            xRatio = e.attribute("width").toPixels("x") / svg.opts["scaleWidth"];
                        else if (!isNaN(viewBox[2]))
                            xRatio = viewBox[2] / svg.opts["scaleWidth"]
                    }
                    if (svg.opts["scaleHeight"] != null) {
                        if (e.attribute("height").hasValue())
                            yRatio = e.attribute("height").toPixels("y") / svg.opts["scaleHeight"];
                        else if (!isNaN(viewBox[3]))
                            yRatio = viewBox[3] / svg.opts["scaleHeight"]
                    }
                    if (xRatio == null) {
                        xRatio = yRatio
                    }
                    if (yRatio == null) {
                        yRatio = xRatio
                    }
                    e.attribute("width", true).value = svg.opts["scaleWidth"];
                    e.attribute("height", true).value = svg.opts["scaleHeight"];
                    e.attribute("transform", true).value += " scale(" + 1 / xRatio + "," + 1 / yRatio + ")"
                }
                if (svg.opts["ignoreClear"] != true) {
                    ctx.clearRect(0, 0, cWidth, cHeight)
                }
                e.render(ctx);
                if (isFirstRender) {
                    isFirstRender = false;
                    if (typeof svg.opts["renderCallback"] == "function")
                        svg.opts["renderCallback"](dom)
                }
            };
            var waitingForImages = true;
            if (svg.ImagesLoaded()) {
                waitingForImages = false;
                draw()
            }
            svg.intervalID = setInterval(function() {
                var needUpdate = false;
                if (waitingForImages && svg.ImagesLoaded()) {
                    waitingForImages = false;
                    needUpdate = true
                }
                if (svg.opts["ignoreMouse"] != true) {
                    needUpdate = needUpdate | svg.Mouse.hasEvents()
                }
                if (svg.opts["ignoreAnimation"] != true) {
                    for (var i = 0; i < svg.Animations.length; i++) {
                        needUpdate = needUpdate | svg.Animations[i].update(1e3 / svg.FRAMERATE)
                    }
                }
                if (typeof svg.opts["forceRedraw"] == "function") {
                    if (svg.opts["forceRedraw"]() == true)
                        needUpdate = true
                }
                if (needUpdate) {
                    draw();
                    svg.Mouse.runEvents()
                }
            }, 1e3 / svg.FRAMERATE)
        };
        svg.stop = function() {
            if (svg.intervalID) {
                clearInterval(svg.intervalID)
            }
        };
        svg.Mouse = new function() {
            this.events = [];
            this.hasEvents = function() {
                return this.events.length != 0
            };
            this.onclick = function(x, y) {
                this.events.push({type: "onclick",x: x,y: y,run: function(e) {
                    if (e.onclick)
                        e.onclick()
                }})
            };
            this.onmousemove = function(x, y) {
                this.events.push({type: "onmousemove",x: x,y: y,run: function(e) {
                    if (e.onmousemove)
                        e.onmousemove()
                }})
            };
            this.eventElements = [];
            this.checkPath = function(element, ctx) {
                for (var i = 0; i < this.events.length; i++) {
                    var e = this.events[i];
                    if (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y))
                        this.eventElements[i] = element
                }
            };
            this.checkBoundingBox = function(element, bb) {
                for (var i = 0; i < this.events.length; i++) {
                    var e = this.events[i];
                    if (bb.isPointInBox(e.x, e.y))
                        this.eventElements[i] = element
                }
            };
            this.runEvents = function() {
                svg.ctx.canvas.style.cursor = "";
                for (var i = 0; i < this.events.length; i++) {
                    var e = this.events[i];
                    var element = this.eventElements[i];
                    while (element) {
                        e.run(element);
                        element = element.parent
                    }
                }
                this.events = [];
                this.eventElements = []
            }
        };
        return svg
    }
})();
if (typeof CanvasRenderingContext2D != "undefined") {
    CanvasRenderingContext2D.prototype.drawSvg = function(s, dx, dy, dw, dh) {
        canvg(this.canvas, s, {ignoreMouse: true,ignoreAnimation: true,ignoreDimensions: true,ignoreClear: true,offsetX: dx,offsetY: dy,scaleWidth: dw,scaleHeight: dh})
    }
}
function RGBColor(color_string) {
    this.ok = false;
    if (color_string.charAt(0) == "#") {
        color_string = color_string.substr(1, 6)
    }
    color_string = color_string.replace(/ /g, "");
    color_string = color_string.toLowerCase();
    var simple_colors = {aliceblue: "f0f8ff",antiquewhite: "faebd7",aqua: "00ffff",aquamarine: "7fffd4",azure: "f0ffff",beige: "f5f5dc",bisque: "ffe4c4",black: "000000",blanchedalmond: "ffebcd",blue: "0000ff",blueviolet: "8a2be2",brown: "a52a2a",burlywood: "deb887",cadetblue: "5f9ea0",chartreuse: "7fff00",chocolate: "d2691e",coral: "ff7f50",cornflowerblue: "6495ed",cornsilk: "fff8dc",crimson: "dc143c",cyan: "00ffff",darkblue: "00008b",darkcyan: "008b8b",darkgoldenrod: "b8860b",darkgray: "a9a9a9",darkgreen: "006400",darkkhaki: "bdb76b",darkmagenta: "8b008b",darkolivegreen: "556b2f",darkorange: "ff8c00",darkorchid: "9932cc",darkred: "8b0000",darksalmon: "e9967a",darkseagreen: "8fbc8f",darkslateblue: "483d8b",darkslategray: "2f4f4f",darkturquoise: "00ced1",darkviolet: "9400d3",deeppink: "ff1493",deepskyblue: "00bfff",dimgray: "696969",dodgerblue: "1e90ff",feldspar: "d19275",firebrick: "b22222",floralwhite: "fffaf0",forestgreen: "228b22",fuchsia: "ff00ff",gainsboro: "dcdcdc",ghostwhite: "f8f8ff",gold: "ffd700",goldenrod: "daa520",gray: "808080",green: "008000",greenyellow: "adff2f",honeydew: "f0fff0",hotpink: "ff69b4",indianred: "cd5c5c",indigo: "4b0082",ivory: "fffff0",khaki: "f0e68c",lavender: "e6e6fa",lavenderblush: "fff0f5",lawngreen: "7cfc00",lemonchiffon: "fffacd",lightblue: "add8e6",lightcoral: "f08080",lightcyan: "e0ffff",lightgoldenrodyellow: "fafad2",lightgrey: "d3d3d3",lightgreen: "90ee90",lightpink: "ffb6c1",lightsalmon: "ffa07a",lightseagreen: "20b2aa",lightskyblue: "87cefa",lightslateblue: "8470ff",lightslategray: "778899",lightsteelblue: "b0c4de",lightyellow: "ffffe0",lime: "00ff00",limegreen: "32cd32",linen: "faf0e6",magenta: "ff00ff",maroon: "800000",mediumaquamarine: "66cdaa",mediumblue: "0000cd",mediumorchid: "ba55d3",mediumpurple: "9370d8",mediumseagreen: "3cb371",mediumslateblue: "7b68ee",mediumspringgreen: "00fa9a",mediumturquoise: "48d1cc",mediumvioletred: "c71585",midnightblue: "191970",mintcream: "f5fffa",mistyrose: "ffe4e1",moccasin: "ffe4b5",navajowhite: "ffdead",navy: "000080",oldlace: "fdf5e6",olive: "808000",olivedrab: "6b8e23",orange: "ffa500",orangered: "ff4500",orchid: "da70d6",palegoldenrod: "eee8aa",palegreen: "98fb98",paleturquoise: "afeeee",palevioletred: "d87093",papayawhip: "ffefd5",peachpuff: "ffdab9",peru: "cd853f",pink: "ffc0cb",plum: "dda0dd",powderblue: "b0e0e6",purple: "800080",red: "ff0000",rosybrown: "bc8f8f",royalblue: "4169e1",saddlebrown: "8b4513",salmon: "fa8072",sandybrown: "f4a460",seagreen: "2e8b57",seashell: "fff5ee",sienna: "a0522d",silver: "c0c0c0",skyblue: "87ceeb",slateblue: "6a5acd",slategray: "708090",snow: "fffafa",springgreen: "00ff7f",steelblue: "4682b4",tan: "d2b48c",teal: "008080",thistle: "d8bfd8",tomato: "ff6347",turquoise: "40e0d0",violet: "ee82ee",violetred: "d02090",wheat: "f5deb3",white: "ffffff",whitesmoke: "f5f5f5",yellow: "ffff00",yellowgreen: "9acd32"};
    for (var key in simple_colors) {
        if (color_string == key) {
            color_string = simple_colors[key]
        }
    }
    var color_defs = [{re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],process: function(bits) {
        return [parseInt(bits[1]), parseInt(bits[2]), parseInt(bits[3])]
    }}, {re: /^(\w{2})(\w{2})(\w{2})$/,example: ["#00ff00", "336699"],process: function(bits) {
        return [parseInt(bits[1], 16), parseInt(bits[2], 16), parseInt(bits[3], 16)]
    }}, {re: /^(\w{1})(\w{1})(\w{1})$/,example: ["#fb0", "f0f"],process: function(bits) {
        return [parseInt(bits[1] + bits[1], 16), parseInt(bits[2] + bits[2], 16), parseInt(bits[3] + bits[3], 16)]
    }}];
    for (var i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits) {
            channels = processor(bits);
            this.r = channels[0];
            this.g = channels[1];
            this.b = channels[2];
            this.ok = true
        }
    }
    this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r;
    this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g;
    this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b;
    this.toRGB = function() {
        return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")"
    };
    this.toHex = function() {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r.length == 1)
            r = "0" + r;
        if (g.length == 1)
            g = "0" + g;
        if (b.length == 1)
            b = "0" + b;
        return "#" + r + g + b
    };
    this.getHelpXML = function() {
        var examples = new Array;
        for (var i = 0; i < color_defs.length; i++) {
            var example = color_defs[i].example;
            for (var j = 0; j < example.length; j++) {
                examples[examples.length] = example[j]
            }
        }
        for (var sc in simple_colors) {
            examples[examples.length] = sc
        }
        var xml = document.createElement("ul");
        xml.setAttribute("id", "rgbcolor-examples");
        for (var i = 0; i < examples.length; i++) {
            try {
                var list_item = document.createElement("li");
                var list_color = new RGBColor(examples[i]);
                var example_div = document.createElement("div");
                example_div.style.cssText = "margin: 3px; " + "border: 1px solid black; " + "background:" + list_color.toHex() + "; " + "color:" + list_color.toHex();
                example_div.appendChild(document.createTextNode("test"));
                var list_item_value = document.createTextNode(" " + examples[i] + " -> " + list_color.toRGB() + " -> " + list_color.toHex());
                list_item.appendChild(example_div);
                list_item.appendChild(list_item_value);
                xml.appendChild(list_item)
            } catch (e) {
            }
        }
        return xml
    }
}
var mul_table = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
var shg_table = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
function stackBlurImage(imageID, canvasID, radius, blurAlphaChannel) {
    var img = document.getElementById(imageID);
    var w = img.naturalWidth;
    var h = img.naturalHeight;
    var canvas = document.getElementById(canvasID);
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    canvas.width = w;
    canvas.height = h;
    var context = canvas.getContext("2d");
    context.clearRect(0, 0, w, h);
    context.drawImage(img, 0, 0);
    if (isNaN(radius) || radius < 1)
        return;
    if (blurAlphaChannel)
        stackBlurCanvasRGBA(canvasID, 0, 0, w, h, radius);
    else
        stackBlurCanvasRGB(canvasID, 0, 0, w, h, radius)
}
function stackBlurCanvasRGBA(id, top_x, top_y, width, height, radius) {
    if (isNaN(radius) || radius < 1)
        return;
    radius |= 0;
    var canvas = document.getElementById(id);
    var context = canvas.getContext("2d");
    var imageData;
    try {
        try {
            imageData = context.getImageData(top_x, top_y, width, height)
        } catch (e) {
            try {
                netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
                imageData = context.getImageData(top_x, top_y, width, height)
            } catch (e) {
                alert("Cannot access local image");
                throw new Error("unable to access local image data: " + e);
                return
            }
        }
    } catch (e) {
        alert("Cannot access image");
        throw new Error("unable to access image data: " + e)
    }
    var pixels = imageData.data;
    var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr, pg, pb, pa, rbs;
    var div = radius + radius + 1;
    var w4 = width << 2;
    var widthMinus1 = width - 1;
    var heightMinus1 = height - 1;
    var radiusPlus1 = radius + 1;
    var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
    var stackStart = new BlurStack;
    var stack = stackStart;
    for (i = 1; i < div; i++) {
        stack = stack.next = new BlurStack;
        if (i == radiusPlus1)
            var stackEnd = stack
    }
    stack.next = stackStart;
    var stackIn = null;
    var stackOut = null;
    yw = yi = 0;
    var mul_sum = mul_table[radius];
    var shg_sum = shg_table[radius];
    for (y = 0; y < height; y++) {
        r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
        r_out_sum = radiusPlus1 * (pr = pixels[yi]);
        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
        a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
        r_sum += sumFactor * pr;
        g_sum += sumFactor * pg;
        b_sum += sumFactor * pb;
        a_sum += sumFactor * pa;
        stack = stackStart;
        for (i = 0; i < radiusPlus1; i++) {
            stack.r = pr;
            stack.g = pg;
            stack.b = pb;
            stack.a = pa;
            stack = stack.next
        }
        for (i = 1; i < radiusPlus1; i++) {
            p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
            r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
            g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
            b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
            a_sum += (stack.a = pa = pixels[p + 3]) * rbs;
            r_in_sum += pr;
            g_in_sum += pg;
            b_in_sum += pb;
            a_in_sum += pa;
            stack = stack.next
        }
        stackIn = stackStart;
        stackOut = stackEnd;
        for (x = 0; x < width; x++) {
            pixels[yi + 3] = pa = a_sum * mul_sum >> shg_sum;
            if (pa != 0) {
                pa = 255 / pa;
                pixels[yi] = (r_sum * mul_sum >> shg_sum) * pa;
                pixels[yi + 1] = (g_sum * mul_sum >> shg_sum) * pa;
                pixels[yi + 2] = (b_sum * mul_sum >> shg_sum) * pa
            } else {
                pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0
            }
            r_sum -= r_out_sum;
            g_sum -= g_out_sum;
            b_sum -= b_out_sum;
            a_sum -= a_out_sum;
            r_out_sum -= stackIn.r;
            g_out_sum -= stackIn.g;
            b_out_sum -= stackIn.b;
            a_out_sum -= stackIn.a;
            p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2;
            r_in_sum += stackIn.r = pixels[p];
            g_in_sum += stackIn.g = pixels[p + 1];
            b_in_sum += stackIn.b = pixels[p + 2];
            a_in_sum += stackIn.a = pixels[p + 3];
            r_sum += r_in_sum;
            g_sum += g_in_sum;
            b_sum += b_in_sum;
            a_sum += a_in_sum;
            stackIn = stackIn.next;
            r_out_sum += pr = stackOut.r;
            g_out_sum += pg = stackOut.g;
            b_out_sum += pb = stackOut.b;
            a_out_sum += pa = stackOut.a;
            r_in_sum -= pr;
            g_in_sum -= pg;
            b_in_sum -= pb;
            a_in_sum -= pa;
            stackOut = stackOut.next;
            yi += 4
        }
        yw += width
    }
    for (x = 0; x < width; x++) {
        g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
        yi = x << 2;
        r_out_sum = radiusPlus1 * (pr = pixels[yi]);
        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
        a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
        r_sum += sumFactor * pr;
        g_sum += sumFactor * pg;
        b_sum += sumFactor * pb;
        a_sum += sumFactor * pa;
        stack = stackStart;
        for (i = 0; i < radiusPlus1; i++) {
            stack.r = pr;
            stack.g = pg;
            stack.b = pb;
            stack.a = pa;
            stack = stack.next
        }
        yp = width;
        for (i = 1; i <= radius; i++) {
            yi = yp + x << 2;
            r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
            g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
            b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;
            a_sum += (stack.a = pa = pixels[yi + 3]) * rbs;
            r_in_sum += pr;
            g_in_sum += pg;
            b_in_sum += pb;
            a_in_sum += pa;
            stack = stack.next;
            if (i < heightMinus1) {
                yp += width
            }
        }
        yi = x;
        stackIn = stackStart;
        stackOut = stackEnd;
        for (y = 0; y < height; y++) {
            p = yi << 2;
            pixels[p + 3] = pa = a_sum * mul_sum >> shg_sum;
            if (pa > 0) {
                pa = 255 / pa;
                pixels[p] = (r_sum * mul_sum >> shg_sum) * pa;
                pixels[p + 1] = (g_sum * mul_sum >> shg_sum) * pa;
                pixels[p + 2] = (b_sum * mul_sum >> shg_sum) * pa
            } else {
                pixels[p] = pixels[p + 1] = pixels[p + 2] = 0
            }
            r_sum -= r_out_sum;
            g_sum -= g_out_sum;
            b_sum -= b_out_sum;
            a_sum -= a_out_sum;
            r_out_sum -= stackIn.r;
            g_out_sum -= stackIn.g;
            b_out_sum -= stackIn.b;
            a_out_sum -= stackIn.a;
            p = x + ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2;
            r_sum += r_in_sum += stackIn.r = pixels[p];
            g_sum += g_in_sum += stackIn.g = pixels[p + 1];
            b_sum += b_in_sum += stackIn.b = pixels[p + 2];
            a_sum += a_in_sum += stackIn.a = pixels[p + 3];
            stackIn = stackIn.next;
            r_out_sum += pr = stackOut.r;
            g_out_sum += pg = stackOut.g;
            b_out_sum += pb = stackOut.b;
            a_out_sum += pa = stackOut.a;
            r_in_sum -= pr;
            g_in_sum -= pg;
            b_in_sum -= pb;
            a_in_sum -= pa;
            stackOut = stackOut.next;
            yi += width
        }
    }
    context.putImageData(imageData, top_x, top_y)
}
function stackBlurCanvasRGB(id, top_x, top_y, width, height, radius) {
    if (isNaN(radius) || radius < 1)
        return;
    radius |= 0;
    var canvas = document.getElementById(id);
    var context = canvas.getContext("2d");
    var imageData;
    try {
        try {
            imageData = context.getImageData(top_x, top_y, width, height)
        } catch (e) {
            try {
                netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
                imageData = context.getImageData(top_x, top_y, width, height)
            } catch (e) {
                alert("Cannot access local image");
                throw new Error("unable to access local image data: " + e);
                return
            }
        }
    } catch (e) {
        alert("Cannot access image");
        throw new Error("unable to access image data: " + e)
    }
    var pixels = imageData.data;
    var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, r_out_sum, g_out_sum, b_out_sum, r_in_sum, g_in_sum, b_in_sum, pr, pg, pb, rbs;
    var div = radius + radius + 1;
    var w4 = width << 2;
    var widthMinus1 = width - 1;
    var heightMinus1 = height - 1;
    var radiusPlus1 = radius + 1;
    var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
    var stackStart = new BlurStack;
    var stack = stackStart;
    for (i = 1; i < div; i++) {
        stack = stack.next = new BlurStack;
        if (i == radiusPlus1)
            var stackEnd = stack
    }
    stack.next = stackStart;
    var stackIn = null;
    var stackOut = null;
    yw = yi = 0;
    var mul_sum = mul_table[radius];
    var shg_sum = shg_table[radius];
    for (y = 0; y < height; y++) {
        r_in_sum = g_in_sum = b_in_sum = r_sum = g_sum = b_sum = 0;
        r_out_sum = radiusPlus1 * (pr = pixels[yi]);
        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
        r_sum += sumFactor * pr;
        g_sum += sumFactor * pg;
        b_sum += sumFactor * pb;
        stack = stackStart;
        for (i = 0; i < radiusPlus1; i++) {
            stack.r = pr;
            stack.g = pg;
            stack.b = pb;
            stack = stack.next
        }
        for (i = 1; i < radiusPlus1; i++) {
            p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
            r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
            g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
            b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
            r_in_sum += pr;
            g_in_sum += pg;
            b_in_sum += pb;
            stack = stack.next
        }
        stackIn = stackStart;
        stackOut = stackEnd;
        for (x = 0; x < width; x++) {
            pixels[yi] = r_sum * mul_sum >> shg_sum;
            pixels[yi + 1] = g_sum * mul_sum >> shg_sum;
            pixels[yi + 2] = b_sum * mul_sum >> shg_sum;
            r_sum -= r_out_sum;
            g_sum -= g_out_sum;
            b_sum -= b_out_sum;
            r_out_sum -= stackIn.r;
            g_out_sum -= stackIn.g;
            b_out_sum -= stackIn.b;
            p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2;
            r_in_sum += stackIn.r = pixels[p];
            g_in_sum += stackIn.g = pixels[p + 1];
            b_in_sum += stackIn.b = pixels[p + 2];
            r_sum += r_in_sum;
            g_sum += g_in_sum;
            b_sum += b_in_sum;
            stackIn = stackIn.next;
            r_out_sum += pr = stackOut.r;
            g_out_sum += pg = stackOut.g;
            b_out_sum += pb = stackOut.b;
            r_in_sum -= pr;
            g_in_sum -= pg;
            b_in_sum -= pb;
            stackOut = stackOut.next;
            yi += 4
        }
        yw += width
    }
    for (x = 0; x < width; x++) {
        g_in_sum = b_in_sum = r_in_sum = g_sum = b_sum = r_sum = 0;
        yi = x << 2;
        r_out_sum = radiusPlus1 * (pr = pixels[yi]);
        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
        r_sum += sumFactor * pr;
        g_sum += sumFactor * pg;
        b_sum += sumFactor * pb;
        stack = stackStart;
        for (i = 0; i < radiusPlus1; i++) {
            stack.r = pr;
            stack.g = pg;
            stack.b = pb;
            stack = stack.next
        }
        yp = width;
        for (i = 1; i <= radius; i++) {
            yi = yp + x << 2;
            r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
            g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
            b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;
            r_in_sum += pr;
            g_in_sum += pg;
            b_in_sum += pb;
            stack = stack.next;
            if (i < heightMinus1) {
                yp += width
            }
        }
        yi = x;
        stackIn = stackStart;
        stackOut = stackEnd;
        for (y = 0; y < height; y++) {
            p = yi << 2;
            pixels[p] = r_sum * mul_sum >> shg_sum;
            pixels[p + 1] = g_sum * mul_sum >> shg_sum;
            pixels[p + 2] = b_sum * mul_sum >> shg_sum;
            r_sum -= r_out_sum;
            g_sum -= g_out_sum;
            b_sum -= b_out_sum;
            r_out_sum -= stackIn.r;
            g_out_sum -= stackIn.g;
            b_out_sum -= stackIn.b;
            p = x + ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2;
            r_sum += r_in_sum += stackIn.r = pixels[p];
            g_sum += g_in_sum += stackIn.g = pixels[p + 1];
            b_sum += b_in_sum += stackIn.b = pixels[p + 2];
            stackIn = stackIn.next;
            r_out_sum += pr = stackOut.r;
            g_out_sum += pg = stackOut.g;
            b_out_sum += pb = stackOut.b;
            r_in_sum -= pr;
            g_in_sum -= pg;
            b_in_sum -= pb;
            stackOut = stackOut.next;
            yi += width
        }
    }
    context.putImageData(imageData, top_x, top_y)
}
function BlurStack() {
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.a = 0;
    this.next = null
}
joint.dia.Paper.prototype.toDataURL = function(callback, options) {
    if (typeof this.toSVG !== "function")
        throw new Error("The joint.format.svg.js plugin must be loaded.");
    options = options || {};
    var imageWidth, imageHeight, contentHeight, contentWidth, padding = options.padding || 0;
    if (!options.width || !options.height) {
        var clientRect = this.viewport.getBoundingClientRect();
        contentWidth = clientRect.width || 1;
        contentHeight = clientRect.height || 1;
        imageWidth = contentWidth + 2 * padding;
        imageHeight = contentHeight + 2 * padding
    } else {
        imageWidth = options.width;
        imageHeight = options.height;
        padding = Math.min(padding, imageWidth / 2 - 1, imageHeight / 2 - 1);
        contentWidth = imageWidth - 2 * padding;
        contentHeight = imageHeight - 2 * padding
    }
    var img = new Image;
    var svg;
    img.onload = function() {
        var dataURL, context, canvas;
        function createCanvas() {
            canvas = document.createElement("canvas");
            canvas.width = imageWidth;
            canvas.height = imageHeight;
            context = canvas.getContext("2d");
            context.fillStyle = options.backgroundColor || "white";
            context.fillRect(0, 0, imageWidth, imageHeight)
        }
        createCanvas();
        try {
            context.drawImage(img, padding, padding, contentWidth, contentHeight);
            dataURL = canvas.toDataURL(options.type, options.quality);
            callback(dataURL)
        } catch (e) {
            if (typeof canvg === "undefined") {
                return console.error("Canvas tainted. Canvg library required.")
            }
            createCanvas();
            function replaceSVGImagesWithSVGEmbedded(svg) {
                return svg.replace(/\<image[^>]*>/g, function(imageTag) {
                    var href = imageTag.match(/href="([^"]*)"/)[1];
                    var svgDataUriPrefix = "data:image/svg+xml";
                    if (href.substr(0, svgDataUriPrefix.length) === svgDataUriPrefix) {
                        var svg = decodeURIComponent(href.substr(href.indexOf(",") + 1));
                        return svg.substr(svg.indexOf("<svg"))
                    }
                    return imageTag
                })
            }
            var canvgOpt = {ignoreDimensions: true,ignoreClear: true,offsetX: padding,offsetY: padding,useCORS: true};
            canvg(canvas, svg, _.extend({}, canvgOpt, {renderCallback: function() {
                try {
                    dataURL = canvas.toDataURL(options.type, options.quality);
                    callback(dataURL)
                } catch (e) {
                    svg = replaceSVGImagesWithSVGEmbedded(svg);
                    createCanvas();
                    canvg(canvas, svg, _.extend({}, canvgOpt, {renderCallback: function() {
                        dataURL = canvas.toDataURL(options.type, options.quality);
                        callback(dataURL)
                    }}))
                }
            }}));
            return
        }
    };
    this.toSVG(function(svgString) {
        svg = svgString = svgString.replace('width="100%"', 'width="' + contentWidth + '"').replace('height="100%"', 'height="' + contentHeight + '"');
        img.src = "data:image/svg+xml," + encodeURIComponent(svgString)
    }, {convertImagesToDataUris: true})
};
joint.dia.Paper.prototype.toPNG = function(callback, options) {
    options = options || {};
    options.type = "image/png";
    this.toDataURL(callback, options)
};
joint.dia.Paper.prototype.toJPEG = function(callback, options) {
    options = options || {};
    options.type = "image/jpeg";
    this.toDataURL(callback, options)
};
joint.dia.Paper.prototype.openAsPNG = function(opt) {
    var windowFeatures = "menubar=yes,location=yes,resizable=yes,scrollbars=yes,status=yes";
    var windowName = _.uniqueId("png_output");
    this.toPNG(function(dataURL) {
        var imageWindow = window.open("", windowName, windowFeatures);
        imageWindow.document.write('<img src="' + dataURL + '"/>')
    }, _.extend({padding: 10}, opt))
};
(function() {
    var printEvents = "onbeforeprint" in window;
    function beforePrint(opt, data) {
        var svg = V(this.svg);
        var paddingLeft = opt.paddingLeft || opt.padding;
        var paddingRight = opt.paddingRight || opt.padding;
        var paddingTop = opt.paddingTop || opt.padding;
        var paddingBottom = opt.paddingBottom || opt.padding;
        var bbox = this.getContentBBox().moveAndExpand({x: -paddingLeft,y: -paddingTop,width: paddingLeft + paddingRight,height: paddingTop + paddingBottom});
        data.attrs = {width: svg.attr("width"),height: svg.attr("height"),viewBox: svg.attr("viewBox")};
        data.scrollLeft = this.el.scrollLeft;
        data.scrollTop = this.el.scrollTop;
        svg.attr({width: "100%",height: "100%",viewBox: [bbox.x, bbox.y, bbox.width, bbox.height].join(" ")});
        this.$el.addClass("printarea").addClass(opt.size);
        if (opt.detachBody) {
            data.$parent = this.$el.parent();
            data.index = data.$parent.children().index(this.$el);
            data.$content = $(document.body).children().detach();
            this.$el.appendTo(document.body)
        }
    }
    function afterPrint(opt, data) {
        var svg = V(this.svg);
        var isWebkit = !!window.chrome && !window.opera;
        var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
        if ((isWebkit || isFirefox) && !data.attrs.viewBox) {
            svg.node.removeAttributeNS(null, "viewBox");
            delete data.attrs.viewBox
        }
        svg.attr(data.attrs);
        this.$el.removeClass("printarea").removeClass(opt.size);
        if (opt.detachBody) {
            if (data.$parent.children().length) {
                data.$parent.children().eq(data.index).before(this.$el)
            } else {
                this.$el.appendTo(data.$parent)
            }
            data.$content.appendTo(document.body)
        }
        this.el.scrollLeft = data.scrollLeft;
        this.el.scrollTop = data.scrollTop
    }
    joint.dia.Paper.prototype.print = function(opt) {
        opt = opt || {};
        _.defaults(opt, {size: "a4",padding: 5,detachBody: true});
        var data = {};
        var localBeforePrint = _.bind(beforePrint, this, opt, data);
        var localAfterPrint = _.bind(afterPrint, this, opt, data);
        if (printEvents) {
            $(window).one("beforeprint", localBeforePrint);
            $(window).one("afterprint", localAfterPrint)
        } else {
            localBeforePrint()
        }
        window.print();
        if (!printEvents) {
            var onceAfterPrint = _.once(localAfterPrint);
            $(document).one("mouseover", onceAfterPrint);
            _.delay(onceAfterPrint, 1e3)
        }
    }
})();
joint.dia.CommandManager = Backbone.Model.extend({defaults: {cmdBeforeAdd: null,cmdNameRegex: /^(?:add|remove|change:\w+)$/},PREFIX_LENGTH: 7,initialize: function(options) {
    _.bindAll(this, "initBatchCommand", "storeBatchCommand");
    this.graph = options.graph;
    this.reset();
    this.listen()
},listen: function() {
    this.listenTo(this.graph, "all", this.addCommand, this);
    this.listenTo(this.graph, "batch:start", this.initBatchCommand, this);
    this.listenTo(this.graph, "batch:stop", this.storeBatchCommand, this)
},createCommand: function(options) {
    var cmd = {action: undefined,data: {id: undefined,type: undefined,previous: {},next: {}},batch: options && options.batch};
    return cmd
},addCommand: function(cmdName, cell, graph, options) {
    if (!this.get("cmdNameRegex").test(cmdName)) {
        return
    }
    if (typeof this.get("cmdBeforeAdd") == "function" && !this.get("cmdBeforeAdd").apply(this, arguments)) {
        return
    }
    var push = _.bind(function(cmd) {
        this.redoStack = [];
        if (!cmd.batch) {
            this.undoStack.push(cmd);
            this.trigger("add", cmd)
        } else {
            this.lastCmdIndex = Math.max(this.lastCmdIndex, 0);
            this.trigger("batch", cmd)
        }
    }, this);
    var command = undefined;
    if (this.batchCommand) {
        command = this.batchCommand[Math.max(this.lastCmdIndex, 0)];
        if (this.lastCmdIndex >= 0 && (command.data.id !== cell.id || command.action !== cmdName)) {
            command = _.find(this.batchCommand, function(cmd, index) {
                this.lastCmdIndex = index;
                return cmd.data.id === cell.id && cmd.action === cmdName
            }, this);
            if (!command) {
                this.lastCmdIndex = this.batchCommand.push(this.createCommand({batch: true})) - 1;
                command = _.last(this.batchCommand)
            }
        }
    } else {
        command = this.createCommand();
        command.batch = false
    }
    if (cmdName === "add" || cmdName === "remove") {
        command.action = cmdName;
        command.data.id = cell.id;
        command.data.type = cell.attributes.type;
        command.data.attributes = _.merge({}, cell.toJSON());
        command.options = options || {};
        return push(command)
    }
    var changedAttribute = cmdName.substr(this.PREFIX_LENGTH);
    if (!command.batch || !command.action) {
        command.action = cmdName;
        command.data.id = cell.id;
        command.data.type = cell.attributes.type;
        command.data.previous[changedAttribute] = _.clone(cell.previous(changedAttribute));
        command.options = options || {}
    }
    command.data.next[changedAttribute] = _.clone(cell.get(changedAttribute));
    return push(command)
},initBatchCommand: function() {
    if (!this.batchCommand) {
        this.batchCommand = [this.createCommand({batch: true})];
        this.lastCmdIndex = -1;
        this.batchLevel = 0
    } else {
        this.batchLevel++
    }
},storeBatchCommand: function() {
    if (this.batchCommand && this.batchLevel <= 0) {
        if (this.lastCmdIndex >= 0) {
            this.redoStack = [];
            this.undoStack.push(this.batchCommand);
            this.trigger("add", this.batchCommand)
        }
        delete this.batchCommand;
        delete this.lastCmdIndex;
        delete this.batchLevel
    } else if (this.batchCommand && this.batchLevel > 0) {
        this.batchLevel--
    }
},revertCommand: function(command) {
    this.stopListening();
    var batchCommand;
    if (_.isArray(command)) {
        batchCommand = command
    } else {
        batchCommand = [command]
    }
    for (var i = batchCommand.length - 1; i >= 0; i--) {
        var cmd = batchCommand[i], cell = this.graph.getCell(cmd.data.id);
        switch (cmd.action) {
            case "add":
                cell.remove();
                break;
            case "remove":
                this.graph.addCell(cmd.data.attributes);
                break;
            default:
                var attribute = cmd.action.substr(this.PREFIX_LENGTH);
                cell.set(attribute, cmd.data.previous[attribute]);
                break
        }
    }
    this.listen()
},applyCommand: function(command) {
    this.stopListening();
    var batchCommand;
    if (_.isArray(command)) {
        batchCommand = command
    } else {
        batchCommand = [command]
    }
    for (var i = 0; i < batchCommand.length; i++) {
        var cmd = batchCommand[i], cell = this.graph.getCell(cmd.data.id);
        switch (cmd.action) {
            case "add":
                this.graph.addCell(cmd.data.attributes);
                break;
            case "remove":
                cell.remove();
                break;
            default:
                var attribute = cmd.action.substr(this.PREFIX_LENGTH);
                cell.set(attribute, cmd.data.next[attribute]);
                break
        }
    }
    this.listen()
},undo: function() {
    var command = this.undoStack.pop();
    if (command) {
        this.revertCommand(command);
        this.redoStack.push(command)
    }
},redo: function() {
    var command = this.redoStack.pop();
    if (command) {
        this.applyCommand(command);
        this.undoStack.push(command)
    }
},cancel: function() {
    if (this.hasUndo()) {
        this.revertCommand(this.undoStack.pop());
        this.redoStack = []
    }
},reset: function() {
    this.undoStack = [];
    this.redoStack = []
},hasUndo: function() {
    return this.undoStack.length > 0
},hasRedo: function() {
    return this.redoStack.length > 0
}});
joint.dia.Validator = Backbone.Model.extend({initialize: function(options) {
    this._map = {};
    this._commandManager = options.commandManager;
    this.listenTo(this._commandManager, "add", this._onCommand)
},defaults: {cancelInvalid: true},_onCommand: function(command) {
    return _.isArray(command) ? _.find(command, function(singleCmd) {
        return !this._validateCommand(singleCmd)
    }, this) : this._validateCommand(command)
},_validateCommand: function(command) {
    if (command.options && command.options.validation === false)
        return true;
    var handoverErr;
    _.each(this._map[command.action], function(route) {
        var i = 0;
        function callbacks(err) {
            var fn = route[i++];
            try {
                if (fn) {
                    fn(err, command, callbacks)
                } else {
                    handoverErr = err;
                    return
                }
            } catch (err) {
                callbacks(err)
            }
        }
        callbacks(handoverErr)
    });
    if (handoverErr) {
        if (this.get("cancelInvalid"))
            this._commandManager.cancel();
        this.trigger("invalid", handoverErr);
        return false
    }
    return true
},validate: function(actions) {
    var callbacks = _.rest(arguments);
    _.each(callbacks, function(callback) {
        if (_.isFunction(callback))
            return;
        throw new Error(actions + " requires callback functions.")
    });
    _.each(actions.split(" "), function(action) {
        (this._map[action] = this._map[action] || []).push(callbacks)
    }, this);
    return this
}});
joint.dia.Graph.prototype.constructTree = function(parent, opt, parentElement, collector) {
    collector = collector || [];
    var children = _.isFunction(opt.children) ? opt.children(parent) : parent[opt.children || "children"];
    if (!parentElement) {
        parentElement = opt.makeElement(parent);
        collector.push(parentElement)
    }
    _.each(children, function(child) {
        var childElement = opt.makeElement(child);
        var link = opt.makeLink(parentElement, childElement);
        collector.push(childElement, link);
        this.constructTree(child, opt, childElement, collector)
    }, this);
    return collector
};
joint.dia.Graph.prototype.shortestPath = function(source, target, opt) {
    opt = opt || {};
    var adjacencyList = {};
    _.each(this.getLinks(), function(link) {
        var sourceId = link.get("source").id;
        var targetId = link.get("target").id;
        if (!adjacencyList[sourceId]) {
            adjacencyList[sourceId] = []
        }
        if (!adjacencyList[targetId]) {
            adjacencyList[targetId] = []
        }
        adjacencyList[sourceId].push(targetId);
        if (!opt.directed) {
            adjacencyList[targetId].push(sourceId)
        }
    });
    var previous = joint.alg.Dijkstra(adjacencyList, source.id || source, opt.weight);
    var path = [];
    var u = target.id || target;
    if (previous[u])
        path.push(u);
    while (u = previous[u]) {
        path.unshift(u)
    }
    return path
};
joint.layout.ForceDirected = Backbone.Model.extend({defaults: {linkDistance: 10,linkStrength: 1,charge: 10},initialize: function(opt) {
    this.elements = this.get("graph").getElements();
    this.links = this.get("graph").getLinks();
    this.cells = this.get("graph").get("cells");
    this.width = this.get("width");
    this.height = this.get("height");
    this.gravityCenter = this.get("gravityCenter");
    this.t = 1;
    this.energy = Infinity;
    this.progress = 0
},start: function() {
    var w = this.get("width");
    var h = this.get("height");
    var elementsJSON = [];
    var linksJSON = [];
    _.each(this.elements, function(el) {
        el.set("position", {x: Math.random() * w,y: Math.random() * h});
        el.charge = el.get("charge") || this.get("charge");
        el.weight = el.get("weight") || 1;
        var pos = el.get("position");
        el.x = pos.x;
        el.y = pos.y;
        el.px = el.x;
        el.py = el.y;
        el.fx = 0;
        el.fy = 0
    }, this);
    _.each(this.links, function(link) {
        link.strength = link.get("strength") || this.get("linkStrength");
        link.distance = link.get("distance") || this.get("linkDistance");
        link.source = this.cells.get(link.get("source").id);
        link.target = this.cells.get(link.get("target").id)
    }, this)
},step: function() {
    if (this.t * .99 < .005)
        return this.notifyEnd();
    var w = this.width;
    var h = this.height;
    var gravity = .1;
    var gravityCenter = this.gravityCenter;
    var energyBefore = this.energy;
    this.energy = 0;
    var xBefore = 0;
    var yBefore = 0;
    var xAfter = 0;
    var yAfter = 0;
    var i, j;
    var nElements = this.elements.length;
    var nLinks = this.links.length;
    for (i = 0; i < nElements - 1; i++) {
        var v = this.elements[i];
        xBefore += v.x;
        yBefore += v.y;
        for (j = i + 1; j < nElements; j++) {
            var u = this.elements[j];
            var dx = u.x - v.x;
            var dy = u.y - v.y;
            var distanceSquared = dx * dx + dy * dy;
            var distance = Math.sqrt(distanceSquared);
            var fr = this.t * v.charge / distanceSquared;
            var fx = fr * dx;
            var fy = fr * dy;
            v.fx -= fx;
            v.fy -= fy;
            u.fx += fx;
            u.fy += fy;
            this.energy += fx * fx + fy * fy
        }
    }
    xBefore += this.elements[nElements - 1].x;
    yBefore += this.elements[nElements - 1].y;
    for (i = 0; i < nLinks; i++) {
        var link = this.links[i];
        var v = link.source;
        var u = link.target;
        var dx = u.x - v.x;
        var dy = u.y - v.y;
        var distanceSquared = dx * dx + dy * dy;
        var distance = Math.sqrt(distanceSquared);
        var fa = this.t * link.strength * (distance - link.distance) / distance;
        var fx = fa * dx;
        var fy = fa * dy;
        var k = v.weight / (v.weight + u.weight);
        v.x += fx * (1 - k);
        v.y += fy * (1 - k);
        u.x -= fx * k;
        u.y -= fy * k;
        this.energy += fx * fx + fy * fy
    }
    for (i = 0; i < nElements; i++) {
        var el = this.elements[i];
        var pos = {x: el.x,y: el.y};
        if (gravityCenter) {
            pos.x += (gravityCenter.x - pos.x) * this.t * gravity;
            pos.y += (gravityCenter.y - pos.y) * this.t * gravity
        }
        pos.x += el.fx;
        pos.y += el.fy;
        pos.x = Math.max(0, Math.min(w, pos.x));
        pos.y = Math.max(0, Math.min(h, pos.y));
        var friction = .9;
        pos.x += (el.px - pos.x) * friction;
        pos.y += (el.py - pos.y) * friction;
        el.px = pos.x;
        el.py = pos.y;
        el.fx = el.fy = 0;
        el.x = pos.x;
        el.y = pos.y;
        xAfter += el.x;
        yAfter += el.y;
        this.notify(el, i, pos)
    }
    this.t = this.cool(this.t, this.energy, energyBefore);
    var gdx = xBefore - xAfter;
    var gdy = yBefore - yAfter;
    var gd = Math.sqrt(gdx * gdx + gdy * gdy);
    if (gd < 1) {
        this.notifyEnd()
    }
},cool: function(t, energy, energyBefore) {
    if (energy < energyBefore) {
        this.progress += 1;
        if (this.progress >= 5) {
            this.progress = 0;
            return t / .99
        }
    } else {
        this.progress = 0;
        return t * .99
    }
    return t
},notify: function(el, i, pos) {
    el.set("position", pos)
},notifyEnd: function() {
    this.trigger("end")
}});
joint.layout = joint.layout || {};
joint.layout.GridLayout = {layout: function(graph, opt) {
    opt = opt || {};
    var elements = graph.getElements();
    var columns = opt.columns || 1;
    var dx = opt.dx || 0;
    var dy = opt.dy || 0;
    var columnWidth = opt.columnWidth || this._maxDim(elements, "width") + dx;
    var rowHeight = opt.rowHeight || this._maxDim(elements, "height") + dy;
    var centre = _.isUndefined(opt.centre) || opt.centre !== false;
    var resizeToFit = !!opt.resizeToFit;
    _.each(elements, function(element, index) {
        var cx = 0, cy = 0, elementSize = element.get("size");
        if (resizeToFit) {
            var elementWidth = columnWidth - 2 * dx;
            var elementHeight = rowHeight - 2 * dy;
            var calcElHeight = elementSize.height * (elementSize.width ? elementWidth / elementSize.width : 1);
            var calcElWidth = elementSize.width * (elementSize.height ? elementHeight / elementSize.height : 1);
            if (calcElHeight > rowHeight) {
                elementWidth = calcElWidth
            } else {
                elementHeight = calcElHeight
            }
            elementSize = {width: elementWidth,height: elementHeight};
            element.set("size", elementSize)
        }
        if (centre) {
            cx = (columnWidth - elementSize.width) / 2;
            cy = (rowHeight - elementSize.height) / 2
        }
        element.set("position", {x: index % columns * columnWidth + dx + cx,y: Math.floor(index / columns) * rowHeight + dy + cy})
    })
},_maxDim: function(elements, dimension) {
    return _.reduce(elements, function(max, el) {
        return Math.max(el.get("size")[dimension], max)
    }, 0)
}};
(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a)
                    return a(o, !0);
                if (i)
                    return i(o, !0);
                throw new Error("Cannot find module '" + o + "'")
            }
            var f = n[o] = {exports: {}};
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e)
            }, f, f.exports, e, t, n, r)
        }
        return n[o].exports
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++)
        s(r[o]);
    return s
})({1: [function(require, module, exports) {
    var global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
    global.dagre = require("./index")
}, {"./index": 2}],2: [function(require, module, exports) {
    exports.Digraph = require("graphlib").Digraph;
    exports.Graph = require("graphlib").Graph;
    exports.layout = require("./lib/layout");
    exports.version = require("./lib/version")
}, {"./lib/layout": 3,"./lib/version": 18,graphlib: 24}],3: [function(require, module, exports) {
    var util = require("./util"), rank = require("./rank"), order = require("./order"), CGraph = require("graphlib").CGraph, CDigraph = require("graphlib").CDigraph;
    module.exports = function() {
        var config = {debugLevel: 0,orderMaxSweeps: order.DEFAULT_MAX_SWEEPS,rankSimplex: false,rankDir: "TB"};
        var position = require("./position")();
        var self = {};
        self.orderIters = util.propertyAccessor(self, config, "orderMaxSweeps");
        self.rankSimplex = util.propertyAccessor(self, config, "rankSimplex");
        self.nodeSep = delegateProperty(position.nodeSep);
        self.edgeSep = delegateProperty(position.edgeSep);
        self.universalSep = delegateProperty(position.universalSep);
        self.rankSep = delegateProperty(position.rankSep);
        self.rankDir = util.propertyAccessor(self, config, "rankDir");
        self.debugAlignment = delegateProperty(position.debugAlignment);
        self.debugLevel = util.propertyAccessor(self, config, "debugLevel", function(x) {
            util.log.level = x;
            position.debugLevel(x)
        });
        self.run = util.time("Total layout", run);
        self._normalize = normalize;
        return self;
        function initLayoutGraph(inputGraph) {
            var g = new CDigraph;
            inputGraph.eachNode(function(u, value) {
                if (value === undefined)
                    value = {};
                g.addNode(u, {width: value.width,height: value.height});
                if (value.hasOwnProperty("rank")) {
                    g.node(u).prefRank = value.rank
                }
            });
            if (inputGraph.parent) {
                inputGraph.nodes().forEach(function(u) {
                    g.parent(u, inputGraph.parent(u))
                })
            }
            inputGraph.eachEdge(function(e, u, v, value) {
                if (value === undefined)
                    value = {};
                var newValue = {e: e,minLen: value.minLen || 1,width: value.width || 0,height: value.height || 0,points: []};
                g.addEdge(null, u, v, newValue)
            });
            var graphValue = inputGraph.graph() || {};
            g.graph({rankDir: graphValue.rankDir || config.rankDir,orderRestarts: graphValue.orderRestarts});
            return g
        }
        function run(inputGraph) {
            var rankSep = self.rankSep();
            var g;
            try {
                g = util.time("initLayoutGraph", initLayoutGraph)(inputGraph);
                if (g.order() === 0) {
                    return g
                }
                g.eachEdge(function(e, s, t, a) {
                    a.minLen *= 2
                });
                self.rankSep(rankSep / 2);
                util.time("rank.run", rank.run)(g, config.rankSimplex);
                util.time("normalize", normalize)(g);
                util.time("order", order)(g, config.orderMaxSweeps);
                util.time("position", position.run)(g);
                util.time("undoNormalize", undoNormalize)(g);
                util.time("fixupEdgePoints", fixupEdgePoints)(g);
                util.time("rank.restoreEdges", rank.restoreEdges)(g);
                return util.time("createFinalGraph", createFinalGraph)(g, inputGraph.isDirected())
            }finally {
                self.rankSep(rankSep)
            }
        }
        function normalize(g) {
            var dummyCount = 0;
            g.eachEdge(function(e, s, t, a) {
                var sourceRank = g.node(s).rank;
                var targetRank = g.node(t).rank;
                if (sourceRank + 1 < targetRank) {
                    for (var u = s, rank = sourceRank + 1, i = 0; rank < targetRank; ++rank, ++i) {
                        var v = "_D" + ++dummyCount;
                        var node = {width: a.width,height: a.height,edge: {id: e,source: s,target: t,attrs: a},rank: rank,dummy: true};
                        if (i === 0)
                            node.index = 0;
                        else if (rank + 1 === targetRank)
                            node.index = 1;
                        g.addNode(v, node);
                        g.addEdge(null, u, v, {});
                        u = v
                    }
                    g.addEdge(null, u, t, {});
                    g.delEdge(e)
                }
            })
        }
        function undoNormalize(g) {
            g.eachNode(function(u, a) {
                if (a.dummy) {
                    if ("index" in a) {
                        var edge = a.edge;
                        if (!g.hasEdge(edge.id)) {
                            g.addEdge(edge.id, edge.source, edge.target, edge.attrs)
                        }
                        var points = g.edge(edge.id).points;
                        points[a.index] = {x: a.x,y: a.y,ul: a.ul,ur: a.ur,dl: a.dl,dr: a.dr}
                    }
                    g.delNode(u)
                }
            })
        }
        function fixupEdgePoints(g) {
            g.eachEdge(function(e, s, t, a) {
                if (a.reversed)
                    a.points.reverse()
            })
        }
        function createFinalGraph(g, isDirected) {
            var out = isDirected ? new CDigraph : new CGraph;
            out.graph(g.graph());
            g.eachNode(function(u, value) {
                out.addNode(u, value)
            });
            g.eachNode(function(u) {
                out.parent(u, g.parent(u))
            });
            g.eachEdge(function(e, u, v, value) {
                out.addEdge(value.e, u, v, value)
            });
            var maxX = 0, maxY = 0;
            g.eachNode(function(u, value) {
                if (!g.children(u).length) {
                    maxX = Math.max(maxX, value.x + value.width / 2);
                    maxY = Math.max(maxY, value.y + value.height / 2)
                }
            });
            g.eachEdge(function(e, u, v, value) {
                var maxXPoints = Math.max.apply(Math, value.points.map(function(p) {
                    return p.x
                }));
                var maxYPoints = Math.max.apply(Math, value.points.map(function(p) {
                    return p.y
                }));
                maxX = Math.max(maxX, maxXPoints + value.width / 2);
                maxY = Math.max(maxY, maxYPoints + value.height / 2)
            });
            out.graph().width = maxX;
            out.graph().height = maxY;
            return out
        }
        function delegateProperty(f) {
            return function() {
                if (!arguments.length)
                    return f();
                f.apply(null, arguments);
                return self
            }
        }
    }
}, {"./order": 4,"./position": 9,"./rank": 10,"./util": 17,graphlib: 24}],4: [function(require, module, exports) {
    var util = require("./util"), crossCount = require("./order/crossCount"), initLayerGraphs = require("./order/initLayerGraphs"), initOrder = require("./order/initOrder"), sortLayer = require("./order/sortLayer");
    module.exports = order;
    var DEFAULT_MAX_SWEEPS = 24;
    order.DEFAULT_MAX_SWEEPS = DEFAULT_MAX_SWEEPS;
    function order(g, maxSweeps) {
        if (arguments.length < 2) {
            maxSweeps = DEFAULT_MAX_SWEEPS
        }
        var restarts = g.graph().orderRestarts || 0;
        var layerGraphs = initLayerGraphs(g);
        layerGraphs.forEach(function(lg) {
            lg = lg.filterNodes(function(u) {
                return !g.children(u).length
            })
        });
        var iters = 0, currentBestCC, allTimeBestCC = Number.MAX_VALUE, allTimeBest = {};
        function saveAllTimeBest() {
            g.eachNode(function(u, value) {
                allTimeBest[u] = value.order
            })
        }
        for (var j = 0; j < Number(restarts) + 1 && allTimeBestCC !== 0; ++j) {
            currentBestCC = Number.MAX_VALUE;
            initOrder(g, restarts > 0);
            util.log(2, "Order phase start cross count: " + g.graph().orderInitCC);
            var i, lastBest, cc;
            for (i = 0, lastBest = 0; lastBest < 4 && i < maxSweeps && currentBestCC > 0; ++i, ++lastBest, ++iters) {
                sweep(g, layerGraphs, i);
                cc = crossCount(g);
                if (cc < currentBestCC) {
                    lastBest = 0;
                    currentBestCC = cc;
                    if (cc < allTimeBestCC) {
                        saveAllTimeBest();
                        allTimeBestCC = cc
                    }
                }
                util.log(3, "Order phase start " + j + " iter " + i + " cross count: " + cc)
            }
        }
        Object.keys(allTimeBest).forEach(function(u) {
            if (!g.children || !g.children(u).length) {
                g.node(u).order = allTimeBest[u]
            }
        });
        g.graph().orderCC = allTimeBestCC;
        util.log(2, "Order iterations: " + iters);
        util.log(2, "Order phase best cross count: " + g.graph().orderCC)
    }
    function predecessorWeights(g, nodes) {
        var weights = {};
        nodes.forEach(function(u) {
            weights[u] = g.inEdges(u).map(function(e) {
                return g.node(g.source(e)).order
            })
        });
        return weights
    }
    function successorWeights(g, nodes) {
        var weights = {};
        nodes.forEach(function(u) {
            weights[u] = g.outEdges(u).map(function(e) {
                return g.node(g.target(e)).order
            })
        });
        return weights
    }
    function sweep(g, layerGraphs, iter) {
        if (iter % 2 === 0) {
            sweepDown(g, layerGraphs, iter)
        } else {
            sweepUp(g, layerGraphs, iter)
        }
    }
    function sweepDown(g, layerGraphs) {
        var cg;
        for (i = 1; i < layerGraphs.length; ++i) {
            cg = sortLayer(layerGraphs[i], cg, predecessorWeights(g, layerGraphs[i].nodes()))
        }
    }
    function sweepUp(g, layerGraphs) {
        var cg;
        for (i = layerGraphs.length - 2; i >= 0; --i) {
            sortLayer(layerGraphs[i], cg, successorWeights(g, layerGraphs[i].nodes()))
        }
    }
}, {"./order/crossCount": 5,"./order/initLayerGraphs": 6,"./order/initOrder": 7,"./order/sortLayer": 8,"./util": 17}],5: [function(require, module, exports) {
    var util = require("../util");
    module.exports = crossCount;
    function crossCount(g) {
        var cc = 0;
        var ordering = util.ordering(g);
        for (var i = 1; i < ordering.length; ++i) {
            cc += twoLayerCrossCount(g, ordering[i - 1], ordering[i])
        }
        return cc
    }
    function twoLayerCrossCount(g, layer1, layer2) {
        var indices = [];
        layer1.forEach(function(u) {
            var nodeIndices = [];
            g.outEdges(u).forEach(function(e) {
                nodeIndices.push(g.node(g.target(e)).order)
            });
            nodeIndices.sort(function(x, y) {
                return x - y
            });
            indices = indices.concat(nodeIndices)
        });
        var firstIndex = 1;
        while (firstIndex < layer2.length)
            firstIndex <<= 1;
        var treeSize = 2 * firstIndex - 1;
        firstIndex -= 1;
        var tree = [];
        for (var i = 0; i < treeSize; ++i) {
            tree[i] = 0
        }
        var cc = 0;
        indices.forEach(function(i) {
            var treeIndex = i + firstIndex;
            ++tree[treeIndex];
            while (treeIndex > 0) {
                if (treeIndex % 2) {
                    cc += tree[treeIndex + 1]
                }
                treeIndex = treeIndex - 1 >> 1;
                ++tree[treeIndex]
            }
        });
        return cc
    }
}, {"../util": 17}],6: [function(require, module, exports) {
    var nodesFromList = require("graphlib").filter.nodesFromList, Set = require("cp-data").Set;
    module.exports = initLayerGraphs;
    function initLayerGraphs(g) {
        var ranks = [];
        function dfs(u) {
            if (u === null) {
                g.children(u).forEach(function(v) {
                    dfs(v)
                });
                return
            }
            var value = g.node(u);
            value.minRank = "rank" in value ? value.rank : Number.MAX_VALUE;
            value.maxRank = "rank" in value ? value.rank : Number.MIN_VALUE;
            var uRanks = new Set;
            g.children(u).forEach(function(v) {
                var rs = dfs(v);
                uRanks = Set.union([uRanks, rs]);
                value.minRank = Math.min(value.minRank, g.node(v).minRank);
                value.maxRank = Math.max(value.maxRank, g.node(v).maxRank)
            });
            if ("rank" in value)
                uRanks.add(value.rank);
            uRanks.keys().forEach(function(r) {
                if (!(r in ranks))
                    ranks[r] = [];
                ranks[r].push(u)
            });
            return uRanks
        }
        dfs(null);
        var layerGraphs = [];
        ranks.forEach(function(us, rank) {
            layerGraphs[rank] = g.filterNodes(nodesFromList(us))
        });
        return layerGraphs
    }
}, {"cp-data": 19,graphlib: 24}],7: [function(require, module, exports) {
    var crossCount = require("./crossCount"), util = require("../util");
    module.exports = initOrder;
    function initOrder(g, random) {
        var layers = [];
        g.eachNode(function(u, value) {
            var layer = layers[value.rank];
            if (g.children && g.children(u).length > 0)
                return;
            if (!layer) {
                layer = layers[value.rank] = []
            }
            layer.push(u)
        });
        layers.forEach(function(layer) {
            if (random) {
                util.shuffle(layer)
            }
            layer.forEach(function(u, i) {
                g.node(u).order = i
            })
        });
        var cc = crossCount(g);
        g.graph().orderInitCC = cc;
        g.graph().orderCC = Number.MAX_VALUE
    }
}, {"../util": 17,"./crossCount": 5}],8: [function(require, module, exports) {
    var util = require("../util");
    module.exports = sortLayer;
    function sortLayer(g, cg, weights) {
        var ordering = [];
        var bs = {};
        g.eachNode(function(u, value) {
            ordering[value.order] = u;
            var ws = weights[u];
            if (ws.length) {
                bs[u] = util.sum(ws) / ws.length
            }
        });
        var toSort = g.nodes().filter(function(u) {
            return bs[u] !== undefined
        });
        toSort.sort(function(x, y) {
            return bs[x] - bs[y] || g.node(x).order - g.node(y).order
        });
        for (var i = 0, j = 0, jl = toSort.length; j < jl; ++i) {
            if (bs[ordering[i]] !== undefined) {
                g.node(toSort[j++]).order = i
            }
        }
    }
}, {"../util": 17}],9: [function(require, module, exports) {
    var util = require("./util");
    module.exports = function() {
        var config = {nodeSep: 50,edgeSep: 10,universalSep: null,rankSep: 30};
        var self = {};
        self.nodeSep = util.propertyAccessor(self, config, "nodeSep");
        self.edgeSep = util.propertyAccessor(self, config, "edgeSep");
        self.universalSep = util.propertyAccessor(self, config, "universalSep");
        self.rankSep = util.propertyAccessor(self, config, "rankSep");
        self.debugLevel = util.propertyAccessor(self, config, "debugLevel");
        self.run = run;
        return self;
        function run(g) {
            g = g.filterNodes(util.filterNonSubgraphs(g));
            var layering = util.ordering(g);
            var conflicts = findConflicts(g, layering);
            var xss = {};
            ["u", "d"].forEach(function(vertDir) {
                if (vertDir === "d")
                    layering.reverse();
                ["l", "r"].forEach(function(horizDir) {
                    if (horizDir === "r")
                        reverseInnerOrder(layering);
                    var dir = vertDir + horizDir;
                    var align = verticalAlignment(g, layering, conflicts, vertDir === "u" ? "predecessors" : "successors");
                    xss[dir] = horizontalCompaction(g, layering, align.pos, align.root, align.align);
                    if (config.debugLevel >= 3)
                        debugPositioning(vertDir + horizDir, g, layering, xss[dir]);
                    if (horizDir === "r")
                        flipHorizontally(xss[dir]);
                    if (horizDir === "r")
                        reverseInnerOrder(layering)
                });
                if (vertDir === "d")
                    layering.reverse()
            });
            balance(g, layering, xss);
            g.eachNode(function(v) {
                var xs = [];
                for (var alignment in xss) {
                    var alignmentX = xss[alignment][v];
                    posXDebug(alignment, g, v, alignmentX);
                    xs.push(alignmentX)
                }
                xs.sort(function(x, y) {
                    return x - y
                });
                posX(g, v, (xs[1] + xs[2]) / 2)
            });
            var y = 0, reverseY = g.graph().rankDir === "BT" || g.graph().rankDir === "RL";
            layering.forEach(function(layer) {
                var maxHeight = util.max(layer.map(function(u) {
                    return height(g, u)
                }));
                y += maxHeight / 2;
                layer.forEach(function(u) {
                    posY(g, u, reverseY ? -y : y)
                });
                y += maxHeight / 2 + config.rankSep
            });
            var minX = util.min(g.nodes().map(function(u) {
                return posX(g, u) - width(g, u) / 2
            }));
            var minY = util.min(g.nodes().map(function(u) {
                return posY(g, u) - height(g, u) / 2
            }));
            g.eachNode(function(u) {
                posX(g, u, posX(g, u) - minX);
                posY(g, u, posY(g, u) - minY)
            })
        }
        function undirEdgeId(u, v) {
            return u < v ? u.toString().length + ":" + u + "-" + v : v.toString().length + ":" + v + "-" + u
        }
        function findConflicts(g, layering) {
            var conflicts = {}, pos = {}, prevLayer, currLayer, k0, l, k1;
            if (layering.length <= 2)
                return conflicts;
            function updateConflicts(v) {
                var k = pos[v];
                if (k < k0 || k > k1) {
                    conflicts[undirEdgeId(currLayer[l], v)] = true
                }
            }
            layering[1].forEach(function(u, i) {
                pos[u] = i
            });
            for (var i = 1; i < layering.length - 1; ++i) {
                prevLayer = layering[i];
                currLayer = layering[i + 1];
                k0 = 0;
                l = 0;
                for (var l1 = 0; l1 < currLayer.length; ++l1) {
                    var u = currLayer[l1];
                    pos[u] = l1;
                    k1 = undefined;
                    if (g.node(u).dummy) {
                        var uPred = g.predecessors(u)[0];
                        if (uPred !== undefined && g.node(uPred).dummy)
                            k1 = pos[uPred]
                    }
                    if (k1 === undefined && l1 === currLayer.length - 1)
                        k1 = prevLayer.length - 1;
                    if (k1 !== undefined) {
                        for (; l <= l1; ++l) {
                            g.predecessors(currLayer[l]).forEach(updateConflicts)
                        }
                        k0 = k1
                    }
                }
            }
            return conflicts
        }
        function verticalAlignment(g, layering, conflicts, relationship) {
            var pos = {}, root = {}, align = {};
            layering.forEach(function(layer) {
                layer.forEach(function(u, i) {
                    root[u] = u;
                    align[u] = u;
                    pos[u] = i
                })
            });
            layering.forEach(function(layer) {
                var prevIdx = -1;
                layer.forEach(function(v) {
                    var related = g[relationship](v), mid;
                    if (related.length > 0) {
                        related.sort(function(x, y) {
                            return pos[x] - pos[y]
                        });
                        mid = (related.length - 1) / 2;
                        related.slice(Math.floor(mid), Math.ceil(mid) + 1).forEach(function(u) {
                            if (align[v] === v) {
                                if (!conflicts[undirEdgeId(u, v)] && prevIdx < pos[u]) {
                                    align[u] = v;
                                    align[v] = root[v] = root[u];
                                    prevIdx = pos[u]
                                }
                            }
                        })
                    }
                })
            });
            return {pos: pos,root: root,align: align}
        }
        function horizontalCompaction(g, layering, pos, root, align) {
            var sink = {}, maybeShift = {}, shift = {}, pred = {}, xs = {};
            layering.forEach(function(layer) {
                layer.forEach(function(u, i) {
                    sink[u] = u;
                    maybeShift[u] = {};
                    if (i > 0)
                        pred[u] = layer[i - 1]
                })
            });
            function updateShift(toShift, neighbor, delta) {
                if (!(neighbor in maybeShift[toShift])) {
                    maybeShift[toShift][neighbor] = delta
                } else {
                    maybeShift[toShift][neighbor] = Math.min(maybeShift[toShift][neighbor], delta)
                }
            }
            function placeBlock(v) {
                if (!(v in xs)) {
                    xs[v] = 0;
                    var w = v;
                    do {
                        if (pos[w] > 0) {
                            var u = root[pred[w]];
                            placeBlock(u);
                            if (sink[v] === v) {
                                sink[v] = sink[u]
                            }
                            var delta = sep(g, pred[w]) + sep(g, w);
                            if (sink[v] !== sink[u]) {
                                updateShift(sink[u], sink[v], xs[v] - xs[u] - delta)
                            } else {
                                xs[v] = Math.max(xs[v], xs[u] + delta)
                            }
                        }
                        w = align[w]
                    } while (w !== v)
                }
            }
            util.values(root).forEach(function(v) {
                placeBlock(v)
            });
            layering.forEach(function(layer) {
                layer.forEach(function(v) {
                    xs[v] = xs[root[v]];
                    if (v === root[v] && v === sink[v]) {
                        var minShift = 0;
                        if (v in maybeShift && Object.keys(maybeShift[v]).length > 0) {
                            minShift = util.min(Object.keys(maybeShift[v]).map(function(u) {
                                return maybeShift[v][u] + (u in shift ? shift[u] : 0)
                            }))
                        }
                        shift[v] = minShift
                    }
                })
            });
            layering.forEach(function(layer) {
                layer.forEach(function(v) {
                    xs[v] += shift[sink[root[v]]] || 0
                })
            });
            return xs
        }
        function findMinCoord(g, layering, xs) {
            return util.min(layering.map(function(layer) {
                var u = layer[0];
                return xs[u]
            }))
        }
        function findMaxCoord(g, layering, xs) {
            return util.max(layering.map(function(layer) {
                var u = layer[layer.length - 1];
                return xs[u]
            }))
        }
        function balance(g, layering, xss) {
            var min = {}, max = {}, smallestAlignment, shift = {};
            function updateAlignment(v) {
                xss[alignment][v] += shift[alignment]
            }
            var smallest = Number.POSITIVE_INFINITY;
            for (var alignment in xss) {
                var xs = xss[alignment];
                min[alignment] = findMinCoord(g, layering, xs);
                max[alignment] = findMaxCoord(g, layering, xs);
                var w = max[alignment] - min[alignment];
                if (w < smallest) {
                    smallest = w;
                    smallestAlignment = alignment
                }
            }
            ["u", "d"].forEach(function(vertDir) {
                ["l", "r"].forEach(function(horizDir) {
                    var alignment = vertDir + horizDir;
                    shift[alignment] = horizDir === "l" ? min[smallestAlignment] - min[alignment] : max[smallestAlignment] - max[alignment]
                })
            });
            for (alignment in xss) {
                g.eachNode(updateAlignment)
            }
        }
        function flipHorizontally(xs) {
            for (var u in xs) {
                xs[u] = -xs[u]
            }
        }
        function reverseInnerOrder(layering) {
            layering.forEach(function(layer) {
                layer.reverse()
            })
        }
        function width(g, u) {
            switch (g.graph().rankDir) {
                case "LR":
                    return g.node(u).height;
                case "RL":
                    return g.node(u).height;
                default:
                    return g.node(u).width
            }
        }
        function height(g, u) {
            switch (g.graph().rankDir) {
                case "LR":
                    return g.node(u).width;
                case "RL":
                    return g.node(u).width;
                default:
                    return g.node(u).height
            }
        }
        function sep(g, u) {
            if (config.universalSep !== null) {
                return config.universalSep
            }
            var w = width(g, u);
            var s = g.node(u).dummy ? config.edgeSep : config.nodeSep;
            return (w + s) / 2
        }
        function posX(g, u, x) {
            if (g.graph().rankDir === "LR" || g.graph().rankDir === "RL") {
                if (arguments.length < 3) {
                    return g.node(u).y
                } else {
                    g.node(u).y = x
                }
            } else {
                if (arguments.length < 3) {
                    return g.node(u).x
                } else {
                    g.node(u).x = x
                }
            }
        }
        function posXDebug(name, g, u, x) {
            if (g.graph().rankDir === "LR" || g.graph().rankDir === "RL") {
                if (arguments.length < 3) {
                    return g.node(u)[name]
                } else {
                    g.node(u)[name] = x
                }
            } else {
                if (arguments.length < 3) {
                    return g.node(u)[name]
                } else {
                    g.node(u)[name] = x
                }
            }
        }
        function posY(g, u, y) {
            if (g.graph().rankDir === "LR" || g.graph().rankDir === "RL") {
                if (arguments.length < 3) {
                    return g.node(u).x
                } else {
                    g.node(u).x = y
                }
            } else {
                if (arguments.length < 3) {
                    return g.node(u).y
                } else {
                    g.node(u).y = y
                }
            }
        }
        function debugPositioning(align, g, layering, xs) {
            layering.forEach(function(l, li) {
                var u, xU;
                l.forEach(function(v) {
                    var xV = xs[v];
                    if (u) {
                        var s = sep(g, u) + sep(g, v);
                        if (xV - xU < s)
                            console.log("Position phase: sep violation. Align: " + align + ". Layer: " + li + ". " + "U: " + u + " V: " + v + ". Actual sep: " + (xV - xU) + " Expected sep: " + s)
                    }
                    u = v;
                    xU = xV
                })
            })
        }
    }
}, {"./util": 17}],10: [function(require, module, exports) {
    var util = require("./util"), acyclic = require("./rank/acyclic"), initRank = require("./rank/initRank"), feasibleTree = require("./rank/feasibleTree"), constraints = require("./rank/constraints"), simplex = require("./rank/simplex"), components = require("graphlib").alg.components, filter = require("graphlib").filter;
    exports.run = run;
    exports.restoreEdges = restoreEdges;
    function run(g, useSimplex) {
        expandSelfLoops(g);
        util.time("constraints.apply", constraints.apply)(g);
        expandSidewaysEdges(g);
        util.time("acyclic", acyclic)(g);
        var flatGraph = g.filterNodes(util.filterNonSubgraphs(g));
        initRank(flatGraph);
        components(flatGraph).forEach(function(cmpt) {
            var subgraph = flatGraph.filterNodes(filter.nodesFromList(cmpt));
            rankComponent(subgraph, useSimplex)
        });
        util.time("constraints.relax", constraints.relax(g));
        util.time("reorientEdges", reorientEdges)(g)
    }
    function restoreEdges(g) {
        acyclic.undo(g)
    }
    function expandSelfLoops(g) {
        g.eachEdge(function(e, u, v, a) {
            if (u === v) {
                var x = addDummyNode(g, e, u, v, a, 0, false), y = addDummyNode(g, e, u, v, a, 1, true), z = addDummyNode(g, e, u, v, a, 2, false);
                g.addEdge(null, x, u, {minLen: 1,selfLoop: true});
                g.addEdge(null, x, y, {minLen: 1,selfLoop: true});
                g.addEdge(null, u, z, {minLen: 1,selfLoop: true});
                g.addEdge(null, y, z, {minLen: 1,selfLoop: true});
                g.delEdge(e)
            }
        })
    }
    function expandSidewaysEdges(g) {
        g.eachEdge(function(e, u, v, a) {
            if (u === v) {
                var origEdge = a.originalEdge, dummy = addDummyNode(g, origEdge.e, origEdge.u, origEdge.v, origEdge.value, 0, true);
                g.addEdge(null, u, dummy, {minLen: 1});
                g.addEdge(null, dummy, v, {minLen: 1});
                g.delEdge(e)
            }
        })
    }
    function addDummyNode(g, e, u, v, a, index, isLabel) {
        return g.addNode(null, {width: isLabel ? a.width : 0,height: isLabel ? a.height : 0,edge: {id: e,source: u,target: v,attrs: a},dummy: true,index: index})
    }
    function reorientEdges(g) {
        g.eachEdge(function(e, u, v, value) {
            if (g.node(u).rank > g.node(v).rank) {
                g.delEdge(e);
                value.reversed = true;
                g.addEdge(e, v, u, value)
            }
        })
    }
    function rankComponent(subgraph, useSimplex) {
        var spanningTree = feasibleTree(subgraph);
        if (useSimplex) {
            util.log(1, "Using network simplex for ranking");
            simplex(subgraph, spanningTree)
        }
        normalize(subgraph)
    }
    function normalize(g) {
        var m = util.min(g.nodes().map(function(u) {
            return g.node(u).rank
        }));
        g.eachNode(function(u, node) {
            node.rank -= m
        })
    }
}, {"./rank/acyclic": 11,"./rank/constraints": 12,"./rank/feasibleTree": 13,"./rank/initRank": 14,"./rank/simplex": 16,"./util": 17,graphlib: 24}],11: [function(require, module, exports) {
    var util = require("../util");
    module.exports = acyclic;
    module.exports.undo = undo;
    function acyclic(g) {
        var onStack = {}, visited = {}, reverseCount = 0;
        function dfs(u) {
            if (u in visited)
                return;
            visited[u] = onStack[u] = true;
            g.outEdges(u).forEach(function(e) {
                var t = g.target(e), value;
                if (u === t) {
                    console.error('Warning: found self loop "' + e + '" for node "' + u + '"')
                } else if (t in onStack) {
                    value = g.edge(e);
                    g.delEdge(e);
                    value.reversed = true;
                    ++reverseCount;
                    g.addEdge(e, t, u, value)
                } else {
                    dfs(t)
                }
            });
            delete onStack[u]
        }
        g.eachNode(function(u) {
            dfs(u)
        });
        util.log(2, "Acyclic Phase: reversed " + reverseCount + " edge(s)");
        return reverseCount
    }
    function undo(g) {
        g.eachEdge(function(e, s, t, a) {
            if (a.reversed) {
                delete a.reversed;
                g.delEdge(e);
                g.addEdge(e, t, s, a)
            }
        })
    }
}, {"../util": 17}],12: [function(require, module, exports) {
    exports.apply = function(g) {
        function dfs(sg) {
            var rankSets = {};
            g.children(sg).forEach(function(u) {
                if (g.children(u).length) {
                    dfs(u);
                    return
                }
                var value = g.node(u), prefRank = value.prefRank;
                if (prefRank !== undefined) {
                    if (!checkSupportedPrefRank(prefRank)) {
                        return
                    }
                    if (!(prefRank in rankSets)) {
                        rankSets.prefRank = [u]
                    } else {
                        rankSets.prefRank.push(u)
                    }
                    var newU = rankSets[prefRank];
                    if (newU === undefined) {
                        newU = rankSets[prefRank] = g.addNode(null, {originalNodes: []});
                        g.parent(newU, sg)
                    }
                    redirectInEdges(g, u, newU, prefRank === "min");
                    redirectOutEdges(g, u, newU, prefRank === "max");
                    g.node(newU).originalNodes.push({u: u,value: value,parent: sg});
                    g.delNode(u)
                }
            });
            addLightEdgesFromMinNode(g, sg, rankSets.min);
            addLightEdgesToMaxNode(g, sg, rankSets.max)
        }
        dfs(null)
    };
    function checkSupportedPrefRank(prefRank) {
        if (prefRank !== "min" && prefRank !== "max" && prefRank.indexOf("same_") !== 0) {
            console.error("Unsupported rank type: " + prefRank);
            return false
        }
        return true
    }
    function redirectInEdges(g, u, newU, reverse) {
        g.inEdges(u).forEach(function(e) {
            var origValue = g.edge(e), value;
            if (origValue.originalEdge) {
                value = origValue
            } else {
                value = {originalEdge: {e: e,u: g.source(e),v: g.target(e),value: origValue},minLen: g.edge(e).minLen}
            }
            if (origValue.selfLoop) {
                reverse = false
            }
            if (reverse) {
                g.addEdge(null, newU, g.source(e), value);
                value.reversed = true
            } else {
                g.addEdge(null, g.source(e), newU, value)
            }
        })
    }
    function redirectOutEdges(g, u, newU, reverse) {
        g.outEdges(u).forEach(function(e) {
            var origValue = g.edge(e), value;
            if (origValue.originalEdge) {
                value = origValue
            } else {
                value = {originalEdge: {e: e,u: g.source(e),v: g.target(e),value: origValue},minLen: g.edge(e).minLen}
            }
            if (origValue.selfLoop) {
                reverse = false
            }
            if (reverse) {
                g.addEdge(null, g.target(e), newU, value);
                value.reversed = true
            } else {
                g.addEdge(null, newU, g.target(e), value)
            }
        })
    }
    function addLightEdgesFromMinNode(g, sg, minNode) {
        if (minNode !== undefined) {
            g.children(sg).forEach(function(u) {
                if (u !== minNode && !g.outEdges(minNode, u).length && !g.node(u).dummy) {
                    g.addEdge(null, minNode, u, {minLen: 0})
                }
            })
        }
    }
    function addLightEdgesToMaxNode(g, sg, maxNode) {
        if (maxNode !== undefined) {
            g.children(sg).forEach(function(u) {
                if (u !== maxNode && !g.outEdges(u, maxNode).length && !g.node(u).dummy) {
                    g.addEdge(null, u, maxNode, {minLen: 0})
                }
            })
        }
    }
    exports.relax = function(g) {
        var originalEdges = [];
        g.eachEdge(function(e, u, v, value) {
            var originalEdge = value.originalEdge;
            if (originalEdge) {
                originalEdges.push(originalEdge)
            }
        });
        g.eachNode(function(u, value) {
            var originalNodes = value.originalNodes;
            if (originalNodes) {
                originalNodes.forEach(function(originalNode) {
                    originalNode.value.rank = value.rank;
                    g.addNode(originalNode.u, originalNode.value);
                    g.parent(originalNode.u, originalNode.parent)
                });
                g.delNode(u)
            }
        });
        originalEdges.forEach(function(edge) {
            g.addEdge(edge.e, edge.u, edge.v, edge.value)
        })
    }
}, {}],13: [function(require, module, exports) {
    var Set = require("cp-data").Set, Digraph = require("graphlib").Digraph, util = require("../util");
    module.exports = feasibleTree;
    function feasibleTree(g) {
        var remaining = new Set(g.nodes()), tree = new Digraph;
        if (remaining.size() === 1) {
            var root = g.nodes()[0];
            tree.addNode(root, {});
            tree.graph({root: root});
            return tree
        }
        function addTightEdges(v) {
            var continueToScan = true;
            g.predecessors(v).forEach(function(u) {
                if (remaining.has(u) && !slack(g, u, v)) {
                    if (remaining.has(v)) {
                        tree.addNode(v, {});
                        remaining.remove(v);
                        tree.graph({root: v})
                    }
                    tree.addNode(u, {});
                    tree.addEdge(null, u, v, {reversed: true});
                    remaining.remove(u);
                    addTightEdges(u);
                    continueToScan = false
                }
            });
            g.successors(v).forEach(function(w) {
                if (remaining.has(w) && !slack(g, v, w)) {
                    if (remaining.has(v)) {
                        tree.addNode(v, {});
                        remaining.remove(v);
                        tree.graph({root: v})
                    }
                    tree.addNode(w, {});
                    tree.addEdge(null, v, w, {});
                    remaining.remove(w);
                    addTightEdges(w);
                    continueToScan = false
                }
            });
            return continueToScan
        }
        function createTightEdge() {
            var minSlack = Number.MAX_VALUE;
            remaining.keys().forEach(function(v) {
                g.predecessors(v).forEach(function(u) {
                    if (!remaining.has(u)) {
                        var edgeSlack = slack(g, u, v);
                        if (Math.abs(edgeSlack) < Math.abs(minSlack)) {
                            minSlack = -edgeSlack
                        }
                    }
                });
                g.successors(v).forEach(function(w) {
                    if (!remaining.has(w)) {
                        var edgeSlack = slack(g, v, w);
                        if (Math.abs(edgeSlack) < Math.abs(minSlack)) {
                            minSlack = edgeSlack
                        }
                    }
                })
            });
            tree.eachNode(function(u) {
                g.node(u).rank -= minSlack
            })
        }
        while (remaining.size()) {
            var nodesToSearch = !tree.order() ? remaining.keys() : tree.nodes();
            for (var i = 0, il = nodesToSearch.length; i < il && addTightEdges(nodesToSearch[i]); ++i)
                ;
            if (remaining.size()) {
                createTightEdge()
            }
        }
        return tree
    }
    function slack(g, u, v) {
        var rankDiff = g.node(v).rank - g.node(u).rank;
        var maxMinLen = util.max(g.outEdges(u, v).map(function(e) {
            return g.edge(e).minLen
        }));
        return rankDiff - maxMinLen
    }
}, {"../util": 17,"cp-data": 19,graphlib: 24}],14: [function(require, module, exports) {
    var util = require("../util"), topsort = require("graphlib").alg.topsort;
    module.exports = initRank;
    function initRank(g) {
        var sorted = topsort(g);
        sorted.forEach(function(u) {
            var inEdges = g.inEdges(u);
            if (inEdges.length === 0) {
                g.node(u).rank = 0;
                return
            }
            var minLens = inEdges.map(function(e) {
                return g.node(g.source(e)).rank + g.edge(e).minLen
            });
            g.node(u).rank = util.max(minLens)
        })
    }
}, {"../util": 17,graphlib: 24}],15: [function(require, module, exports) {
    module.exports = {slack: slack};
    function slack(graph, u, v, minLen) {
        return Math.abs(graph.node(u).rank - graph.node(v).rank) - minLen
    }
}, {}],16: [function(require, module, exports) {
    var util = require("../util"), rankUtil = require("./rankUtil");
    module.exports = simplex;
    function simplex(graph, spanningTree) {
        initCutValues(graph, spanningTree);
        while (true) {
            var e = leaveEdge(spanningTree);
            if (e === null)
                break;
            var f = enterEdge(graph, spanningTree, e);
            exchange(graph, spanningTree, e, f)
        }
    }
    function initCutValues(graph, spanningTree) {
        computeLowLim(spanningTree);
        spanningTree.eachEdge(function(id, u, v, treeValue) {
            treeValue.cutValue = 0
        });
        function dfs(n) {
            var children = spanningTree.successors(n);
            for (var c in children) {
                var child = children[c];
                dfs(child)
            }
            if (n !== spanningTree.graph().root) {
                setCutValue(graph, spanningTree, n)
            }
        }
        dfs(spanningTree.graph().root)
    }
    function computeLowLim(tree) {
        var postOrderNum = 0;
        function dfs(n) {
            var children = tree.successors(n);
            var low = postOrderNum;
            for (var c in children) {
                var child = children[c];
                dfs(child);
                low = Math.min(low, tree.node(child).low)
            }
            tree.node(n).low = low;
            tree.node(n).lim = postOrderNum++
        }
        dfs(tree.graph().root)
    }
    function setCutValue(graph, tree, child) {
        var parentEdge = tree.inEdges(child)[0];
        var grandchildren = [];
        var grandchildEdges = tree.outEdges(child);
        for (var gce in grandchildEdges) {
            grandchildren.push(tree.target(grandchildEdges[gce]))
        }
        var cutValue = 0;
        var E = 0;
        var F = 0;
        var G = 0;
        var H = 0;
        var outEdges = graph.outEdges(child);
        var gc;
        for (var oe in outEdges) {
            var succ = graph.target(outEdges[oe]);
            for (gc in grandchildren) {
                if (inSubtree(tree, succ, grandchildren[gc])) {
                    E++
                }
            }
            if (!inSubtree(tree, succ, child)) {
                G++
            }
        }
        var inEdges = graph.inEdges(child);
        for (var ie in inEdges) {
            var pred = graph.source(inEdges[ie]);
            for (gc in grandchildren) {
                if (inSubtree(tree, pred, grandchildren[gc])) {
                    F++
                }
            }
            if (!inSubtree(tree, pred, child)) {
                H++
            }
        }
        var grandchildCutSum = 0;
        for (gc in grandchildren) {
            var cv = tree.edge(grandchildEdges[gc]).cutValue;
            if (!tree.edge(grandchildEdges[gc]).reversed) {
                grandchildCutSum += cv
            } else {
                grandchildCutSum -= cv
            }
        }
        if (!tree.edge(parentEdge).reversed) {
            cutValue += grandchildCutSum - E + F - G + H
        } else {
            cutValue -= grandchildCutSum - E + F - G + H
        }
        tree.edge(parentEdge).cutValue = cutValue
    }
    function inSubtree(tree, n, root) {
        return tree.node(root).low <= tree.node(n).lim && tree.node(n).lim <= tree.node(root).lim
    }
    function leaveEdge(tree) {
        var edges = tree.edges();
        for (var n in edges) {
            var e = edges[n];
            var treeValue = tree.edge(e);
            if (treeValue.cutValue < 0) {
                return e
            }
        }
        return null
    }
    function enterEdge(graph, tree, e) {
        var source = tree.source(e);
        var target = tree.target(e);
        var lower = tree.node(target).lim < tree.node(source).lim ? target : source;
        var aligned = !tree.edge(e).reversed;
        var minSlack = Number.POSITIVE_INFINITY;
        var minSlackEdge;
        if (aligned) {
            graph.eachEdge(function(id, u, v, value) {
                if (id !== e && inSubtree(tree, u, lower) && !inSubtree(tree, v, lower)) {
                    var slack = rankUtil.slack(graph, u, v, value.minLen);
                    if (slack < minSlack) {
                        minSlack = slack;
                        minSlackEdge = id
                    }
                }
            })
        } else {
            graph.eachEdge(function(id, u, v, value) {
                if (id !== e && !inSubtree(tree, u, lower) && inSubtree(tree, v, lower)) {
                    var slack = rankUtil.slack(graph, u, v, value.minLen);
                    if (slack < minSlack) {
                        minSlack = slack;
                        minSlackEdge = id
                    }
                }
            })
        }
        if (minSlackEdge === undefined) {
            var outside = [];
            var inside = [];
            graph.eachNode(function(id) {
                if (!inSubtree(tree, id, lower)) {
                    outside.push(id)
                } else {
                    inside.push(id)
                }
            });
            throw new Error("No edge found from outside of tree to inside")
        }
        return minSlackEdge
    }
    function exchange(graph, tree, e, f) {
        tree.delEdge(e);
        var source = graph.source(f);
        var target = graph.target(f);
        function redirect(v) {
            var edges = tree.inEdges(v);
            for (var i in edges) {
                var e = edges[i];
                var u = tree.source(e);
                var value = tree.edge(e);
                redirect(u);
                tree.delEdge(e);
                value.reversed = !value.reversed;
                tree.addEdge(e, v, u, value)
            }
        }
        redirect(target);
        var root = source;
        var edges = tree.inEdges(root);
        while (edges.length > 0) {
            root = tree.source(edges[0]);
            edges = tree.inEdges(root)
        }
        tree.graph().root = root;
        tree.addEdge(null, source, target, {cutValue: 0});
        initCutValues(graph, tree);
        adjustRanks(graph, tree)
    }
    function adjustRanks(graph, tree) {
        function dfs(p) {
            var children = tree.successors(p);
            children.forEach(function(c) {
                var minLen = minimumLength(graph, p, c);
                graph.node(c).rank = graph.node(p).rank + minLen;
                dfs(c)
            })
        }
        dfs(tree.graph().root)
    }
    function minimumLength(graph, u, v) {
        var outEdges = graph.outEdges(u, v);
        if (outEdges.length > 0) {
            return util.max(outEdges.map(function(e) {
                return graph.edge(e).minLen
            }))
        }
        var inEdges = graph.inEdges(u, v);
        if (inEdges.length > 0) {
            return -util.max(inEdges.map(function(e) {
                return graph.edge(e).minLen
            }))
        }
    }
}, {"../util": 17,"./rankUtil": 15}],17: [function(require, module, exports) {
    exports.min = function(values) {
        return Math.min.apply(Math, values)
    };
    exports.max = function(values) {
        return Math.max.apply(Math, values)
    };
    exports.all = function(xs, f) {
        for (var i = 0; i < xs.length; ++i) {
            if (!f(xs[i])) {
                return false
            }
        }
        return true
    };
    exports.sum = function(values) {
        return values.reduce(function(acc, x) {
            return acc + x
        }, 0)
    };
    exports.values = function(obj) {
        return Object.keys(obj).map(function(k) {
            return obj[k]
        })
    };
    exports.shuffle = function(array) {
        for (i = array.length - 1; i > 0; --i) {
            var j = Math.floor(Math.random() * (i + 1));
            var aj = array[j];
            array[j] = array[i];
            array[i] = aj
        }
    };
    exports.propertyAccessor = function(self, config, field, setHook) {
        return function(x) {
            if (!arguments.length)
                return config[field];
            config[field] = x;
            if (setHook)
                setHook(x);
            return self
        }
    };
    exports.ordering = function(g) {
        var ordering = [];
        g.eachNode(function(u, value) {
            var rank = ordering[value.rank] || (ordering[value.rank] = []);
            rank[value.order] = u
        });
        return ordering
    };
    exports.filterNonSubgraphs = function(g) {
        return function(u) {
            return g.children(u).length === 0
        }
    };
    function time(name, func) {
        return function() {
            var start = (new Date).getTime();
            try {
                return func.apply(null, arguments)
            }finally {
                log(1, name + " time: " + ((new Date).getTime() - start) + "ms")
            }
        }
    }
    time.enabled = false;
    exports.time = time;
    function log(level) {
        if (log.level >= level) {
            console.log.apply(console, Array.prototype.slice.call(arguments, 1))
        }
    }
    log.level = 0;
    exports.log = log
}, {}],18: [function(require, module, exports) {
    module.exports = "0.4.5"
}, {}],19: [function(require, module, exports) {
    exports.Set = require("./lib/Set");
    exports.PriorityQueue = require("./lib/PriorityQueue");
    exports.version = require("./lib/version")
}, {"./lib/PriorityQueue": 20,"./lib/Set": 21,"./lib/version": 23}],20: [function(require, module, exports) {
    module.exports = PriorityQueue;
    function PriorityQueue() {
        this._arr = [];
        this._keyIndices = {}
    }
    PriorityQueue.prototype.size = function() {
        return this._arr.length
    };
    PriorityQueue.prototype.keys = function() {
        return this._arr.map(function(x) {
            return x.key
        })
    };
    PriorityQueue.prototype.has = function(key) {
        return key in this._keyIndices
    };
    PriorityQueue.prototype.priority = function(key) {
        var index = this._keyIndices[key];
        if (index !== undefined) {
            return this._arr[index].priority
        }
    };
    PriorityQueue.prototype.min = function() {
        if (this.size() === 0) {
            throw new Error("Queue underflow")
        }
        return this._arr[0].key
    };
    PriorityQueue.prototype.add = function(key, priority) {
        var keyIndices = this._keyIndices;
        if (!(key in keyIndices)) {
            var arr = this._arr;
            var index = arr.length;
            keyIndices[key] = index;
            arr.push({key: key,priority: priority});
            this._decrease(index);
            return true
        }
        return false
    };
    PriorityQueue.prototype.removeMin = function() {
        this._swap(0, this._arr.length - 1);
        var min = this._arr.pop();
        delete this._keyIndices[min.key];
        this._heapify(0);
        return min.key
    };
    PriorityQueue.prototype.decrease = function(key, priority) {
        var index = this._keyIndices[key];
        if (priority > this._arr[index].priority) {
            throw new Error("New priority is greater than current priority. " + "Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority)
        }
        this._arr[index].priority = priority;
        this._decrease(index)
    };
    PriorityQueue.prototype._heapify = function(i) {
        var arr = this._arr;
        var l = 2 * i, r = l + 1, largest = i;
        if (l < arr.length) {
            largest = arr[l].priority < arr[largest].priority ? l : largest;
            if (r < arr.length) {
                largest = arr[r].priority < arr[largest].priority ? r : largest
            }
            if (largest !== i) {
                this._swap(i, largest);
                this._heapify(largest)
            }
        }
    };
    PriorityQueue.prototype._decrease = function(index) {
        var arr = this._arr;
        var priority = arr[index].priority;
        var parent;
        while (index !== 0) {
            parent = index >> 1;
            if (arr[parent].priority < priority) {
                break
            }
            this._swap(index, parent);
            index = parent
        }
    };
    PriorityQueue.prototype._swap = function(i, j) {
        var arr = this._arr;
        var keyIndices = this._keyIndices;
        var origArrI = arr[i];
        var origArrJ = arr[j];
        arr[i] = origArrJ;
        arr[j] = origArrI;
        keyIndices[origArrJ.key] = i;
        keyIndices[origArrI.key] = j
    }
}, {}],21: [function(require, module, exports) {
    var util = require("./util");
    module.exports = Set;
    function Set(initialKeys) {
        this._size = 0;
        this._keys = {};
        if (initialKeys) {
            for (var i = 0, il = initialKeys.length; i < il; ++i) {
                this.add(initialKeys[i])
            }
        }
    }
    Set.intersect = function(sets) {
        if (sets.length === 0) {
            return new Set
        }
        var result = new Set(!util.isArray(sets[0]) ? sets[0].keys() : sets[0]);
        for (var i = 1, il = sets.length; i < il; ++i) {
            var resultKeys = result.keys(), other = !util.isArray(sets[i]) ? sets[i] : new Set(sets[i]);
            for (var j = 0, jl = resultKeys.length; j < jl; ++j) {
                var key = resultKeys[j];
                if (!other.has(key)) {
                    result.remove(key)
                }
            }
        }
        return result
    };
    Set.union = function(sets) {
        var totalElems = util.reduce(sets, function(lhs, rhs) {
            return lhs + (rhs.size ? rhs.size() : rhs.length)
        }, 0);
        var arr = new Array(totalElems);
        var k = 0;
        for (var i = 0, il = sets.length; i < il; ++i) {
            var cur = sets[i], keys = !util.isArray(cur) ? cur.keys() : cur;
            for (var j = 0, jl = keys.length; j < jl; ++j) {
                arr[k++] = keys[j]
            }
        }
        return new Set(arr)
    };
    Set.prototype.size = function() {
        return this._size
    };
    Set.prototype.keys = function() {
        return values(this._keys)
    };
    Set.prototype.has = function(key) {
        return key in this._keys
    };
    Set.prototype.add = function(key) {
        if (!(key in this._keys)) {
            this._keys[key] = key;
            ++this._size;
            return true
        }
        return false
    };
    Set.prototype.remove = function(key) {
        if (key in this._keys) {
            delete this._keys[key];
            --this._size;
            return true
        }
        return false
    };
    function values(o) {
        var ks = Object.keys(o), len = ks.length, result = new Array(len), i;
        for (i = 0; i < len; ++i) {
            result[i] = o[ks[i]]
        }
        return result
    }
}, {"./util": 22}],22: [function(require, module, exports) {
    if (!Array.isArray) {
        exports.isArray = function(vArg) {
            return Object.prototype.toString.call(vArg) === "[object Array]"
        }
    } else {
        exports.isArray = Array.isArray
    }
    if ("function" !== typeof Array.prototype.reduce) {
        exports.reduce = function(array, callback, opt_initialValue) {
            "use strict";
            if (null === array || "undefined" === typeof array) {
                throw new TypeError("Array.prototype.reduce called on null or undefined")
            }
            if ("function" !== typeof callback) {
                throw new TypeError(callback + " is not a function")
            }
            var index, value, length = array.length >>> 0, isValueSet = false;
            if (1 < arguments.length) {
                value = opt_initialValue;
                isValueSet = true
            }
            for (index = 0; length > index; ++index) {
                if (array.hasOwnProperty(index)) {
                    if (isValueSet) {
                        value = callback(value, array[index], index, array)
                    } else {
                        value = array[index];
                        isValueSet = true
                    }
                }
            }
            if (!isValueSet) {
                throw new TypeError("Reduce of empty array with no initial value")
            }
            return value
        }
    } else {
        exports.reduce = function(array, callback, opt_initialValue) {
            return array.reduce(callback, opt_initialValue)
        }
    }
}, {}],23: [function(require, module, exports) {
    module.exports = "1.1.3"
}, {}],24: [function(require, module, exports) {
    exports.Graph = require("./lib/Graph");
    exports.Digraph = require("./lib/Digraph");
    exports.CGraph = require("./lib/CGraph");
    exports.CDigraph = require("./lib/CDigraph");
    require("./lib/graph-converters");
    exports.alg = {isAcyclic: require("./lib/alg/isAcyclic"),components: require("./lib/alg/components"),dijkstra: require("./lib/alg/dijkstra"),dijkstraAll: require("./lib/alg/dijkstraAll"),findCycles: require("./lib/alg/findCycles"),floydWarshall: require("./lib/alg/floydWarshall"),postorder: require("./lib/alg/postorder"),preorder: require("./lib/alg/preorder"),prim: require("./lib/alg/prim"),tarjan: require("./lib/alg/tarjan"),topsort: require("./lib/alg/topsort")};
    exports.converter = {json: require("./lib/converter/json.js")};
    var filter = require("./lib/filter");
    exports.filter = {all: filter.all,nodesFromList: filter.nodesFromList};
    exports.version = require("./lib/version")
}, {"./lib/CDigraph": 26,"./lib/CGraph": 27,"./lib/Digraph": 28,"./lib/Graph": 29,"./lib/alg/components": 30,"./lib/alg/dijkstra": 31,"./lib/alg/dijkstraAll": 32,"./lib/alg/findCycles": 33,"./lib/alg/floydWarshall": 34,"./lib/alg/isAcyclic": 35,"./lib/alg/postorder": 36,"./lib/alg/preorder": 37,"./lib/alg/prim": 38,"./lib/alg/tarjan": 39,"./lib/alg/topsort": 40,"./lib/converter/json.js": 42,"./lib/filter": 43,"./lib/graph-converters": 44,"./lib/version": 46}],25: [function(require, module, exports) {
    var Set = require("cp-data").Set;
    module.exports = BaseGraph;
    function BaseGraph() {
        this._value = undefined;
        this._nodes = {};
        this._edges = {};
        this._nextId = 0
    }
    BaseGraph.prototype.order = function() {
        return Object.keys(this._nodes).length
    };
    BaseGraph.prototype.size = function() {
        return Object.keys(this._edges).length
    };
    BaseGraph.prototype.graph = function(value) {
        if (arguments.length === 0) {
            return this._value
        }
        this._value = value
    };
    BaseGraph.prototype.hasNode = function(u) {
        return u in this._nodes
    };
    BaseGraph.prototype.node = function(u, value) {
        var node = this._strictGetNode(u);
        if (arguments.length === 1) {
            return node.value
        }
        node.value = value
    };
    BaseGraph.prototype.nodes = function() {
        var nodes = [];
        this.eachNode(function(id) {
            nodes.push(id)
        });
        return nodes
    };
    BaseGraph.prototype.eachNode = function(func) {
        for (var k in this._nodes) {
            var node = this._nodes[k];
            func(node.id, node.value)
        }
    };
    BaseGraph.prototype.hasEdge = function(e) {
        return e in this._edges
    };
    BaseGraph.prototype.edge = function(e, value) {
        var edge = this._strictGetEdge(e);
        if (arguments.length === 1) {
            return edge.value
        }
        edge.value = value
    };
    BaseGraph.prototype.edges = function() {
        var es = [];
        this.eachEdge(function(id) {
            es.push(id)
        });
        return es
    };
    BaseGraph.prototype.eachEdge = function(func) {
        for (var k in this._edges) {
            var edge = this._edges[k];
            func(edge.id, edge.u, edge.v, edge.value)
        }
    };
    BaseGraph.prototype.incidentNodes = function(e) {
        var edge = this._strictGetEdge(e);
        return [edge.u, edge.v]
    };
    BaseGraph.prototype.addNode = function(u, value) {
        if (u === undefined || u === null) {
            do {
                u = "_" + ++this._nextId
            } while (this.hasNode(u))
        } else if (this.hasNode(u)) {
            throw new Error("Graph already has node '" + u + "'")
        }
        this._nodes[u] = {id: u,value: value};
        return u
    };
    BaseGraph.prototype.delNode = function(u) {
        this._strictGetNode(u);
        this.incidentEdges(u).forEach(function(e) {
            this.delEdge(e)
        }, this);
        delete this._nodes[u]
    };
    BaseGraph.prototype._addEdge = function(e, u, v, value, inMap, outMap) {
        this._strictGetNode(u);
        this._strictGetNode(v);
        if (e === undefined || e === null) {
            do {
                e = "_" + ++this._nextId
            } while (this.hasEdge(e))
        } else if (this.hasEdge(e)) {
            throw new Error("Graph already has edge '" + e + "'")
        }
        this._edges[e] = {id: e,u: u,v: v,value: value};
        addEdgeToMap(inMap[v], u, e);
        addEdgeToMap(outMap[u], v, e);
        return e
    };
    BaseGraph.prototype._delEdge = function(e, inMap, outMap) {
        var edge = this._strictGetEdge(e);
        delEdgeFromMap(inMap[edge.v], edge.u, e);
        delEdgeFromMap(outMap[edge.u], edge.v, e);
        delete this._edges[e]
    };
    BaseGraph.prototype.copy = function() {
        var copy = new this.constructor;
        copy.graph(this.graph());
        this.eachNode(function(u, value) {
            copy.addNode(u, value)
        });
        this.eachEdge(function(e, u, v, value) {
            copy.addEdge(e, u, v, value)
        });
        copy._nextId = this._nextId;
        return copy
    };
    BaseGraph.prototype.filterNodes = function(filter) {
        var copy = new this.constructor;
        copy.graph(this.graph());
        this.eachNode(function(u, value) {
            if (filter(u)) {
                copy.addNode(u, value)
            }
        });
        this.eachEdge(function(e, u, v, value) {
            if (copy.hasNode(u) && copy.hasNode(v)) {
                copy.addEdge(e, u, v, value)
            }
        });
        return copy
    };
    BaseGraph.prototype._strictGetNode = function(u) {
        var node = this._nodes[u];
        if (node === undefined) {
            throw new Error("Node '" + u + "' is not in graph")
        }
        return node
    };
    BaseGraph.prototype._strictGetEdge = function(e) {
        var edge = this._edges[e];
        if (edge === undefined) {
            throw new Error("Edge '" + e + "' is not in graph")
        }
        return edge
    };
    function addEdgeToMap(map, v, e) {
        (map[v] || (map[v] = new Set)).add(e)
    }
    function delEdgeFromMap(map, v, e) {
        var vEntry = map[v];
        vEntry.remove(e);
        if (vEntry.size() === 0) {
            delete map[v]
        }
    }
}, {"cp-data": 19}],26: [function(require, module, exports) {
    var Digraph = require("./Digraph"), compoundify = require("./compoundify");
    var CDigraph = compoundify(Digraph);
    module.exports = CDigraph;
    CDigraph.fromDigraph = function(src) {
        var g = new CDigraph, graphValue = src.graph();
        if (graphValue !== undefined) {
            g.graph(graphValue)
        }
        src.eachNode(function(u, value) {
            if (value === undefined) {
                g.addNode(u)
            } else {
                g.addNode(u, value)
            }
        });
        src.eachEdge(function(e, u, v, value) {
            if (value === undefined) {
                g.addEdge(null, u, v)
            } else {
                g.addEdge(null, u, v, value)
            }
        });
        return g
    };
    CDigraph.prototype.toString = function() {
        return "CDigraph " + JSON.stringify(this, null, 2)
    }
}, {"./Digraph": 28,"./compoundify": 41}],27: [function(require, module, exports) {
    var Graph = require("./Graph"), compoundify = require("./compoundify");
    var CGraph = compoundify(Graph);
    module.exports = CGraph;
    CGraph.fromGraph = function(src) {
        var g = new CGraph, graphValue = src.graph();
        if (graphValue !== undefined) {
            g.graph(graphValue)
        }
        src.eachNode(function(u, value) {
            if (value === undefined) {
                g.addNode(u)
            } else {
                g.addNode(u, value)
            }
        });
        src.eachEdge(function(e, u, v, value) {
            if (value === undefined) {
                g.addEdge(null, u, v)
            } else {
                g.addEdge(null, u, v, value)
            }
        });
        return g
    };
    CGraph.prototype.toString = function() {
        return "CGraph " + JSON.stringify(this, null, 2)
    }
}, {"./Graph": 29,"./compoundify": 41}],28: [function(require, module, exports) {
    var util = require("./util"), BaseGraph = require("./BaseGraph"), Set = require("cp-data").Set;
    module.exports = Digraph;
    function Digraph() {
        BaseGraph.call(this);
        this._inEdges = {};
        this._outEdges = {}
    }
    Digraph.prototype = new BaseGraph;
    Digraph.prototype.constructor = Digraph;
    Digraph.prototype.isDirected = function() {
        return true
    };
    Digraph.prototype.successors = function(u) {
        this._strictGetNode(u);
        return Object.keys(this._outEdges[u]).map(function(v) {
            return this._nodes[v].id
        }, this)
    };
    Digraph.prototype.predecessors = function(u) {
        this._strictGetNode(u);
        return Object.keys(this._inEdges[u]).map(function(v) {
            return this._nodes[v].id
        }, this)
    };
    Digraph.prototype.neighbors = function(u) {
        return Set.union([this.successors(u), this.predecessors(u)]).keys()
    };
    Digraph.prototype.sources = function() {
        var self = this;
        return this._filterNodes(function(u) {
            return self.inEdges(u).length === 0
        })
    };
    Digraph.prototype.sinks = function() {
        var self = this;
        return this._filterNodes(function(u) {
            return self.outEdges(u).length === 0
        })
    };
    Digraph.prototype.source = function(e) {
        return this._strictGetEdge(e).u
    };
    Digraph.prototype.target = function(e) {
        return this._strictGetEdge(e).v
    };
    Digraph.prototype.inEdges = function(target, source) {
        this._strictGetNode(target);
        var results = Set.union(util.values(this._inEdges[target])).keys();
        if (arguments.length > 1) {
            this._strictGetNode(source);
            results = results.filter(function(e) {
                return this.source(e) === source
            }, this)
        }
        return results
    };
    Digraph.prototype.outEdges = function(source, target) {
        this._strictGetNode(source);
        var results = Set.union(util.values(this._outEdges[source])).keys();
        if (arguments.length > 1) {
            this._strictGetNode(target);
            results = results.filter(function(e) {
                return this.target(e) === target
            }, this)
        }
        return results
    };
    Digraph.prototype.incidentEdges = function(u, v) {
        if (arguments.length > 1) {
            return Set.union([this.outEdges(u, v), this.outEdges(v, u)]).keys()
        } else {
            return Set.union([this.inEdges(u), this.outEdges(u)]).keys()
        }
    };
    Digraph.prototype.toString = function() {
        return "Digraph " + JSON.stringify(this, null, 2)
    };
    Digraph.prototype.addNode = function(u, value) {
        u = BaseGraph.prototype.addNode.call(this, u, value);
        this._inEdges[u] = {};
        this._outEdges[u] = {};
        return u
    };
    Digraph.prototype.delNode = function(u) {
        BaseGraph.prototype.delNode.call(this, u);
        delete this._inEdges[u];
        delete this._outEdges[u]
    };
    Digraph.prototype.addEdge = function(e, source, target, value) {
        return BaseGraph.prototype._addEdge.call(this, e, source, target, value, this._inEdges, this._outEdges)
    };
    Digraph.prototype.delEdge = function(e) {
        BaseGraph.prototype._delEdge.call(this, e, this._inEdges, this._outEdges)
    };
    Digraph.prototype._filterNodes = function(pred) {
        var filtered = [];
        this.eachNode(function(u) {
            if (pred(u)) {
                filtered.push(u)
            }
        });
        return filtered
    }
}, {"./BaseGraph": 25,"./util": 45,"cp-data": 19}],29: [function(require, module, exports) {
    var util = require("./util"), BaseGraph = require("./BaseGraph"), Set = require("cp-data").Set;
    module.exports = Graph;
    function Graph() {
        BaseGraph.call(this);
        this._incidentEdges = {}
    }
    Graph.prototype = new BaseGraph;
    Graph.prototype.constructor = Graph;
    Graph.prototype.isDirected = function() {
        return false
    };
    Graph.prototype.neighbors = function(u) {
        this._strictGetNode(u);
        return Object.keys(this._incidentEdges[u]).map(function(v) {
            return this._nodes[v].id
        }, this)
    };
    Graph.prototype.incidentEdges = function(u, v) {
        this._strictGetNode(u);
        if (arguments.length > 1) {
            this._strictGetNode(v);
            return v in this._incidentEdges[u] ? this._incidentEdges[u][v].keys() : []
        } else {
            return Set.union(util.values(this._incidentEdges[u])).keys()
        }
    };
    Graph.prototype.toString = function() {
        return "Graph " + JSON.stringify(this, null, 2)
    };
    Graph.prototype.addNode = function(u, value) {
        u = BaseGraph.prototype.addNode.call(this, u, value);
        this._incidentEdges[u] = {};
        return u
    };
    Graph.prototype.delNode = function(u) {
        BaseGraph.prototype.delNode.call(this, u);
        delete this._incidentEdges[u]
    };
    Graph.prototype.addEdge = function(e, u, v, value) {
        return BaseGraph.prototype._addEdge.call(this, e, u, v, value, this._incidentEdges, this._incidentEdges)
    };
    Graph.prototype.delEdge = function(e) {
        BaseGraph.prototype._delEdge.call(this, e, this._incidentEdges, this._incidentEdges)
    }
}, {"./BaseGraph": 25,"./util": 45,"cp-data": 19}],30: [function(require, module, exports) {
    var Set = require("cp-data").Set;
    module.exports = components;
    function components(g) {
        var results = [];
        var visited = new Set;
        function dfs(v, component) {
            if (!visited.has(v)) {
                visited.add(v);
                component.push(v);
                g.neighbors(v).forEach(function(w) {
                    dfs(w, component)
                })
            }
        }
        g.nodes().forEach(function(v) {
            var component = [];
            dfs(v, component);
            if (component.length > 0) {
                results.push(component)
            }
        });
        return results
    }
}, {"cp-data": 19}],31: [function(require, module, exports) {
    var PriorityQueue = require("cp-data").PriorityQueue;
    module.exports = dijkstra;
    function dijkstra(g, source, weightFunc, incidentFunc) {
        var results = {}, pq = new PriorityQueue;
        function updateNeighbors(e) {
            var incidentNodes = g.incidentNodes(e), v = incidentNodes[0] !== u ? incidentNodes[0] : incidentNodes[1], vEntry = results[v], weight = weightFunc(e), distance = uEntry.distance + weight;
            if (weight < 0) {
                throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + e + " Weight: " + weight)
            }
            if (distance < vEntry.distance) {
                vEntry.distance = distance;
                vEntry.predecessor = u;
                pq.decrease(v, distance)
            }
        }
        weightFunc = weightFunc || function() {
                return 1
            };
        incidentFunc = incidentFunc || (g.isDirected() ? function(u) {
                return g.outEdges(u)
            } : function(u) {
                return g.incidentEdges(u)
            });
        g.eachNode(function(u) {
            var distance = u === source ? 0 : Number.POSITIVE_INFINITY;
            results[u] = {distance: distance};
            pq.add(u, distance)
        });
        var u, uEntry;
        while (pq.size() > 0) {
            u = pq.removeMin();
            uEntry = results[u];
            if (uEntry.distance === Number.POSITIVE_INFINITY) {
                break
            }
            incidentFunc(u).forEach(updateNeighbors)
        }
        return results
    }
}, {"cp-data": 19}],32: [function(require, module, exports) {
    var dijkstra = require("./dijkstra");
    module.exports = dijkstraAll;
    function dijkstraAll(g, weightFunc, incidentFunc) {
        var results = {};
        g.eachNode(function(u) {
            results[u] = dijkstra(g, u, weightFunc, incidentFunc)
        });
        return results
    }
}, {"./dijkstra": 31}],33: [function(require, module, exports) {
    var tarjan = require("./tarjan");
    module.exports = findCycles;
    function findCycles(g) {
        return tarjan(g).filter(function(cmpt) {
            return cmpt.length > 1
        })
    }
}, {"./tarjan": 39}],34: [function(require, module, exports) {
    module.exports = floydWarshall;
    function floydWarshall(g, weightFunc, incidentFunc) {
        var results = {}, nodes = g.nodes();
        weightFunc = weightFunc || function() {
                return 1
            };
        incidentFunc = incidentFunc || (g.isDirected() ? function(u) {
                return g.outEdges(u)
            } : function(u) {
                return g.incidentEdges(u)
            });
        nodes.forEach(function(u) {
            results[u] = {};
            results[u][u] = {distance: 0};
            nodes.forEach(function(v) {
                if (u !== v) {
                    results[u][v] = {distance: Number.POSITIVE_INFINITY}
                }
            });
            incidentFunc(u).forEach(function(e) {
                var incidentNodes = g.incidentNodes(e), v = incidentNodes[0] !== u ? incidentNodes[0] : incidentNodes[1], d = weightFunc(e);
                if (d < results[u][v].distance) {
                    results[u][v] = {distance: d,predecessor: u}
                }
            })
        });
        nodes.forEach(function(k) {
            var rowK = results[k];
            nodes.forEach(function(i) {
                var rowI = results[i];
                nodes.forEach(function(j) {
                    var ik = rowI[k];
                    var kj = rowK[j];
                    var ij = rowI[j];
                    var altDistance = ik.distance + kj.distance;
                    if (altDistance < ij.distance) {
                        ij.distance = altDistance;
                        ij.predecessor = kj.predecessor
                    }
                })
            })
        });
        return results
    }
}, {}],35: [function(require, module, exports) {
    var topsort = require("./topsort");
    module.exports = isAcyclic;
    function isAcyclic(g) {
        try {
            topsort(g)
        } catch (e) {
            if (e instanceof topsort.CycleException)
                return false;
            throw e
        }
        return true
    }
}, {"./topsort": 40}],36: [function(require, module, exports) {
    var Set = require("cp-data").Set;
    module.exports = postorder;
    function postorder(g, root, f) {
        var visited = new Set;
        if (g.isDirected()) {
            throw new Error("This function only works for undirected graphs")
        }
        function dfs(u, prev) {
            if (visited.has(u)) {
                throw new Error("The input graph is not a tree: " + g)
            }
            visited.add(u);
            g.neighbors(u).forEach(function(v) {
                if (v !== prev)
                    dfs(v, u)
            });
            f(u)
        }
        dfs(root)
    }
}, {"cp-data": 19}],37: [function(require, module, exports) {
    var Set = require("cp-data").Set;
    module.exports = preorder;
    function preorder(g, root, f) {
        var visited = new Set;
        if (g.isDirected()) {
            throw new Error("This function only works for undirected graphs")
        }
        function dfs(u, prev) {
            if (visited.has(u)) {
                throw new Error("The input graph is not a tree: " + g)
            }
            visited.add(u);
            f(u);
            g.neighbors(u).forEach(function(v) {
                if (v !== prev)
                    dfs(v, u)
            })
        }
        dfs(root)
    }
}, {"cp-data": 19}],38: [function(require, module, exports) {
    var Graph = require("../Graph"), PriorityQueue = require("cp-data").PriorityQueue;
    module.exports = prim;
    function prim(g, weightFunc) {
        var result = new Graph, parents = {}, pq = new PriorityQueue, u;
        function updateNeighbors(e) {
            var incidentNodes = g.incidentNodes(e), v = incidentNodes[0] !== u ? incidentNodes[0] : incidentNodes[1], pri = pq.priority(v);
            if (pri !== undefined) {
                var edgeWeight = weightFunc(e);
                if (edgeWeight < pri) {
                    parents[v] = u;
                    pq.decrease(v, edgeWeight)
                }
            }
        }
        if (g.order() === 0) {
            return result
        }
        g.eachNode(function(u) {
            pq.add(u, Number.POSITIVE_INFINITY);
            result.addNode(u)
        });
        pq.decrease(g.nodes()[0], 0);
        var init = false;
        while (pq.size() > 0) {
            u = pq.removeMin();
            if (u in parents) {
                result.addEdge(null, u, parents[u])
            } else if (init) {
                throw new Error("Input graph is not connected: " + g)
            } else {
                init = true
            }
            g.incidentEdges(u).forEach(updateNeighbors)
        }
        return result
    }
}, {"../Graph": 29,"cp-data": 19}],39: [function(require, module, exports) {
    module.exports = tarjan;
    function tarjan(g) {
        if (!g.isDirected()) {
            throw new Error("tarjan can only be applied to a directed graph. Bad input: " + g)
        }
        var index = 0, stack = [], visited = {}, results = [];
        function dfs(u) {
            var entry = visited[u] = {onStack: true,lowlink: index,index: index++};
            stack.push(u);
            g.successors(u).forEach(function(v) {
                if (!(v in visited)) {
                    dfs(v);
                    entry.lowlink = Math.min(entry.lowlink, visited[v].lowlink)
                } else if (visited[v].onStack) {
                    entry.lowlink = Math.min(entry.lowlink, visited[v].index)
                }
            });
            if (entry.lowlink === entry.index) {
                var cmpt = [], v;
                do {
                    v = stack.pop();
                    visited[v].onStack = false;
                    cmpt.push(v)
                } while (u !== v);
                results.push(cmpt)
            }
        }
        g.nodes().forEach(function(u) {
            if (!(u in visited)) {
                dfs(u)
            }
        });
        return results
    }
}, {}],40: [function(require, module, exports) {
    module.exports = topsort;
    topsort.CycleException = CycleException;
    function topsort(g) {
        if (!g.isDirected()) {
            throw new Error("topsort can only be applied to a directed graph. Bad input: " + g)
        }
        var visited = {};
        var stack = {};
        var results = [];
        function visit(node) {
            if (node in stack) {
                throw new CycleException
            }
            if (!(node in visited)) {
                stack[node] = true;
                visited[node] = true;
                g.predecessors(node).forEach(function(pred) {
                    visit(pred)
                });
                delete stack[node];
                results.push(node)
            }
        }
        var sinks = g.sinks();
        if (g.order() !== 0 && sinks.length === 0) {
            throw new CycleException
        }
        g.sinks().forEach(function(sink) {
            visit(sink)
        });
        return results
    }
    function CycleException() {
    }
    CycleException.prototype.toString = function() {
        return "Graph has at least one cycle"
    }
}, {}],41: [function(require, module, exports) {
    var Set = require("cp-data").Set;
    module.exports = compoundify;
    function compoundify(SuperConstructor) {
        function Constructor() {
            SuperConstructor.call(this);
            this._parents = {};
            this._children = {};
            this._children[null] = new Set
        }
        Constructor.prototype = new SuperConstructor;
        Constructor.prototype.constructor = Constructor;
        Constructor.prototype.parent = function(u, parent) {
            this._strictGetNode(u);
            if (arguments.length < 2) {
                return this._parents[u]
            }
            if (u === parent) {
                throw new Error("Cannot make " + u + " a parent of itself")
            }
            if (parent !== null) {
                this._strictGetNode(parent)
            }
            this._children[this._parents[u]].remove(u);
            this._parents[u] = parent;
            this._children[parent].add(u)
        };
        Constructor.prototype.children = function(u) {
            if (u !== null) {
                this._strictGetNode(u)
            }
            return this._children[u].keys()
        };
        Constructor.prototype.addNode = function(u, value) {
            u = SuperConstructor.prototype.addNode.call(this, u, value);
            this._parents[u] = null;
            this._children[u] = new Set;
            this._children[null].add(u);
            return u
        };
        Constructor.prototype.delNode = function(u) {
            var parent = this.parent(u);
            this._children[u].keys().forEach(function(child) {
                this.parent(child, parent)
            }, this);
            this._children[parent].remove(u);
            delete this._parents[u];
            delete this._children[u];
            return SuperConstructor.prototype.delNode.call(this, u)
        };
        Constructor.prototype.copy = function() {
            var copy = SuperConstructor.prototype.copy.call(this);
            this.nodes().forEach(function(u) {
                copy.parent(u, this.parent(u))
            }, this);
            return copy
        };
        Constructor.prototype.filterNodes = function(filter) {
            var self = this, copy = SuperConstructor.prototype.filterNodes.call(this, filter);
            var parents = {};
            function findParent(u) {
                var parent = self.parent(u);
                if (parent === null || copy.hasNode(parent)) {
                    parents[u] = parent;
                    return parent
                } else if (parent in parents) {
                    return parents[parent]
                } else {
                    return findParent(parent)
                }
            }
            copy.eachNode(function(u) {
                copy.parent(u, findParent(u))
            });
            return copy
        };
        return Constructor
    }
}, {"cp-data": 19}],42: [function(require, module, exports) {
    var Graph = require("../Graph"), Digraph = require("../Digraph"), CGraph = require("../CGraph"), CDigraph = require("../CDigraph");
    exports.decode = function(nodes, edges, Ctor) {
        Ctor = Ctor || Digraph;
        if (typeOf(nodes) !== "Array") {
            throw new Error("nodes is not an Array")
        }
        if (typeOf(edges) !== "Array") {
            throw new Error("edges is not an Array")
        }
        if (typeof Ctor === "string") {
            switch (Ctor) {
                case "graph":
                    Ctor = Graph;
                    break;
                case "digraph":
                    Ctor = Digraph;
                    break;
                case "cgraph":
                    Ctor = CGraph;
                    break;
                case "cdigraph":
                    Ctor = CDigraph;
                    break;
                default:
                    throw new Error("Unrecognized graph type: " + Ctor)
            }
        }
        var graph = new Ctor;
        nodes.forEach(function(u) {
            graph.addNode(u.id, u.value)
        });
        if (graph.parent) {
            nodes.forEach(function(u) {
                if (u.children) {
                    u.children.forEach(function(v) {
                        graph.parent(v, u.id)
                    })
                }
            })
        }
        edges.forEach(function(e) {
            graph.addEdge(e.id, e.u, e.v, e.value)
        });
        return graph
    };
    exports.encode = function(graph) {
        var nodes = [];
        var edges = [];
        graph.eachNode(function(u, value) {
            var node = {id: u,value: value};
            if (graph.children) {
                var children = graph.children(u);
                if (children.length) {
                    node.children = children
                }
            }
            nodes.push(node)
        });
        graph.eachEdge(function(e, u, v, value) {
            edges.push({id: e,u: u,v: v,value: value})
        });
        var type;
        if (graph instanceof CDigraph) {
            type = "cdigraph"
        } else if (graph instanceof CGraph) {
            type = "cgraph"
        } else if (graph instanceof Digraph) {
            type = "digraph"
        } else if (graph instanceof Graph) {
            type = "graph"
        } else {
            throw new Error("Couldn't determine type of graph: " + graph)
        }
        return {nodes: nodes,edges: edges,type: type}
    };
    function typeOf(obj) {
        return Object.prototype.toString.call(obj).slice(8, -1)
    }
}, {"../CDigraph": 26,"../CGraph": 27,"../Digraph": 28,"../Graph": 29}],43: [function(require, module, exports) {
    var Set = require("cp-data").Set;
    exports.all = function() {
        return function() {
            return true
        }
    };
    exports.nodesFromList = function(nodes) {
        var set = new Set(nodes);
        return function(u) {
            return set.has(u)
        }
    }
}, {"cp-data": 19}],44: [function(require, module, exports) {
    var Graph = require("./Graph"), Digraph = require("./Digraph");
    Graph.prototype.toDigraph = Graph.prototype.asDirected = function() {
        var g = new Digraph;
        this.eachNode(function(u, value) {
            g.addNode(u, value)
        });
        this.eachEdge(function(e, u, v, value) {
            g.addEdge(null, u, v, value);
            g.addEdge(null, v, u, value)
        });
        return g
    };
    Digraph.prototype.toGraph = Digraph.prototype.asUndirected = function() {
        var g = new Graph;
        this.eachNode(function(u, value) {
            g.addNode(u, value)
        });
        this.eachEdge(function(e, u, v, value) {
            g.addEdge(e, u, v, value)
        });
        return g
    }
}, {"./Digraph": 28,"./Graph": 29}],45: [function(require, module, exports) {
    exports.values = function(o) {
        var ks = Object.keys(o), len = ks.length, result = new Array(len), i;
        for (i = 0; i < len; ++i) {
            result[i] = o[ks[i]]
        }
        return result
    }
}, {}],46: [function(require, module, exports) {
    module.exports = "0.7.4"
}, {}]}, {}, [1]);
joint.layout.DirectedGraph = {layout: function(graph, opt) {
    opt = opt || {};
    var inputGraph = this._prepareData(graph);
    var runner = dagre.layout();
    if (opt.debugLevel) {
        runner.debugLevel(opt.debugLevel)
    }
    if (opt.rankDir) {
        runner.rankDir(opt.rankDir)
    }
    if (opt.rankSep) {
        runner.rankSep(opt.rankSep)
    }
    if (opt.edgeSep) {
        runner.edgeSep(opt.edgeSep)
    }
    if (opt.nodeSep) {
        runner.nodeSep(opt.nodeSep)
    }
    var layoutGraph = runner.run(inputGraph);
    layoutGraph.eachNode(function(u, value) {
        if (!value.dummy) {
            var cell = graph.getCell(u);
            opt.setPosition ? opt.setPosition(cell, value) : graph.get("cells").get(u).set("position", {x: value.x - value.width / 2,y: value.y - value.height / 2})
        }
    });
    if (opt.setLinkVertices) {
        layoutGraph.eachEdge(function(e, u, v, value) {
            var link = graph.getCell(e);
            if (link) {
                opt.setVertices ? opt.setVertices(link, value.points) : link.set("vertices", value.points)
            }
        })
    }
    return {width: layoutGraph.graph().width,height: layoutGraph.graph().height}
},_prepareData: function(graph) {
    var dagreGraph = new dagre.Digraph;
    _.each(graph.getElements(), function(cell) {
        if (dagreGraph.hasNode(cell.id))
            return;
        dagreGraph.addNode(cell.id, {width: cell.get("size").width,height: cell.get("size").height,rank: cell.get("rank")})
    });
    _.each(graph.getLinks(), function(cell) {
        if (dagreGraph.hasEdge(cell.id))
            return;
        var sourceId = cell.get("source").id;
        var targetId = cell.get("target").id;
        dagreGraph.addEdge(cell.id, sourceId, targetId, {minLen: cell.get("minLen") || 1})
    });
    return dagreGraph
}};
if (typeof exports === "object") {
    var joint = {com: {},util: require("../../../src/core").util};
    var WebSocketServer = require("ws").Server;
    var WebSocket = require("ws");
    var _ = require("lodash");
    var url = require("url");
    var Backbone = require("backbone")
}
joint.com = joint.com || {};
joint.com.Channel = function(opt) {
    this.options = opt;
    if (!this.options || !this.options.graph)
        throw new Error("Channel: missing a graph.");
    this.options.ttl = this.options.ttl || 60;
    this.options.healthCheckInterval = this.options.healthCheckInterval || 1e3 * 60 * 60;
    this.options.reconnectInterval = this.options.reconnectInterval || 1e4;
    this.options.serverShouldSendGraph = _.isUndefined(this.options.serverShouldSendGraph) ? true : this.options.serverShouldSendGraph;
    this._isClient = !!this.options.url;
    this._clients = [];
    this.messageQueue = [];
    this.id = this.options.id || (this._isClient ? "c_" : "s_") + joint.util.uuid();
    this.state = {};
    this.state[this.id] = 0;
    this.sites = {};
    this.sites[this.id] = {socket: undefined,outgoing: [],ttl: this.options.ttl};
    this.initialize()
};
_.extend(joint.com.Channel.prototype, Backbone.Events);
joint.com.Channel.prototype.initialize = function() {
    this.options.graph.on("all", this.onGraphChange.bind(this));
    if (this._isClient) {
        this.connectClient()
    } else if (this.options.port) {
        this.server = new WebSocketServer({port: this.options.port});
        this.server.on("connection", this.onConnection.bind(this))
    }
    if (!this._isClient) {
        this._healthCheckInterval = setInterval(this.healthCheck.bind(this), this.options.healthCheckInterval)
    }
};
joint.com.Channel.prototype.connectClient = function() {
    var url = this.options.url + "/?channelId=" + this.id + "&state=" + JSON.stringify(this.state) + (this.options.query ? "&query=" + JSON.stringify(this.options.query) : "");
    if (this.options.debugLevel > 0)
        this.log("connectClient", url);
    var socket = new WebSocket(url);
    socket.onopen = this.onConnection.bind(this, socket);
    socket.onclose = this.onClose.bind(this, socket)
};
joint.com.Channel.prototype.close = function() {
    if (this._reconnectTimeout)
        clearTimeout(this._reconnectTimeout);
    if (this._healthCheckInterval)
        clearInterval(this._healthCheckInterval);
    this._closed = true;
    _.each(this.sites, function(site) {
        if (site.socket)
            site.socket.close()
    });
    if (this.server)
        this.server.close()
};
joint.com.Channel.prototype.healthCheck = function() {
    if (this.options.debugLevel > 0)
        this.log("healthCheck", _.object(_.keys(this.sites), _.pluck(this.sites, "ttl")));
    _.each(this.sites, function(site, channelId) {
        if (channelId === this.id)
            return;
        if (!site.socket || site.socket.readyState !== 1) {
            site.ttl -= 1
        } else {
            site.ttl = this.options.ttl
        }
        if (site.ttl <= 0) {
            delete this.sites[channelId];
            delete this.state[channelId]
        }
    }, this)
};
joint.com.Channel.prototype.onConnection = function(socket) {
    this._clients.push(socket);
    if (this._isClient) {
        this.sites[this.id].socket = socket;
        socket.onmessage = function(evt) {
            this.onMessage(socket, evt.data)
        }.bind(this)
    } else {
        var upgradeReqUrl = url.parse(socket.upgradeReq.url, true);
        var channelId = upgradeReqUrl.query.channelId;
        if (this.sites[channelId]) {
            this.sites[channelId].socket = socket
        } else {
            if (this.debugLevel > 1)
                this.log("new_site", channelId);
            this.sites[channelId] = {socket: socket,outgoing: [],ttl: this.options.ttl};
            this.state[channelId] = 0;
            if (this.options.serverShouldSendGraph) {
                var op = {channelId: this.id,state: JSON.parse(JSON.stringify(this.state)),action: "graph",graph: this.options.graph.toJSON()};
                this.messageQueue.push({type: "op",data: op,source: this.id,target: [channelId]});
                this.send()
            }
        }
        socket.on("message", this.onMessage.bind(this, socket));
        socket.on("close", this.onClose.bind(this, socket))
    }
};
joint.com.Channel.prototype.onClose = function(socket) {
    var index = this._clients.indexOf(socket);
    if (index !== -1) {
        this._clients.splice(index, 1)
    }
    if (this._isClient && !this._closed) {
        if (this._reconnectTimeout)
            clearTimeout(this._reconnectTimeout);
        this._reconnectTimeout = setTimeout(this.connectClient.bind(this), this.options.reconnectInterval)
    }
    this.trigger("close", socket)
};
joint.com.Channel.prototype.onMessage = function(socket, message) {
    this.trigger("message:received", message);
    if (this.options.debugLevel > 1)
        this.log("message", message);
    try {
        message = JSON.parse(message)
    } catch (err) {
        return console.error("Channel: message parsing failed.", err)
    }
    if (message.type == "notification") {
        this.trigger(message.data.event, message.data.data);
        return this.sendNotification(message)
    }
    var op = message.data;
    if (this._isClient) {
        var mySite = this.sites[this.id];
        op = this.receive(mySite, this.id, op)
    } else {
        var otherSite = this.sites[op.channelId];
        op = this.receive(otherSite, op.channelId, op);
        var mySite = this.sites[this.id];
        op = this.receive(mySite, this.id, op)
    }
    if (op.action === "graph") {
        this.state[op.channelId] = op.state[op.channelId]
    } else {
        this.state[op.channelId] = (this.state[op.channelId] || 0) + 1
    }
    if (this.options.debugLevel > 1)
        this.log("new state", this.state);
    this.execute(op);
    _.each(this.sites, function(site, channelId) {
        if (channelId !== this.id && channelId !== op.channelId) {
            this.receive(site, channelId, op)
        }
    }, this);
    if (!this._isClient) {
        message.op = op;
        this.messageQueue.push(message);
        this.broadcast(message)
    }
    this.trigger("message:processed", message)
};
joint.com.Channel.prototype.receive = function(site, channelId, op) {
    if (!site)
        return op;
    if (this.options.debugLevel > 1)
        this.log("receive", channelId, op);
    if (this.options.debugLevel > 1)
        this.log("outgoing", site.outgoing);
    site.outgoing = _.filter(site.outgoing, function(oldOp) {
        return oldOp.state[oldOp.channelId] >= (op.state[oldOp.channelId] || 0)
    });
    if (this.options.debugLevel > 1)
        this.log("outgoing.length", site.outgoing.length);
    for (var i = 0; i < site.outgoing.length; i++) {
        var oldOp = site.outgoing[i];
        var transformResult = this.transform(op, oldOp);
        op = transformResult[0];
        site.outgoing[i] = transformResult[1]
    }
    return op
};
joint.com.Channel.prototype.transform = function(o1, o2) {
    if (this.options.debugLevel > 1)
        this.log("transform", o1, o2);
    if (o1.action === "change:target" && o2.action === "remove") {
        if (o1.cell.target.id === o2.cell.id) {
            o1.cell.target = {x: 0,y: 0}
        }
    }
    if (o1.action === "change:source" && o2.action === "remove") {
        if (o1.cell.source.id === o2.cell.id) {
            o1.cell.source = {x: 0,y: 0}
        }
    }
    return [o1, o2]
};
joint.com.Channel.prototype.execute = function(op) {
    var cell;
    switch (op.action) {
        case "add":
            this.options.graph.addCell(op.cell, {remote: true});
            break;
        case "remove":
            cell = this.options.graph.getCell(op.cell.id);
            if (cell)
                cell.remove({remote: true,disconnectLinks: true});
            break;
        case "graph":
            this.options.graph.fromJSON(op.graph);
            break;
        default:
            var attribute = op.action.substr("change:".length);
            cell = this.options.graph.getCell(op.cell.id);
            if (cell)
                cell.set(attribute, op.cell[attribute], {remote: true});
            break
    }
};
joint.com.Channel.prototype.broadcast = function(message) {
    if (this._isClient) {
        message.target = _.keys(this.sites)
    } else {
        message.target = _.keys(_.omit(this.sites, this.id, message.source))
    }
    this.send()
};
joint.com.Channel.prototype.send = function() {
    if (this._paused)
        return;
    var toRemove = [];
    for (var i = 0; i < this.messageQueue.length; i++) {
        var m = this.messageQueue[i];
        if (this.sendMessage(m)) {
            toRemove.push(i)
        }
    }
    toRemove.forEach(_.bind(function(msgIdx) {
        this.messageQueue.splice(msgIdx, 1)
    }, this))
};
joint.com.Channel.prototype.sendMessage = function(m) {
    if (this.debugLevel > 1)
        this.log("sendMessage", m);
    var successTargets = [];
    m.target.forEach(function(target, idx) {
        var recievingSite = this.sites[target];
        if (!recievingSite)
            return successTargets.push(idx);
        if (!recievingSite.socket)
            return;
        if (recievingSite.socket.readyState !== 1)
            return;
        if (this.debugLevel > 1)
            this.log("sendMessage", target, m);
        recievingSite.socket.send(JSON.stringify(m));
        successTargets.push(idx)
    }, this);
    successTargets.forEach(function(targetIdx) {
        m.target.splice(targetIdx, 1)
    });
    if (!m.target.length)
        return true;
    return false
};
joint.com.Channel.prototype.log = function(keyword, args) {
    var text = "Channel [" + this.id + "] " + keyword.toUpperCase() + ": ";
    console.log.apply(console, [text].concat(_.rest(_.toArray(arguments))))
};
joint.com.Channel.prototype.pause = function() {
    this._paused = true
};
joint.com.Channel.prototype.unpause = function() {
    this._paused = false;
    this.send()
};
joint.com.Channel.prototype.notify = function(event, data) {
    var message = {type: "notification",source: this.id,data: {event: event,data: data}};
    this.sendNotification(message)
};
joint.com.Channel.prototype.sendNotification = function(message) {
    if (this._isClient) {
        message.target = _.keys(this.sites)
    } else {
        message.target = _.keys(_.omit(this.sites, this.id, message.source))
    }
    this.sendMessage(message)
};
joint.com.Channel.prototype.onGraphChange = function(eventName, cell, graph, options) {
    if (options && options.remote)
        return;
    var isInteresting = eventName === "add" || eventName === "remove" || eventName.substr(0, "change:".length) === "change:";
    if (!isInteresting)
        return;
    var op = {channelId: this.id,state: JSON.parse(JSON.stringify(this.state)),action: eventName,cell: cell.toJSON()};
    var message = {type: "op",data: op,source: this.id};
    if (this.options.debugLevel > 1)
        this.log("generate", message);
    this.messageQueue.push(message);
    this.broadcast(message);
    this.sites[this.id].outgoing.push(op);
    this.state[this.id]++
};
joint.com.ChannelHub = function(opt) {
    this.options = opt;
    if (!this.options.port)
        throw new Error("ChannelHub: missing a port.");
    this.initialize()
};
_.extend(joint.com.ChannelHub.prototype, Backbone.Events);
joint.com.ChannelHub.prototype.initialize = function() {
    this.server = new WebSocketServer({port: this.options.port});
    this.server.on("connection", this.onConnection.bind(this))
};
joint.com.ChannelHub.prototype.onConnection = function(socket) {
    var upgradeReqUrl = url.parse(socket.upgradeReq.url, true);
    var req = {query: upgradeReqUrl.query};
    if (!this.router)
        throw new Error("ChannelHub: missing a router.");
    var channel = this.router(req);
    channel.onConnection(socket)
};
joint.com.ChannelHub.prototype.route = function(router) {
    this.router = router
};
joint.com.ChannelHub.prototype.close = function() {
    this.server.close()
};
if (typeof exports === "object") {
    module.exports.Channel = joint.com.Channel;
    module.exports.ChannelHub = joint.com.ChannelHub
}
(function(context, factory) {
    [].indexOf || (Array.prototype.indexOf = function(a, b, c) {
        for (c = this.length, b = (c + ~~b) % c; b < c && (!(b in this) || this[b] !== a); b++)
            ;
        return b ^ c ? b : -1
    });
    if (typeof define === "function" && define.amd) {
        define(constructAMD)
    } else {
        constructGlobal()
    }
    function constructAMD() {
        return init();
        function init() {
            var library;
            library = factory("amd");
            library.fork = init;
            return library
        }
    }
    function constructGlobal() {
        var library;
        library = init();
        library.noConflict("KeyboardJS", "k");
        function init() {
            var library, namespaces = [], previousValues = {};
            library = factory("global");
            library.fork = init;
            library.noConflict = noConflict;
            return library;
            function noConflict() {
                var args, nI, newNamespaces;
                newNamespaces = Array.prototype.slice.apply(arguments);
                for (nI = 0; nI < namespaces.length; nI += 1) {
                    if (typeof previousValues[namespaces[nI]] === "undefined") {
                        delete context[namespaces[nI]]
                    } else {
                        context[namespaces[nI]] = previousValues[namespaces[nI]]
                    }
                }
                previousValues = {};
                for (nI = 0; nI < newNamespaces.length; nI += 1) {
                    if (typeof newNamespaces[nI] !== "string") {
                        throw new Error("Cannot replace namespaces. All new namespaces must be strings.")
                    }
                    previousValues[newNamespaces[nI]] = context[newNamespaces[nI]];
                    context[newNamespaces[nI]] = library
                }
                namespaces = newNamespaces;
                return namespaces
            }
        }
    }
})(this, function(env) {
    var KeyboardJS = {}, locales = {}, locale, map, macros, activeKeys = [], bindings = [], activeBindings = [], activeMacros = [], aI, usLocale;
    usLocale = {map: {3: ["cancel"],8: ["backspace"],9: ["tab"],12: ["clear"],13: ["enter"],16: ["shift"],17: ["ctrl"],18: ["alt", "menu"],19: ["pause", "break"],20: ["capslock"],27: ["escape", "esc"],32: ["space", "spacebar"],33: ["pageup"],34: ["pagedown"],35: ["end"],36: ["home"],37: ["left"],38: ["up"],39: ["right"],40: ["down"],41: ["select"],42: ["printscreen"],43: ["execute"],44: ["snapshot"],45: ["insert", "ins"],46: ["delete", "del"],47: ["help"],91: ["command", "windows", "win", "super", "leftcommand", "leftwindows", "leftwin", "leftsuper"],92: ["command", "windows", "win", "super", "rightcommand", "rightwindows", "rightwin", "rightsuper"],145: ["scrolllock", "scroll"],186: ["semicolon", ";"],187: ["equal", "equalsign", "="],188: ["comma", ","],189: ["dash", "-"],190: ["period", "."],191: ["slash", "forwardslash", "/"],192: ["graveaccent", "`"],219: ["openbracket", "["],220: ["backslash", "\\"],221: ["closebracket", "]"],222: ["apostrophe", "'"],48: ["zero", "0"],49: ["one", "1"],50: ["two", "2"],51: ["three", "3"],52: ["four", "4"],53: ["five", "5"],54: ["six", "6"],55: ["seven", "7"],56: ["eight", "8"],57: ["nine", "9"],96: ["numzero", "num0"],97: ["numone", "num1"],98: ["numtwo", "num2"],99: ["numthree", "num3"],100: ["numfour", "num4"],101: ["numfive", "num5"],102: ["numsix", "num6"],103: ["numseven", "num7"],104: ["numeight", "num8"],105: ["numnine", "num9"],106: ["nummultiply", "num*"],107: ["numadd", "num+"],108: ["numenter"],109: ["numsubtract", "num-"],110: ["numdecimal", "num."],111: ["numdevide", "num/"],144: ["numlock", "num"],112: ["f1"],113: ["f2"],114: ["f3"],115: ["f4"],116: ["f5"],117: ["f6"],118: ["f7"],119: ["f8"],120: ["f9"],121: ["f10"],122: ["f11"],123: ["f12"]},macros: [["shift + `", ["tilde", "~"]], ["shift + 1", ["exclamation", "exclamationpoint", "!"]], ["shift + 2", ["at", "@"]], ["shift + 3", ["number", "#"]], ["shift + 4", ["dollar", "dollars", "dollarsign", "$"]], ["shift + 5", ["percent", "%"]], ["shift + 6", ["caret", "^"]], ["shift + 7", ["ampersand", "and", "&"]], ["shift + 8", ["asterisk", "*"]], ["shift + 9", ["openparen", "("]], ["shift + 0", ["closeparen", ")"]], ["shift + -", ["underscore", "_"]], ["shift + =", ["plus", "+"]], ["shift + (", ["opencurlybrace", "opencurlybracket", "{"]], ["shift + )", ["closecurlybrace", "closecurlybracket", "}"]], ["shift + \\", ["verticalbar", "|"]], ["shift + ;", ["colon", ":"]], ["shift + '", ["quotationmark", '"']], ["shift + !,", ["openanglebracket", "<"]], ["shift + .", ["closeanglebracket", ">"]], ["shift + /", ["questionmark", "?"]]]};
    for (aI = 65; aI <= 90; aI += 1) {
        usLocale.map[aI] = String.fromCharCode(aI + 32);
        usLocale.macros.push(["shift + " + String.fromCharCode(aI + 32) + ", capslock + " + String.fromCharCode(aI + 32), [String.fromCharCode(aI)]])
    }
    registerLocale("us", usLocale);
    getSetLocale("us");
    enable();
    KeyboardJS.enable = enable;
    KeyboardJS.disable = disable;
    KeyboardJS.activeKeys = getActiveKeys;
    KeyboardJS.on = createBinding;
    KeyboardJS.clear = removeBindingByKeyCombo;
    KeyboardJS.clear.key = removeBindingByKeyName;
    KeyboardJS.locale = getSetLocale;
    KeyboardJS.locale.register = registerLocale;
    KeyboardJS.macro = createMacro;
    KeyboardJS.macro.remove = removeMacro;
    KeyboardJS.key = {};
    KeyboardJS.key.name = getKeyName;
    KeyboardJS.key.code = getKeyCode;
    KeyboardJS.combo = {};
    KeyboardJS.combo.active = isSatisfiedCombo;
    KeyboardJS.combo.parse = parseKeyCombo;
    KeyboardJS.combo.stringify = stringifyKeyCombo;
    return KeyboardJS;
    function enable() {
        if (window.addEventListener) {
            document.addEventListener("keydown", keydown, false);
            document.addEventListener("keyup", keyup, false);
            window.addEventListener("blur", reset, false);
            window.addEventListener("webkitfullscreenchange", reset, false);
            window.addEventListener("mozfullscreenchange", reset, false)
        } else if (window.attachEvent) {
            document.attachEvent("onkeydown", keydown);
            document.attachEvent("onkeyup", keyup);
            window.attachEvent("onblur", reset)
        }
    }
    function disable() {
        reset();
        if (window.removeEventListener) {
            document.removeEventListener("keydown", keydown, false);
            document.removeEventListener("keyup", keyup, false);
            window.removeEventListener("blur", reset, false);
            window.removeEventListener("webkitfullscreenchange", reset, false);
            window.removeEventListener("mozfullscreenchange", reset, false)
        } else if (window.detachEvent) {
            document.detachEvent("onkeydown", keydown);
            document.detachEvent("onkeyup", keyup);
            window.detachEvent("onblur", reset)
        }
    }
    function reset(event) {
        activeKeys = [];
        pruneMacros();
        pruneBindings(event)
    }
    function keydown(event) {
        var keyNames, kI;
        keyNames = getKeyName(event.keyCode);
        if (keyNames.length < 1) {
            return
        }
        for (kI = 0; kI < keyNames.length; kI += 1) {
            addActiveKey(keyNames[kI])
        }
        executeMacros();
        executeBindings(event)
    }
    function keyup(event) {
        var keyNames, kI;
        keyNames = getKeyName(event.keyCode);
        if (keyNames.length < 1) {
            return
        }
        for (kI = 0; kI < keyNames.length; kI += 1) {
            removeActiveKey(keyNames[kI])
        }
        pruneMacros();
        pruneBindings(event)
    }
    function getKeyName(keyCode) {
        return map[keyCode] || []
    }
    function getKeyCode(keyName) {
        var keyCode;
        for (keyCode in map) {
            if (!map.hasOwnProperty(keyCode)) {
                continue
            }
            if (map[keyCode].indexOf(keyName) > -1) {
                return keyCode
            }
        }
        return false
    }
    function createMacro(combo, injectedKeys) {
        if (typeof combo !== "string" && (typeof combo !== "object" || typeof combo.push !== "function")) {
            throw new Error("Cannot create macro. The combo must be a string or array.")
        }
        if (typeof injectedKeys !== "object" || typeof injectedKeys.push !== "function") {
            throw new Error("Cannot create macro. The injectedKeys must be an array.")
        }
        macros.push([combo, injectedKeys])
    }
    function removeMacro(combo) {
        var macro;
        if (typeof combo !== "string" && (typeof combo !== "object" || typeof combo.push !== "function")) {
            throw new Error("Cannot remove macro. The combo must be a string or array.")
        }
        for (mI = 0; mI < macros.length; mI += 1) {
            macro = macros[mI];
            if (compareCombos(combo, macro[0])) {
                removeActiveKey(macro[1]);
                macros.splice(mI, 1);
                break
            }
        }
    }
    function executeMacros() {
        var mI, combo, kI;
        for (mI = 0; mI < macros.length; mI += 1) {
            combo = parseKeyCombo(macros[mI][0]);
            if (activeMacros.indexOf(macros[mI]) === -1 && isSatisfiedCombo(combo)) {
                activeMacros.push(macros[mI]);
                for (kI = 0; kI < macros[mI][1].length; kI += 1) {
                    addActiveKey(macros[mI][1][kI])
                }
            }
        }
    }
    function pruneMacros() {
        var mI, combo, kI;
        for (mI = 0; mI < activeMacros.length; mI += 1) {
            combo = parseKeyCombo(activeMacros[mI][0]);
            if (isSatisfiedCombo(combo) === false) {
                for (kI = 0; kI < activeMacros[mI][1].length; kI += 1) {
                    removeActiveKey(activeMacros[mI][1][kI])
                }
                activeMacros.splice(mI, 1);
                mI -= 1
            }
        }
    }
    function createBinding(keyCombo, keyDownCallback, keyUpCallback) {
        var api = {}, binding, subBindings = [], bindingApi = {}, kI, subCombo;
        if (typeof keyCombo === "string") {
            keyCombo = parseKeyCombo(keyCombo)
        }
        for (kI = 0; kI < keyCombo.length; kI += 1) {
            binding = {};
            subCombo = stringifyKeyCombo([keyCombo[kI]]);
            if (typeof subCombo !== "string") {
                throw new Error("Failed to bind key combo. The key combo must be string.")
            }
            binding.keyCombo = subCombo;
            binding.keyDownCallback = [];
            binding.keyUpCallback = [];
            if (keyDownCallback) {
                binding.keyDownCallback.push(keyDownCallback)
            }
            if (keyUpCallback) {
                binding.keyUpCallback.push(keyUpCallback)
            }
            bindings.push(binding);
            subBindings.push(binding)
        }
        api.clear = clear;
        api.on = on;
        return api;
        function clear() {
            var bI;
            for (bI = 0; bI < subBindings.length; bI += 1) {
                bindings.splice(bindings.indexOf(subBindings[bI]), 1)
            }
        }
        function on(eventName) {
            var api = {}, callbacks, cI, bI;
            if (typeof eventName !== "string") {
                throw new Error("Cannot bind callback. The event name must be a string.")
            }
            if (eventName !== "keyup" && eventName !== "keydown") {
                throw new Error('Cannot bind callback. The event name must be a "keyup" or "keydown".')
            }
            callbacks = Array.prototype.slice.apply(arguments, [1]);
            for (cI = 0; cI < callbacks.length; cI += 1) {
                if (typeof callbacks[cI] === "function") {
                    if (eventName === "keyup") {
                        for (bI = 0; bI < subBindings.length; bI += 1) {
                            subBindings[bI].keyUpCallback.push(callbacks[cI])
                        }
                    } else if (eventName === "keydown") {
                        for (bI = 0; bI < subBindings.length; bI += 1) {
                            subBindings[bI].keyDownCallback.push(callbacks[cI])
                        }
                    }
                }
            }
            api.clear = clear;
            return api;
            function clear() {
                var cI, bI;
                for (cI = 0; cI < callbacks.length; cI += 1) {
                    if (typeof callbacks[cI] === "function") {
                        if (eventName === "keyup") {
                            for (bI = 0; bI < subBindings.length; bI += 1) {
                                subBindings[bI].keyUpCallback.splice(subBindings[bI].keyUpCallback.indexOf(callbacks[cI]), 1)
                            }
                        } else {
                            for (bI = 0; bI < subBindings.length; bI += 1) {
                                subBindings[bI].keyDownCallback.splice(subBindings[bI].keyDownCallback.indexOf(callbacks[cI]), 1)
                            }
                        }
                    }
                }
            }
        }
    }
    function removeBindingByKeyCombo(keyCombo) {
        var bI, binding, keyName;
        for (bI = 0; bI < bindings.length; bI += 1) {
            binding = bindings[bI];
            if (compareCombos(keyCombo, binding.keyCombo)) {
                bindings.splice(bI, 1);
                bI -= 1
            }
        }
    }
    function removeBindingByKeyName(keyName) {
        var bI, cI, binding;
        if (keyName) {
            for (bI = 0; bI < bindings.length; bI += 1) {
                binding = bindings[bI];
                for (cI = 0; cI < binding.keyCombo.length; cI += 1) {
                    if (binding.keyCombo[kI].indexOf(keyName) > -1) {
                        bindings.splice(bI, 1);
                        bI -= 1;
                        break
                    }
                }
            }
        } else {
            bindings = []
        }
    }
    function executeBindings(event) {
        var bI, sBI, binding, bidningKeys, remainingKeys, cI, killEventBubble, kI, bindingKeysSatisfied, index, sortedBindings = [], bindingWeight;
        remainingKeys = [].concat(activeKeys);
        for (bI = 0; bI < bindings.length; bI += 1) {
            bindingWeight = extractComboKeys(bindings[bI].keyCombo).length;
            if (!sortedBindings[bindingWeight]) {
                sortedBindings[bindingWeight] = []
            }
            sortedBindings[bindingWeight].push(bindings[bI])
        }
        for (sBI = sortedBindings.length - 1; sBI >= 0; sBI -= 1) {
            if (!sortedBindings[sBI]) {
                continue
            }
            for (bI = 0; bI < sortedBindings[sBI].length; bI += 1) {
                binding = sortedBindings[sBI][bI];
                bindingKeys = extractComboKeys(binding.keyCombo);
                bindingKeysSatisfied = true;
                for (kI = 0; kI < bindingKeys.length; kI += 1) {
                    if (remainingKeys.indexOf(bindingKeys[kI]) === -1) {
                        bindingKeysSatisfied = false;
                        break
                    }
                }
                if (bindingKeysSatisfied && isSatisfiedCombo(binding.keyCombo)) {
                    activeBindings.push(binding);
                    for (kI = 0; kI < bindingKeys.length; kI += 1) {
                        index = remainingKeys.indexOf(bindingKeys[kI]);
                        if (index > -1) {
                            remainingKeys.splice(index, 1);
                            kI -= 1
                        }
                    }
                    for (cI = 0; cI < binding.keyDownCallback.length; cI += 1) {
                        if (binding.keyDownCallback[cI](event, getActiveKeys(), binding.keyCombo) === false) {
                            killEventBubble = true
                        }
                    }
                    if (killEventBubble === true) {
                        event.preventDefault();
                        event.stopPropagation()
                    }
                }
            }
        }
    }
    function pruneBindings(event) {
        var bI, cI, binding, killEventBubble;
        for (bI = 0; bI < activeBindings.length; bI += 1) {
            binding = activeBindings[bI];
            if (isSatisfiedCombo(binding.keyCombo) === false) {
                for (cI = 0; cI < binding.keyUpCallback.length; cI += 1) {
                    if (binding.keyUpCallback[cI](event, getActiveKeys(), binding.keyCombo) === false) {
                        killEventBubble = true
                    }
                }
                if (killEventBubble === true) {
                    event.preventDefault();
                    event.stopPropagation()
                }
                activeBindings.splice(bI, 1);
                bI -= 1
            }
        }
    }
    function compareCombos(keyComboArrayA, keyComboArrayB) {
        var cI, sI, kI;
        keyComboArrayA = parseKeyCombo(keyComboArrayA);
        keyComboArrayB = parseKeyCombo(keyComboArrayB);
        if (keyComboArrayA.length !== keyComboArrayB.length) {
            return false
        }
        for (cI = 0; cI < keyComboArrayA.length; cI += 1) {
            if (keyComboArrayA[cI].length !== keyComboArrayB[cI].length) {
                return false
            }
            for (sI = 0; sI < keyComboArrayA[cI].length; sI += 1) {
                if (keyComboArrayA[cI][sI].length !== keyComboArrayB[cI][sI].length) {
                    return false
                }
                for (kI = 0; kI < keyComboArrayA[cI][sI].length; kI += 1) {
                    if (keyComboArrayB[cI][sI].indexOf(keyComboArrayA[cI][sI][kI]) === -1) {
                        return false
                    }
                }
            }
        }
        return true
    }
    function isSatisfiedCombo(keyCombo) {
        var cI, sI, stage, kI, stageOffset = 0, index, comboMatches;
        keyCombo = parseKeyCombo(keyCombo);
        for (cI = 0; cI < keyCombo.length; cI += 1) {
            comboMatches = true;
            stageOffset = 0;
            for (sI = 0; sI < keyCombo[cI].length; sI += 1) {
                stage = [].concat(keyCombo[cI][sI]);
                for (kI = stageOffset; kI < activeKeys.length; kI += 1) {
                    index = stage.indexOf(activeKeys[kI]);
                    if (index > -1) {
                        stage.splice(index, 1);
                        stageOffset = kI
                    }
                }
                if (stage.length !== 0) {
                    comboMatches = false;
                    break
                }
            }
            if (comboMatches) {
                return true
            }
        }
        return false
    }
    function extractComboKeys(keyCombo) {
        var cI, sI, kI, keys = [];
        keyCombo = parseKeyCombo(keyCombo);
        for (cI = 0; cI < keyCombo.length; cI += 1) {
            for (sI = 0; sI < keyCombo[cI].length; sI += 1) {
                keys = keys.concat(keyCombo[cI][sI])
            }
        }
        return keys
    }
    function parseKeyCombo(keyCombo) {
        var s = keyCombo, i = 0, op = 0, ws = false, nc = false, combos = [], combo = [], stage = [], key = "";
        if (typeof keyCombo === "object" && typeof keyCombo.push === "function") {
            return keyCombo
        }
        if (typeof keyCombo !== "string") {
            throw new Error('Cannot parse "keyCombo" because its type is "' + typeof keyCombo + '". It must be a "string".')
        }
        while (s.charAt(i) === " ") {
            i += 1
        }
        while (true) {
            if (s.charAt(i) === " ") {
                while (s.charAt(i) === " ") {
                    i += 1
                }
                ws = true
            } else if (s.charAt(i) === ",") {
                if (op || nc) {
                    throw new Error("Failed to parse key combo. Unexpected , at character index " + i + ".")
                }
                nc = true;
                i += 1
            } else if (s.charAt(i) === "+") {
                if (key.length) {
                    stage.push(key);
                    key = ""
                }
                if (op || nc) {
                    throw new Error("Failed to parse key combo. Unexpected + at character index " + i + ".")
                }
                op = true;
                i += 1
            } else if (s.charAt(i) === ">") {
                if (key.length) {
                    stage.push(key);
                    key = ""
                }
                if (stage.length) {
                    combo.push(stage);
                    stage = []
                }
                if (op || nc) {
                    throw new Error("Failed to parse key combo. Unexpected > at character index " + i + ".")
                }
                op = true;
                i += 1
            } else if (i < s.length - 1 && s.charAt(i) === "!" && (s.charAt(i + 1) === ">" || s.charAt(i + 1) === "," || s.charAt(i + 1) === "+")) {
                key += s.charAt(i + 1);
                op = false;
                ws = false;
                nc = false;
                i += 2
            } else if (i < s.length && s.charAt(i) !== "+" && s.charAt(i) !== ">" && s.charAt(i) !== "," && s.charAt(i) !== " ") {
                if (op === false && ws === true || nc === true) {
                    if (key.length) {
                        stage.push(key);
                        key = ""
                    }
                    if (stage.length) {
                        combo.push(stage);
                        stage = []
                    }
                    if (combo.length) {
                        combos.push(combo);
                        combo = []
                    }
                }
                op = false;
                ws = false;
                nc = false;
                while (i < s.length && s.charAt(i) !== "+" && s.charAt(i) !== ">" && s.charAt(i) !== "," && s.charAt(i) !== " ") {
                    key += s.charAt(i);
                    i += 1
                }
            } else {
                i += 1;
                continue
            }
            if (i >= s.length) {
                if (key.length) {
                    stage.push(key);
                    key = ""
                }
                if (stage.length) {
                    combo.push(stage);
                    stage = []
                }
                if (combo.length) {
                    combos.push(combo);
                    combo = []
                }
                break
            }
        }
        return combos
    }
    function stringifyKeyCombo(keyComboArray) {
        var cI, ccI, output = [];
        if (typeof keyComboArray === "string") {
            return keyComboArray
        }
        if (typeof keyComboArray !== "object" || typeof keyComboArray.push !== "function") {
            throw new Error("Cannot stringify key combo.")
        }
        for (cI = 0; cI < keyComboArray.length; cI += 1) {
            output[cI] = [];
            for (ccI = 0; ccI < keyComboArray[cI].length; ccI += 1) {
                output[cI][ccI] = keyComboArray[cI][ccI].join(" + ")
            }
            output[cI] = output[cI].join(" > ")
        }
        return output.join(" ")
    }
    function getActiveKeys() {
        return [].concat(activeKeys)
    }
    function addActiveKey(keyName) {
        if (keyName.match(/\s/)) {
            throw new Error("Cannot add key name " + keyName + " to active keys because it contains whitespace.")
        }
        if (activeKeys.indexOf(keyName) > -1) {
            return
        }
        activeKeys.push(keyName)
    }
    function removeActiveKey(keyName) {
        var keyCode = getKeyCode(keyName);
        if (keyCode === "91" || keyCode === "92") {
            activeKeys = []
        } else {
            activeKeys.splice(activeKeys.indexOf(keyName), 1)
        }
    }
    function registerLocale(localeName, localeMap) {
        if (typeof localeName !== "string") {
            throw new Error("Cannot register new locale. The locale name must be a string.")
        }
        if (typeof localeMap !== "object") {
            throw new Error("Cannot register " + localeName + " locale. The locale map must be an object.")
        }
        if (typeof localeMap.map !== "object") {
            throw new Error("Cannot register " + localeName + " locale. The locale map is invalid.")
        }
        if (!localeMap.macros) {
            localeMap.macros = []
        }
        locales[localeName] = localeMap
    }
    function getSetLocale(localeName) {
        if (localeName) {
            if (typeof localeName !== "string") {
                throw new Error("Cannot set locale. The locale name must be a string.")
            }
            if (!locales[localeName]) {
                throw new Error("Cannot set locale to " + localeName + " because it does not exist. If you would like to submit a " + localeName + " locale map for KeyboardJS please submit it at https://github.com/RobertWHurst/KeyboardJS/issues.")
            }
            map = locales[localeName].map;
            macros = locales[localeName].macros;
            locale = localeName
        }
        return locale
    }
});
var CommonInspectorInputs = {size: {width: {type: "number",min: 1,max: 500,group: "geometry",label: "width",index: 1},height: {type: "number",min: 1,max: 500,group: "geometry",label: "height",index: 2}},position: {x: {type: "number",min: 1,max: 2e3,group: "geometry",label: "x",index: 3},y: {type: "number",min: 1,max: 2e3,group: "geometry",label: "y",index: 4}},custom: {type: "text",group: "data",index: 1,label: "Custom data",attrs: {label: {"data-tooltip": "An example of setting custom data via Inspector."}}}};
var CommonInspectorGroups = {text: {label: "Text",index: 1},presentation: {label: "Presentation",index: 2},geometry: {label: "Geometry",index: 3},data: {label: "Data",index: 4}};
var CommonInspectorTextInputs = {text: {type: "textarea",group: "text",index: 1},"font-size": {type: "range",min: 5,max: 80,unit: "px",group: "text",index: 2},"font-family": {type: "select",options: ["Arial", "Helvetica", "Times New Roman", "Courier New", "Georgia", "Garamond", "Tahoma", "Lucida Console", "Comic Sans MS"],group: "text",index: 3},"font-weight": {type: "range",min: 100,max: 900,step: 100,defaultValue: 400,group: "text",index: 4},fill: {type: "color",group: "text",index: 5},stroke: {type: "color",group: "text",index: 6,defaultValue: "#000000"},"stroke-width": {type: "range",min: 0,max: 5,step: .5,defaultValue: 0,unit: "px",group: "text",index: 7},"ref-x": {type: "range",min: 0,max: .9,step: .1,defaultValue: .5,group: "text",index: 8},"ref-y": {type: "range",min: 0,max: .9,step: .1,defaultValue: .5,group: "text",index: 9}};
var InputDefs = {text: {type: "textarea",label: "Text"},"font-size": {type: "range",min: 5,max: 80,unit: "px",label: "Font size"},"font-family": {type: "select",options: ["Arial", "Helvetica", "Times New Roman", "Courier New", "Georgia", "Garamond", "Tahoma", "Lucida Console", "Comic Sans MS"],label: "Font family"},"font-weight": {type: "range",min: 100,max: 900,step: 100,defaultValue: 400,label: "Font weight"},fill: {type: "color",label: "Fill color"},stroke: {type: "color",defaultValue: "#000000",label: "Stroke"},"stroke-width": {type: "range",min: 0,max: 5,step: .5,defaultValue: 0,unit: "px",label: "Stroke width"},"ref-x": {type: "range",min: 0,max: .9,step: .1,defaultValue: .5,label: "Horizontal alignment"},"ref-y": {type: "range",min: 0,max: .9,step: .1,defaultValue: .5,label: "Vertical alignment"},"ref-dx": {type: "range",min: 0,max: 50,step: 1,defaultValue: 0,label: "Horizontal offset"},"ref-dy": {type: "range",min: 0,max: 50,step: 1,defaultValue: 0,label: "Vertical offset"},dx: {type: "range",min: 0,max: 50,step: 1,defaultValue: 0,label: "Horizontal distance"},dy: {type: "range",min: 0,max: 50,step: 1,defaultValue: 0,label: "Vertical distance"},"stroke-dasharray": {type: "select",options: ["0", "1", "5,5", "5,10", "10,5", "3,5", "5,1", "15,10,5,10,15"],label: "Stroke dasharray"},rx: {type: "range",min: 0,max: 30,defaultValue: 1,unit: "px",label: "X-axis radius"},ry: {type: "range",min: 0,max: 30,defaultValue: 1,unit: "px",label: "Y-axis radius"},"xlink:href": {type: "text",label: "Image URL"}};
function inp(defs) {
    var ret = {};
    _.each(defs, function(def, attr) {
        ret[attr] = _.extend({}, InputDefs[attr], def)
    });
    return ret
}
var InspectorDefs = {link: {inputs: {attrs: {".connection": {"stroke-width": {type: "range",min: 0,max: 50,defaultValue: 1,unit: "px",group: "connection",label: "stroke width",index: 1},stroke: {type: "color",group: "connection",label: "stroke color",index: 2},"stroke-dasharray": {type: "select",options: ["0", "1", "5,5", "5,10", "10,5", "5,1", "15,10,5,10,15"],group: "connection",label: "stroke dasharray",index: 3}},".marker-source": {transform: {type: "range",min: 1,max: 15,unit: "x scale",defaultValue: "scale(1)",valueRegExp: "(scale\\()(.*)(\\))",group: "marker-source",label: "source arrowhead size",index: 1},fill: {type: "color",group: "marker-source",label: "soure arrowhead color",index: 2}},".marker-target": {transform: {type: "range",min: 1,max: 15,unit: "x scale",defaultValue: "scale(1)",valueRegExp: "(scale\\()(.*)(\\))",group: "marker-target",label: "target arrowhead size",index: 1},fill: {type: "color",group: "marker-target",label: "target arrowhead color",index: 2}}},smooth: {type: "toggle",group: "connection",index: 4},manhattan: {type: "toggle",group: "connection",index: 5},labels: {type: "list",group: "labels",attrs: {label: {"data-tooltip": "Set (possibly multiple) labels for the link"}},item: {type: "object",properties: {position: {type: "range",min: .1,max: .9,step: .1,defaultValue: .5,label: "position",index: 2,attrs: {label: {"data-tooltip": "Position the label relative to the source of the link"}}},attrs: {text: {text: {type: "text",label: "text",defaultValue: "label",index: 1,attrs: {label: {"data-tooltip": "Set text of the label"}}}}}}}}},groups: {labels: {label: "Labels",index: 1},connection: {label: "Connection",index: 2},"marker-source": {label: "Source marker",index: 3},"marker-target": {label: "Target marker",index: 4}}},"basic.Rect": {inputs: _.extend({attrs: {text: inp({text: {group: "text",index: 1},"font-size": {group: "text",index: 2},"font-family": {group: "text",index: 3},"font-weight": {group: "text",index: 4},fill: {group: "text",index: 5},stroke: {group: "text",index: 6},"stroke-width": {group: "text",index: 7},"ref-x": {group: "text",index: 8},"ref-y": {group: "text",index: 9}}),rect: inp({fill: {group: "presentation",index: 1},"stroke-width": {group: "presentation",index: 2,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "presentation",index: 3},rx: {group: "presentation",index: 4},ry: {group: "presentation",index: 5}})}}, CommonInspectorInputs),groups: CommonInspectorGroups},"basic.Circle": {inputs: _.extend({attrs: {text: inp({text: {group: "text",index: 1},"font-size": {group: "text",index: 2},"font-family": {group: "text",index: 3},"font-weight": {group: "text",index: 4},fill: {group: "text",index: 5},stroke: {group: "text",index: 6},"stroke-width": {group: "text",index: 7},"ref-x": {group: "text",index: 8},"ref-y": {group: "text",index: 9}}),circle: inp({fill: {group: "presentation",index: 1},"stroke-width": {group: "presentation",index: 2,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {type: "select",options: ["0", "1", "5,5", "5,10", "10,5", "5,1", "15,10,5,10,15"],group: "presentation",index: 3}})}}, CommonInspectorInputs),groups: CommonInspectorGroups},"basic.Image": {inputs: _.extend({attrs: {text: inp({text: {group: "text",index: 1},"font-size": {group: "text",index: 2},"font-family": {group: "text",index: 3},"font-weight": {group: "text",index: 4},fill: {group: "text",index: 5},stroke: {group: "text",index: 6},"stroke-width": {group: "text",index: 7},"ref-x": {group: "text",index: 8},"ref-dy": {group: "text",index: 9}}),image: inp({"xlink:href": {group: "presentation",index: 1}})}}, CommonInspectorInputs),groups: CommonInspectorGroups},"devs.Atomic": {inputs: _.extend({attrs: {".label": inp({text: {group: "text",index: 1},"font-size": {group: "text",index: 2},"font-family": {group: "text",index: 3},"font-weight": {group: "text",index: 4},fill: {group: "text",index: 5},stroke: {group: "text",index: 6},"stroke-width": {group: "text",index: 7},"ref-x": {group: "text",index: 8},"ref-y": {group: "text",index: 9,min: 0,max: 30,step: 1}}),rect: inp({fill: {group: "presentation",index: 1},"stroke-width": {min: 0,max: 30,defaultValue: 1,unit: "px",group: "presentation",index: 2},"stroke-dasharray": {group: "presentation",index: 3},rx: {group: "presentation",index: 4},ry: {group: "presentation",index: 5}}),".inPorts circle": inp({fill: {group: "presentation",index: 6,label: "Input ports fill color"}}),".outPorts circle": inp({fill: {group: "presentation",index: 7,label: "Output ports fill color"}})},inPorts: {type: "list",item: {type: "text"},group: "data",index: -2},outPorts: {type: "list",item: {type: "text"},group: "data",index: -1}}, CommonInspectorInputs),groups: CommonInspectorGroups},"fsa.StartState": {inputs: _.extend({attrs: {circle: inp({fill: {group: "presentation",index: 1}})}}, CommonInspectorInputs),groups: CommonInspectorGroups},"fsa.EndState": {inputs: _.extend({attrs: {".outer": inp({fill: {group: "presentation",index: 1,label: "Outer circle fill color"},"stroke-dasharray": {group: "presentation",index: 2,label: "Outer circle stroke dasharray"}}),".inner": inp({fill: {group: "presentation",index: 3,label: "Inner circle fill color"}})}}, CommonInspectorInputs),groups: CommonInspectorGroups},"fsa.State": {inputs: _.extend({attrs: {text: inp({text: {group: "text",index: 1},"font-size": {group: "text",index: 2},"font-family": {group: "text",index: 3},"font-weight": {group: "text",index: 4},fill: {group: "text",index: 5},stroke: {group: "text",index: 6},"stroke-width": {group: "text",index: 7},"ref-x": {group: "text",index: 8},"ref-y": {group: "text",index: 9}}),circle: inp({fill: {group: "presentation",index: 1},"stroke-width": {group: "presentation",index: 2,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {type: "select",options: ["0", "1", "5,5", "5,10", "10,5", "5,1", "15,10,5,10,15"],group: "presentation",index: 3}})}}, CommonInspectorInputs),groups: CommonInspectorGroups},"pn.Place": {inputs: _.extend({attrs: {".label": inp({text: {group: "text",index: 1},"font-size": {group: "text",index: 2},"font-family": {group: "text",index: 3},"font-weight": {group: "text",index: 4},fill: {group: "text",index: 5},stroke: {group: "text",index: 6},"stroke-width": {group: "text",index: 7},"ref-x": {group: "text",index: 8},"ref-y": {group: "text",index: 9,min: -50,max: 0,step: 1}}),".root": inp({fill: {group: "presentation",index: 1},"stroke-width": {group: "presentation",index: 2,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {type: "select",options: ["0", "1", "5,5", "5,10", "10,5", "5,1", "15,10,5,10,15"],group: "presentation",index: 3}})},tokens: {type: "number",min: 1,max: 500,group: "data",index: 1}}, CommonInspectorInputs),groups: CommonInspectorGroups},"pn.Transition": {inputs: _.extend({attrs: {".label": inp({text: {group: "text",index: 1},"font-size": {group: "text",index: 2},"font-family": {group: "text",index: 3},"font-weight": {group: "text",index: 4},fill: {group: "text",index: 5},stroke: {group: "text",index: 6},"stroke-width": {group: "text",index: 7},"ref-x": {group: "text",index: 8},"ref-y": {group: "text",index: 9,min: -50,max: 0,step: 1}}),rect: inp({fill: {group: "presentation",index: 1},"stroke-width": {group: "presentation",index: 2,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "presentation",index: 3},rx: {group: "presentation",index: 4},ry: {group: "presentation",index: 5}})}}, CommonInspectorInputs),groups: CommonInspectorGroups},"erd.Entity": {inputs: _.extend({attrs: {text: inp({text: {group: "text",index: 1},"font-size": {group: "text",index: 2},"font-family": {group: "text",index: 3},"font-weight": {group: "text",index: 4},fill: {group: "text",index: 5},stroke: {group: "text",index: 6},"stroke-width": {group: "text",index: 7},"ref-x": {group: "text",index: 8},"ref-y": {group: "text",index: 9}}),".outer": inp({fill: {group: "presentation",index: 1},stroke: {group: "presentation",index: 2},"stroke-width": {group: "presentation",index: 3,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "presentation",index: 4}})}}, CommonInspectorInputs),groups: CommonInspectorGroups},"erd.WeakEntity": {inputs: _.extend({attrs: {text: inp({text: {group: "text",index: 1},"font-size": {group: "text",index: 2},"font-family": {group: "text",index: 3},"font-weight": {group: "text",index: 4},fill: {group: "text",index: 5},stroke: {group: "text",index: 6},"stroke-width": {group: "text",index: 7},"ref-x": {group: "text",index: 8},"ref-y": {group: "text",index: 9}}),".outer": inp({fill: {group: "outer",index: 1},stroke: {group: "outer",index: 2},"stroke-width": {group: "outer",index: 3,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "outer",index: 4}}),".inner": inp({fill: {group: "inner",index: 1},stroke: {group: "inner",index: 2},"stroke-width": {group: "inner",index: 3,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "inner",index: 4}})}}, CommonInspectorInputs),groups: {text: {label: "Text",index: 1},outer: {label: "Outer polygon",index: 2},inner: {label: "Inner polygon",index: 3},geometry: {label: "Geometry",index: 4},data: {label: "Data",index: 5}}},"erd.Relationship": {inputs: _.extend({attrs: {text: inp({text: {group: "text",index: 1},"font-size": {group: "text",index: 2},"font-family": {group: "text",index: 3},"font-weight": {group: "text",index: 4},fill: {group: "text",index: 5},stroke: {group: "text",index: 6},"stroke-width": {group: "text",index: 7},"ref-x": {group: "text",index: 8},"ref-y": {group: "text",index: 9}}),".outer": inp({fill: {group: "outer",index: 1},stroke: {group: "outer",index: 2},"stroke-width": {group: "outer",index: 3,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "outer",index: 4}}),".inner": inp({fill: {group: "inner",index: 1},stroke: {group: "inner",index: 2},"stroke-width": {group: "inner",index: 3,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "inner",index: 4}})}}, CommonInspectorInputs),groups: {text: {label: "Text",index: 1},outer: {label: "Outer polygon",index: 2},inner: {label: "Inner polygon",index: 3},geometry: {label: "Geometry",index: 4},data: {label: "Data",index: 5}}},"erd.IdentifyingRelationship": {inputs: _.extend({attrs: {text: inp({text: {group: "text",index: 1},"font-size": {group: "text",index: 2},"font-family": {group: "text",index: 3},"font-weight": {group: "text",index: 4},fill: {group: "text",index: 5},stroke: {group: "text",index: 6},"stroke-width": {group: "text",index: 7},"ref-x": {group: "text",index: 8},"ref-y": {group: "text",index: 9}}),".outer": inp({fill: {group: "outer",index: 1},stroke: {group: "outer",index: 2},"stroke-width": {group: "outer",index: 3,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "outer",index: 4}}),".inner": inp({fill: {group: "inner",index: 1},stroke: {group: "inner",index: 2},"stroke-width": {group: "inner",index: 3,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "inner",index: 4}})}}, CommonInspectorInputs),groups: {text: {label: "Text",index: 1},outer: {label: "Outer polygon",index: 2},inner: {label: "Inner polygon",index: 3},geometry: {label: "Geometry",index: 4},data: {label: "Data",index: 5}}},"erd.Key": {inputs: _.extend({attrs: {text: inp({text: {group: "text",index: 1},"font-size": {group: "text",index: 2},"font-family": {group: "text",index: 3},"font-weight": {group: "text",index: 4},fill: {group: "text",index: 5},stroke: {group: "text",index: 6},"stroke-width": {group: "text",index: 7},"ref-x": {group: "text",index: 8},"ref-y": {group: "text",index: 9}}),".outer": inp({fill: {group: "presentation",index: 1},stroke: {group: "presentation",index: 2},"stroke-width": {group: "presentation",index: 3,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "presentation",index: 4}})}}, CommonInspectorInputs),groups: CommonInspectorGroups},"erd.Normal": {inputs: _.extend({attrs: {text: inp({text: {group: "text",index: 1},"font-size": {group: "text",index: 2},"font-family": {group: "text",index: 3},"font-weight": {group: "text",index: 4},fill: {group: "text",index: 5},stroke: {group: "text",index: 6},"stroke-width": {group: "text",index: 7},"ref-x": {group: "text",index: 8},"ref-y": {group: "text",index: 9}}),".outer": inp({fill: {group: "presentation",index: 1},stroke: {group: "presentation",index: 2},"stroke-width": {group: "presentation",index: 3,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "presentation",index: 4}})}}, CommonInspectorInputs),groups: CommonInspectorGroups},"erd.Multivalued": {inputs: _.extend({attrs: {text: inp({text: {group: "text",index: 1},"font-size": {group: "text",index: 2},"font-family": {group: "text",index: 3},"font-weight": {group: "text",index: 4},fill: {group: "text",index: 5},stroke: {group: "text",index: 6},"stroke-width": {group: "text",index: 7},"ref-x": {group: "text",index: 8},"ref-y": {group: "text",index: 9}}),".outer": inp({fill: {group: "outer",index: 1},stroke: {group: "outer",index: 2},"stroke-width": {group: "outer",index: 3,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "outer",index: 4}}),".inner": inp({fill: {group: "inner",index: 1},stroke: {group: "inner",index: 2},"stroke-width": {group: "inner",index: 3,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "inner",index: 4}})}}, CommonInspectorInputs),groups: {text: {label: "Text",index: 1},outer: {label: "Outer ellipse",index: 2},inner: {label: "Inner ellipse",index: 3},geometry: {label: "Geometry",index: 4},data: {label: "Data",index: 5}}},"erd.Derived": {inputs: _.extend({attrs: {text: inp({text: {group: "text",index: 1},"font-size": {group: "text",index: 2},"font-family": {group: "text",index: 3},"font-weight": {group: "text",index: 4},fill: {group: "text",index: 5},stroke: {group: "text",index: 6},"stroke-width": {group: "text",index: 7},"ref-x": {group: "text",index: 8},"ref-y": {group: "text",index: 9}}),".outer": inp({fill: {group: "presentation",index: 1},stroke: {group: "presentation",index: 2},"stroke-width": {group: "presentation",index: 3,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "presentation",index: 4}})}}, CommonInspectorInputs),groups: CommonInspectorGroups},"erd.ISA": {inputs: _.extend({attrs: {text: inp({text: {group: "text",index: 1},"font-size": {group: "text",index: 2},"font-family": {group: "text",index: 3},"font-weight": {group: "text",index: 4},fill: {group: "text",index: 5},stroke: {group: "text",index: 6},"stroke-width": {group: "text",index: 7},"ref-x": {group: "text",index: 8},"ref-y": {group: "text",index: 9}}),polygon: inp({fill: {group: "presentation",index: 1},stroke: {group: "presentation",index: 2},"stroke-width": {group: "presentation",index: 3,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "presentation",index: 4}})}}, CommonInspectorInputs),groups: CommonInspectorGroups},"uml.Class": {inputs: _.extend({attrs: {".uml-class-name-text": inp({"font-size": {group: "name",index: 2},"font-family": {group: "name",index: 3}}),".uml-class-attrs-text": inp({"font-size": {group: "attributes",index: 2},"font-family": {group: "attributes",index: 3}}),".uml-class-methods-text": inp({"font-size": {group: "methods",index: 2},"font-family": {group: "methods",index: 3}}),".uml-class-name-rect": inp({fill: {group: "name",index: 4},"stroke-width": {group: "name",index: 5,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "name",index: 6},rx: {group: "name",index: 7},ry: {group: "name",index: 8}}),".uml-class-attrs-rect": inp({fill: {group: "attributes",index: 4},"stroke-width": {group: "attributes",index: 5,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "attributes",index: 6},rx: {group: "attributes",index: 7},ry: {group: "attributes",index: 8}}),".uml-class-methods-rect": inp({fill: {group: "methods",index: 4},"stroke-width": {group: "methods",index: 5,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "methods",index: 6},rx: {group: "methods",index: 7},ry: {group: "methods",index: 8}})},name: {type: "text",group: "name",index: 1,label: "Class name"},attributes: {type: "list",item: {type: "text"},group: "attributes",index: 1,label: "Attributes"},methods: {type: "list",item: {type: "text"},group: "methods",index: 1,label: "Methods"}}, CommonInspectorInputs),groups: {name: {label: "Class name",index: 1},attributes: {label: "Attributes",index: 2},methods: {label: "Methods",index: 3},geometry: {label: "Geometry",index: 4},data: {label: "Data",index: 5}}},"uml.Interface": {inputs: _.extend({attrs: {".uml-class-name-rect": inp({fill: {group: "name",index: 1},"stroke-width": {group: "name",index: 2,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "name",index: 3},rx: {group: "name",index: 4},ry: {group: "name",index: 5}}),".uml-class-attrs-rect": inp({fill: {group: "attributes",index: 1},"stroke-width": {group: "attributes",index: 2,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "attributes",index: 3},rx: {group: "attributes",index: 4},ry: {group: "attributes",index: 5}}),".uml-class-methods-rect": inp({fill: {group: "methods",index: 1},"stroke-width": {group: "methods",index: 2,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "methods",index: 3},rx: {group: "methods",index: 4},ry: {group: "methods",index: 5}})},name: {type: "text",group: "name",index: 0,label: "Interface name"},attributes: {type: "list",item: {type: "text"},group: "attributes",index: 0,label: "Attributes"},methods: {type: "list",item: {type: "text"},group: "methods",index: 0,label: "Methods"}}, CommonInspectorInputs),groups: {name: {label: "Interface name",index: 1},attributes: {label: "Attributes",index: 2},methods: {label: "Methods",index: 3},geometry: {label: "Geometry",index: 4},data: {label: "Data",index: 5}}},"uml.Abstract": {inputs: _.extend({attrs: {".uml-class-name-rect": inp({fill: {group: "name",index: 1},"stroke-width": {group: "name",index: 2,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "name",index: 3},rx: {group: "name",index: 4},ry: {group: "name",index: 5}}),".uml-class-attrs-rect": inp({fill: {group: "attributes",index: 1},"stroke-width": {group: "attributes",index: 2,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "attributes",index: 3},rx: {group: "attributes",index: 4},ry: {group: "attributes",index: 5}}),".uml-class-methods-rect": inp({fill: {group: "methods",index: 1},"stroke-width": {group: "methods",index: 2,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "methods",index: 3},rx: {group: "methods",index: 4},ry: {group: "methods",index: 5}})},name: {type: "text",group: "name",index: 0,label: "Abstract class name"},attributes: {type: "list",item: {type: "text"},group: "attributes",index: 0,label: "Attributes"},methods: {type: "list",item: {type: "text"},group: "methods",index: 0,label: "Methods"}}, CommonInspectorInputs),groups: {name: {label: "Abstract class name",index: 1},attributes: {label: "Attributes",index: 2},methods: {label: "Methods",index: 3},geometry: {label: "Geometry",index: 4},data: {label: "Data",index: 5}}},"uml.State": {inputs: _.extend({name: {group: "text",index: 1,type: "text"},events: {group: "events",index: 1,type: "list",item: {type: "text"}},attrs: {".uml-state-name": inp({"font-size": {group: "text",index: 2},"font-family": {group: "text",index: 3},"font-weight": {group: "text",index: 4},fill: {group: "text",index: 5},stroke: {group: "text",index: 6},"stroke-width": {group: "text",index: 7},"ref-x": {group: "text",index: 8},"ref-y": {group: "text",index: 9,min: -20,max: 20,step: 1}}),".uml-state-body": inp({fill: {group: "presentation",index: 1},stroke: {group: "presentation",index: 2},"stroke-width": {group: "presentation",index: 4,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "presentation",index: 5},rx: {group: "presentation",index: 6},ry: {group: "presentation",index: 7}}),".uml-state-separator": inp({stroke: {group: "presentation",index: 3,label: "Horizontal rule stroke color"}}),".uml-state-events": inp({"font-size": {group: "events",index: 2},"font-family": {group: "events",index: 3},"font-weight": {group: "events",index: 4},fill: {group: "events",index: 5},stroke: {group: "events",index: 6},"stroke-width": {group: "events",index: 7},"ref-x": {group: "events",index: 8,min: -20,max: 20,step: 1},"ref-y": {group: "events",index: 9,min: -20,max: 20,step: 1}})}}, CommonInspectorInputs),groups: {text: {label: "State name text",index: 1},events: {label: "State events text",index: 2},presentation: {label: "Presentation",index: 3},geometry: {label: "Geometry",index: 4},data: {label: "Data",index: 5}}},"org.Member": {inputs: _.extend({attrs: {".rank": inp({text: {group: "rank",index: 1},"font-size": {group: "rank",index: 2},"font-family": {group: "rank",index: 3},"font-weight": {group: "rank",index: 4},fill: {group: "rank",index: 5},stroke: {group: "rank",index: 6},"stroke-width": {group: "rank",index: 7},"ref-x": {group: "rank",index: 8},"ref-y": {group: "rank",index: 9}}),".name": inp({text: {group: "name",index: 1},"font-size": {group: "name",index: 2},"font-family": {group: "name",index: 3},"font-weight": {group: "name",index: 4},fill: {group: "name",index: 5},stroke: {group: "name",index: 6},"stroke-width": {group: "name",index: 7},"ref-x": {group: "name",index: 8},"ref-y": {group: "name",index: 9}}),".card": inp({fill: {group: "presentation",index: 1},"stroke-width": {group: "presentation",index: 2,min: 0,max: 30,defaultValue: 1},"stroke-dasharray": {group: "presentation",index: 3},rx: {group: "presentation",index: 4},ry: {group: "presentation",index: 5}}),image: inp({"xlink:href": {group: "photo",index: 1}})}}, CommonInspectorInputs),groups: {rank: {label: "Rank",index: 1},name: {label: "Name",index: 2},photo: {label: "Photo",index: 3},presentation: {label: "Presentation",index: 4},geometry: {label: "Geometry",index: 5},data: {label: "Data",index: 6}}}};
var Stencil = {};
Stencil.groups = {basic: {index: 1,label: "Basic shapes"},fsa: {index: 2,label: "State machine"},pn: {index: 3,label: "Petri nets"},erd: {index: 4,label: "Entity-relationship"},uml: {index: 5,label: "UML"},org: {index: 6,label: "ORG"}};
Stencil.shapes = {basic: [new joint.shapes.basic.Rect({size: {width: 5,height: 3},attrs: {rect: {rx: 2,ry: 2,width: 50,height: 30,fill: "#27AE60"},text: {text: "rect",fill: "#ffffff","font-size": 10,stroke: "#000000","stroke-width": 0}}}), new joint.shapes.basic.Circle({size: {width: 5,height: 3},attrs: {circle: {width: 50,height: 30,fill: "#E74C3C"},text: {text: "ellipse",fill: "#ffffff","font-size": 10,stroke: "#000000","stroke-width": 0}}}), new joint.shapes.devs.Atomic({size: {width: 4,height: 3},inPorts: ["in1", "in2"],outPorts: ["out"],attrs: {rect: {fill: "#8e44ad",rx: 2,ry: 2},".label": {text: "model",fill: "#ffffff","font-size": 10,stroke: "#000000","stroke-width": 0},".inPorts circle": {fill: "#f1c40f",opacity: .9},".outPorts circle": {fill: "#f1c40f",opacity: .9},".inPorts text, .outPorts text": {"font-size": 9}}}), new joint.shapes.basic.Image({attrs: {image: {width: 50,height: 50,"xlink:href": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABmJLR0QA/wD/AP+gvaeTAAAIj0lEQVRogd2Za2wcVxXHf3f2vXayttd52o3yJK9GcpMUNQQIfQVKW6mK1ApVqgQigEBCQghVQUKtKiHBR6j4wEMIofKppRRVgAKl0FJISmijJqTNw2netuvY8Xu9692Ze/gwrzuzu46dIIdypNHM3Lnn3P//PO69MwMfclEN7pNAGrAWHs6sooEqYAPiN5oEksDinu/2fr/rtuX7crn04jp6noLZrGJ9/Pu4qj+iSKxdon1ij4MH5XJ1ou9y/2/e+c7GA8A44JjjWEBx49OnflX8yMa94zNgKfdQHihLuZ0s5d4rwj5N2zzjWlxgWsJrkfC+rs3XiekVMjB85vTBM89segIYAXTSGyMDLG3tXnPvaMUdvJlII++K16YMIEY/v00MI/FI+P3isnOZ2+4IHBmA1u419wNLgRJQ9vM8CyyTVDrRlgV75BKFDNRGLkdAmgNIo0NC8FrcQR3Dq2J4NX5E7BoND6xxj4fWeg3pdAJY7mHGj0ACyKE878S9ImFu+wCUMkh516Z+wxowUsUkTOzaHMckaDzOeZgDAgCq6kAmYRoMVeoMeSi1uLWhFSipL/KIvgkqlvvNIhKXquNi9e8jBGwd8xT1njW97TWjDeDKI2KOYhKXGOiG7Y36eIBsaUxAAaqmY56WkJCKedsyCzWWOs3mADO/46D9GtFmSjXQt3WI1yQAYDlCfaF5qIxAgIQpY/mNRo3MRiC4ljB6DSNikjXOjnsdLLKRCNQpe57xvW33HaPy9gtgT2MphQoOUB5spUDFV7cAtBgRkLDOUjky2x8jtXJbSMqIiokrjjdSA4FnRKLF5qXM+O+eQSrjWFYyAKrci3AF9i5ULA7iDe9PDOIZFxFEO8wMnKZ9//N1KeWDN880qAEA5SsEHjBqQCuQWhnSrYgyll6lXLCxPYQYZMzZzCwwNwpuJHRlqg58XT1KQKohgcB+GMYw5ABaJVFaQAlipo8Sr9AVSlTMWigdbYtpLS5jbLCPscmpMNoiYCWj9RCfgTxrqdgWMxoBw/tmJPzq1Vq7IFFuZ4MI+EGQug0ewIo1m+l64JtMZzopTl/h3IvfY3jwipdGboqZEfeJHDwzjYPCEkFLnvZkuWEEFGBFpjV/liBcoLSWwONxIoCbWr7BGIvEls/yvt0JNoh0k9v6GWTgZ0YaCeb4fia8MZgPptYVLVC9dBrcWWiWIiZMo2CRUtECNImE6RMaEyMSInBtdJz0Sv8ZDI+Oo0WHwP2JI14DAosy0JV3GDp7jLMnjjWMQGDY9b5ECtmf67UIystMJWENuB73JuiEhQSrUWh74vBzFIrrUIUu7Ku9TB19AdGG940UMteItQWQyX6O/elVSmMjTGd6IpGtjwDGXtzzuB8FvwbAn4QkKFp/St2060Gmhy9x4dTx6OwzNcLQc/tJ5DtxpoZQ6TxYych60GhR63v7j3xw7gTbN3Tzt8GVOLllDSOgiL1CxlMI5deABIBzuSwIzFSrKIQ123Yx2fMF8lRZl/4hve8cCkmoBCRz2OVxVLoFraxwHfAObQD3SaSn+/nR/k+yc12Rzd86DckcNKmBundgn4S/7GnRgcdTyQSbH/46qZZF9L78LKmWAuk932DIzjBOhs5PPcnG3I85/eZBbNsJh0ik0SLg5X8A1qgB8/zLL+2kvbCIRDoPKoBYt5WYVYLa8CKglGLDnkcYWHkftijWfW45VcfhilMIdK7OpGm786tsTqZ59/XfYjsOXas3UJspMdjf7wH3CGBEQCKlQzppNd2azJlAQMSbMdbd8XHKPV+kbLuGz6rVqGQ4O/kyWkth3/EVbm8pcu3k3+l4+CkSSpF/5Qec//chtNae3bAG5it1m7m5iNPzOBO1VKQtUI6RGK8qausfpX39Xi7W3Agtv//bbCv+ghOvvUS1Zs8ftYHXMhrm/B1ovFYfODEO82uDFpiqweVaIXg+UM0xuv1rfPSJpygUCnW25iBBEZug5xyB/4ZMVeF8xydY+8iBG1EPsN4yAuC+315wOm9EtfludC4i1TK6MnEjqg1t3YzMug7ExbIstNZMvHRDYb+u7fl09y/MWei6smrLDi6++xa6PBrdJtyEKKVQqSyrtu6kNE9VaLAXmk0Knz7AvXcdA+1cr+v8xEpwta2H0tzNNv6scj2tft1B/6K7541vTjI/n9StAx9aabobXXAgSti3aoyVqUl6y238oW/xbJ8Y57YbXUh5dOlFDv78Wc6fPM6du/dwz31f5tWRZc26129Lb7Ukrp6k9+R7SOE2jvzzCCtmeuekFyGggIoNVr4tOC+UXEss4fa77oFqid137+VMpRh+qIKm03ZkJU7UJimzCCvXRtkGK7dwBF5xdvDgQ118/vHH+NdInr9cW0qiFq72g9cmwErV6fkELCBZvXKc4ubdON5bWMqC5IIlmeIfEyt4bczdsbZlYaTvLLWaxeTkJM+/MQTZdhO3ZRIAoHruTZzCYlral9CSVuSV0JJQ0X9msbejyDfQRm9OkZ8k0vyZwJQjTGvFdFWYGhmEscu8fEhx4gPNi6c6oKWNJDXMN4gIAasyLQOHf62yy9dTtQXtvyIpD2YAUBk/BuLAm3xaDMAan9+8dvHOSimsZJpMNkttpkzFzvH0n/OQLUJrB6DI1gbtqQYEHGC6VM6MFlurHZXev6K0kGBhRSUzqHw7dr4dWrvQdJNvb4VUjoRlkVdTjJ9/fRT3D6VtEigBV8pHf/r7iV1P7sut2Npiz5SoVmuGQ5t4nwbPoT6dzAhEzoT3AigLqSRxKgp4HxRkMxlymQyl4QulytGfHAT6gGlz1CSwGtiBlfpYcsmWTZJoyTo3vWmzPJT6pl6WElYC5ZQq9tB7J9G1w8BbwEXANg2ngZVAN9Dp3f8vSRUYBi4DA959XR5YuP9gsw2e3WoRoAKUcb///n/IfwCA/cfu6DUO7AAAAABJRU5ErkJggg=="},text: {text: "image","font-size": 9,display: "",stroke: "#000000","stroke-width": 0}}})],fsa: [new joint.shapes.fsa.StartState, new joint.shapes.fsa.EndState, new joint.shapes.fsa.State({attrs: {text: {text: "state"}}})],pn: [new joint.shapes.pn.Place({tokens: 3}), new joint.shapes.pn.Transition({attrs: {".label": {text: "transition"}}})],erd: [new joint.shapes.erd.Entity({attrs: {text: {text: "Entity"}}}), new joint.shapes.erd.WeakEntity({attrs: {text: {text: "Weak entity","font-size": 10}}}), new joint.shapes.erd.IdentifyingRelationship({attrs: {text: {text: "Relation","font-size": 8}}}), new joint.shapes.erd.Relationship({attrs: {text: {text: "Relation"}}}), new joint.shapes.erd.ISA({attrs: {text: {text: "ISA"}}}), new joint.shapes.erd.Key({attrs: {text: {text: "Key"}}}), new joint.shapes.erd.Normal({attrs: {text: {text: "Normal"}}}), new joint.shapes.erd.Multivalued({attrs: {text: {text: "MultiValued","font-size": 10}}}), new joint.shapes.erd.Derived({attrs: {text: {text: "Derived"}}})],uml: [new joint.shapes.uml.Class({name: "Class",attributes: ["+attr1"],methods: ["-setAttr1()"],attrs: {".uml-class-name-text": {"font-size": 9},".uml-class-attrs-text": {"font-size": 9},".uml-class-methods-text": {"font-size": 9}}}), new joint.shapes.uml.Interface({name: "Interface",attributes: ["+attr1"],methods: ["-setAttr1()"],attrs: {".uml-class-name-text": {"font-size": 9},".uml-class-attrs-text": {"font-size": 9},".uml-class-methods-text": {"font-size": 9}}}), new joint.shapes.uml.Abstract({name: "Abstract",attributes: ["+attr1"],methods: ["-setAttr1()"],attrs: {".uml-class-name-text": {"font-size": 9},".uml-class-attrs-text": {"font-size": 9},".uml-class-methods-text": {"font-size": 9}}}), new joint.shapes.uml.State({name: "State",events: ["entry/", "create()"],attrs: {".uml-state-name": {"font-size": 10},".uml-state-events": {"font-size": 10}}})],org: [new joint.shapes.org.Member({attrs: {".rank": {text: "Rank"},".name": {text: "Name"},image: {"xlink:href": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAM8AAADBCAIAAADn6XN4AAAACXBIWXMAAAsTAAALEwEAmpwYAAAjPUlEQVR42u2dd3Rbx53vZ25BJQoL2HsRKaqREiWK6pZkSzIt+cmULHtXlhMr2T2J8zbOJntc1om98dk4G6fYfrJjZyMXuVuWrKhaVrF6oyhSVDE7KZJgBQsAAgRwy7w/AF6ARSwggHtB3c+ZwzP3EhjMDL743am/gQghIDIYR39fa3VZR8Pt9robVqPBbjHZrWa71eSMkFK5VKmWKtVShUqqUMvVYbrELF3SdF3ydG1kIoCQ7+wLFyiqzUnnne9rir9tun25tbrU0tPhXSIYTiTNXhoWm5q1eEPizAKI4XwXS1jc02qjHfY75Wdqio9VXT5iNrT4NnGJPCRt3qr0BWvS8lYr1OF8l1UQ3KNqM7Y3lhx+v/zYJ1ZTl78/CyckWYvXzyvcHp+dz3e5eeYeUxtCdaXflRzcWXP1GGKZIf8MjUkhpXJCIvMMGI7bLWa71dV0s/UZbX293n14VOqseYXbZ6zYRErlfFcEP9xDaqu9euzEey8ZGis9b5IyhTYqKTQ6WROdNE4RsDTVpa/paa0fktQ4kavCFj/2y7zC7RhB8l0lgeaeUFt7bfmJ915quH7Go9wwPC49JiNHFRELgJe9SIfV3HjjfGdjhRfvDY1JWbHtxelLHr6n+rBTXG3mrtZTH75y47svwUAxIcQiEqfFTpsnV4f55CMMjZX1pd8xNOXFe3WJWYXP/L/YaXP5rqcAMZXVdvPU7m//+qzNYnQVFcN1SVmx0+ZJ5SG+/SCTQV9x4QBiWS/eCyGWv/Gny594ASelfFeY35maaus39xx9+z9un/2au6PU6lLnrpSrQv30ie11N+7cOO/12yOTszf86p3I5BkBrqgAMwXVVl966uDrPzN3tbpKiOGx03Kj03OgP1tIiGVvnPzC0d/ndQoYKV2x9fn8R56GEAtwjQWMqaa2Ux++cmH369ylQhOePGe5XO0vk+ZJa3VZS2XJJBNJyb1v03/uImWKAGQ48EwdtTG048iOfy8//hl3Jyp1ZmzmPAgCZCqMnc21V49NPp2o1FmP/uZTVURsYLIdSKaI2mx9vXt+9+Sd8nPOSwzDE2cv0UYlBTIPdqvp+7P7fJKUKjzm0d98GpU2O5D5DwBTQW3G9sZdzxZyE50EKU3OXaHU6gKcDZu5p/LiIV+lRkikj770efKcZQEuhV8JerWZOps/evYhY0eT81IiD0nJXSFVqAKfE3NXW33pdz5MECckm17clZZ3f+DL4ieCW2193e0fP/dQd0ud81KhDk+as5TgaeDK0FTVWl3q2zSnmIULYrVZjYZPnn+YmzhSanXJOcuht9NQk6e+7LSl18uFcaNAyhSP//arqbF+JFjVZreYPvzVGkNTlfNSptQkz1nG4zw3Q1NVFw/6qTIlMuW21w5Hpszkq3S+IigHEhHL7P39U5zUSKkiYUYBxHGEWL5CT0ud/363Dpvls99s5sarg5egVNupj37HtcdxQhKfnY+TJGIZvgJDObr01X4tsqWnY++rP2RoB991PymCT20V5w9c/OoNZxxieFxWnkSmQCzLY+hprWcov+tAX1H87bvP8139k4LgOwMTw9BYefD1n3HLh2LS50iVanbYKtxAwlD2bn1NYD6r9MgHsRm5cx7YymN5J0Mw9RJYmvrb04u79bXOS21UYkRiFt+ZAq3VpZbezoB9HMTwp14/EZU6i+9ye0MwPUlPfvBfnNRImTIsLo3HboEzmAwtgZQaAACxzMHX/y/r1eJN3gmaJ6m+4mrx/r854xDCyKTpCAHE8PkMZRnK0OTN1oRJ0l534+JXby5+7Jc8lt07gsO2MZT90Jv/xu2S0kQlSuRKgFgeA8vQrdVlfNmYc1/8ybs9OPwSHLbNs3Il8hCNLp7fngEAoPNOxWTWTk4S589v2x8OB9d2/CCwbYbGygtf/MUZhxCLSMxECPDbYOttb7QaDfxWi77iasnh9/n+ciZGENi2U7teQci1wUQZGonjJOLVsFlNXcb2xrv9F0KYmZ2lVIUolAqVWtVv7e/qNLS3tre3tvk8J+c/f232qsckvt7U4z+ErjZ9xdWqy9844xBiIWFR/D5D+83d3JITTyCEc+blJKUmp6an4vgITzeT0VRafK28tNxus/kqM5Zew5V9f13y+H/wWCETQujjbZ88v4Hby6TURmqiEnjMjK3P2NNSO6TGSJKcmTMrr2C+WqMeMwXKQd28frP0SklPd49PsiRVqH7y95Jg8WojaLXVXTv5+W82uzIKoS45G+dvlYfdah4+9Z42LW3V2lUq9YQXb1bcqjh2+JjD7oP5rvz/89NVP3qFr2qZEIJW23s/v6+tttwZV2jC1RFxfOXEZjEZ2xu55iMAIEQVsnLNfRmZGV6n2Wfu+/bQt/W1DZPMG0aQP3uvLCQsmq/KGT/CVdud8nOfvPCwK5cQhidMw3BeDBvq626zGt2OtyCEOXlzlixfJJFKJp96eenN08fPOByTMnIFm5+578lf81E5E0O4atv76g8qzh9wxmUhGlU4DzveWIY2GfSUzcrdiYzS3f/gqqiYKB9+islo+vLjr0xGs9cpKDQRP3u/nJAI3beDQNVmNrS8tT2XZWjnpVoXF/h+Pm23mQx6Lg8Qwrz83MXLCzDM94OUFEUd2X+spqrW6xTW//vbs1ZuCXAVTRSBjoBc++YDj68ZIySyAI+x2Swma28n91OUK+RrC1enpCUBAIAffp8kQazfuPbc6YvFl655l0LJwb+LavMGhnaUfbOLuySlcoBQwGwwQsBqMtgtJu5OXEJs4Yb7Q1QhAPgxDxCCpSsKQsO0x4+eYpkJu0tqqbrWUnVN4M65hKi2qktHPJfxEFI565WzKi9ADG3p7aQpu/MSQjh/YW7BkvkYhnl2SP3HjFmZak3Iwa+P2mz2ib637OgugatNiPOklQOdAycEKQ3M9gLKZjF1tXBSUyjkGzc/uHjpAgxCgFDAQkJC7GNbHwkN1Uy03qouHeF3Tm9MBNdLYCj7X/5pGre8giClCk2Evz8UAWS3GB39Fu5OfELMg+tXKUN48zVks9kP7DvW3Di2X30I3V/iP7+6P2nWYr7yPCaCe5LWl57yXMmDEYS/J0ZZhrb19Xr2PRcszClYPA86TRpPyKSSok3rLpy7erW4fBSLACHMyc0uvXbLeVl54YCQ1Sa4J+lQxy0I+HXxkKO/z2rs4qSmUMg3blpTsHguAIj3ZegQA4uX5RU9uk6lvuvoz8rVixYuyuUGZaouHubxFzImwrJtLENXD6z4cMLQDoL1y+kCiGUc/X2e3pnjE2LWPbRcqVT4te85UeITop98quj8matlZbcR686YTCYt3LAyITEGAJCQGHOnQQ8AMBn0LdWlgu0rCEttrdWlQw5nYWiKoR2Yr1eo0g477ejnnlAQwgULZy8syIEQgoD0PScEgcPl981fsmxuXW1TfV2zVCpRqZU5udMxDHPmNi090ak2AEDt1eOi2sZF8/dXuDjX+HVY+yRypa+80bIsTdltnn03lUr5YOGymNhIAPwycusrcAzLyEjKyPBwgTiQ25Rk93oFzzoUGsJSm76imIvHxOpa9B0AAIRYh83qg9N6EKIpB8u4H50YBnPnZS8syCEIHAnp6TlRQtSKkBBFX58VANBSVYIQK0xX0cLKE/e7lEolK1ctwHFX9pyDYSxDed3iZiiHw2bxlJouMmzL4+uWLMklcMjv9i2fhJhYly9Ou8XUeceb42kCgIBsm7G9sa+73RmPjokID9PkzZ9x+dIN5x2EEO2wYziOYcT4fbQhBBBLs4O3nRIEnp8/a+48Z7sniE2aJzHREdVVd5xxfUVxZHI23zkaAQGprdnzMRoTDgCbnz8DIfbK5VvcfZZhWIaBEIMYBKM8LBAAiEUIDZ9uio3TrV27SKVyDtsKrkPgNTEx7oOU9BXFuWuf5DtHIyAgtbVVl3HxmOhwgBAEoGDhrIhw7bFjlymK5v6LEIsYAAAzcOAGBNA9aoEAGtFixcbqFi6cmZAQ5UyC7+L6GJ0uFMdxhmEAAK0eNSkoBKS27lb3XqbwcDVnltLT4yIj15SX19y+XW+zDVrjOjCEMVoTH0KQlZWclZXk1FlgJtcDD4aB0FCVwdALAOhprQcICfB0QAGprbfN1ewgSUIhl3qaH7VKsWTx7IKFM2tqmstv1La2jmvncHi4JisraXpWkkIhA2AK2rMhaDRKp9poh62vp12AOxUEozaEettdalOrlSOO5uM4zMxMyMxMYFlkMll6esw9veaeHnNPj9lmc0hIgiBxkiQjwtXR0eGxsRFSKbePYYrrzIlGreTiPW0NotruiqW3k1v+r9EoRh/QxyDQahRajSIFjLo/YIo+NO+GWu1esdLbdicheyHfORqKUNTW09bAxdUqpdDWQQUFg9XWwHd2RkAoauMeo8Bp26bQ2ETA0Kjd0y1cI1hQCEVttj4jF1fIJVO+Re8PFHL3Dj/P+hQOQlEbZXOvmyUJ7F5rcvkEknAPeVB2yyRS8hfCUZt7hzBBBvccOW9AgOMYw7AAAIdHfQoHoajN4Wnb8KkzfRlgSJJgGAcAgOoXbdvdGWTbxCept5AE7vQO57CLtu3ueKqNJLF7ZDzW55Cka5EzJT5JR4HxWHkG4ZSdzfQ3GObqKAjzQAWhqM1zaS5N0UDGm1fAoIaiXCv5iMkvdfYDQlGbROae46MoCgChO4cSJjTtUptErpxcSn5BKGojB6mNEfuk3sHZNs/6FA7CUZt7jo+maFFt3kFxtk3Km0+JURCi2hwULfYSvIBmWG41g2d9CgehqM2z3eZw0OIIiBc4HO7F9GK7bTRU4TFc3NzXL47ueoHZ7B5j86xP4SAUtWmjk7m4yWQT221eYDK7T5nxrE/hIBi1RSWCAQ9Wpj4bEte3TRyTuZ+La6OTJpGSvxCK2giJTBUWbe5qBc7fqGjbJo5o2yaANjrZqTaL1cHQNOeWQWScuNUGoTZKiLZNQN8oZ/wRclYcEsOEQq/J5TFYqdX5wEmPHxCQbdMlZnLxdoNFq5HxnaNgwmKlLFbX1m5dYhbf2RkZAaktLms+F2/rNGemhvKdo2CivdN9cFHc9PmTSMmPCEhtMRm5GEE6l8q0d1rEAd4J0d7pdo0dnyWqbcysSGRRKTNbq0sBAD1Gm8NBSUgfO0CdwrR1DiwNhzA2M4/v7IyMgNQGAIifPt+pNoRAe6c1PiZoTkznF4ZBhm7XYFt4XLpcJdBGiLDUFpc1v3j/35zxlo6++GghTi0LkA6DhRlwNx4n1McoENQICAAgafZSzg9UQ7OJ9zGFYAn1zSaPOlzC99d4V4Rl25RaXVzmPH3FVQBAj9Hea7Rr1T4433jKU9/s6pBiOJE+/wG+s3NXhKU2AEBmQaFTbQCAumZj7vRwvnMkdAw9tj6La89L4sxFgm20AaE9SQEAmYvWc/GG5j7eH1LCD5xhAwBkLnqI7y9wNARn20JjUiKTszsabgMAOrttFqtDKRdcJgVFfbNrpA1CLLOgkO/sjIbgbBsY/AOtqDMF8mzQoAvthv5ek2vCKjZzngD9UXoiRLXNWrmF65lW1BlZlgGAFcOI4Xat23PWjBWb+P7qxkCIDyltdHLKnGX1ZacBAJZ+pl5vSY0X4ip73um3M3VNrikEiTxk1sotfOdoDIRo2wAA8x76MRe/XWPm/YElzFBRZ+YGdWet3CJVqPj+3sZAiLYNAJCx4AFNZIKxowkA0GqwdRvtYRrRV8MgWAS+rxvojUI4t/ApvnM0NgK1bRDD5677AXdZXiX2FYaGuiaLpd+1Vzlp1mLBrmnzRKC2DQAw98Gnzn72B9phBwDUNFlnZ4SEqoWb2wDDsujqbfdsVZ5Hw0PICNS2AQCkSvW8B7c74wiBq7fFaVN3qGiwmi2uvcqRyTOmFTzI99c1LgRtLQoefabs24/sVjMA4E6rraPLHhkmtt4AzaCySvf8wYpt/ynMs2+HI+hcKtTh+Ruf5i6Lb4udUwQQulljtdpc+20VKelpC4Q7DT8EQasNALBg40+V2ghnvNVA1bfY0L2N1cZcr3Z7cH4j9Nrcj+Z+Xf01Aojv72pshK42iUyZ88hPuMsL5X126p6eWjh33UzRLmFVhlMNGrqso+yR/Y/k7srdW71X4JoTtNqslPX3V36/Sf/bLrmrq99vZy/ftPD+LOMr1DbbG9tcs6IMBg5luN3MXO+8XrS/KGdXzp7qPaxQffZAYZ5fRrHUzhs7f3vxt62WVgBAvIn412tqbCCna/JD4nWC7t/4A5sD7TllsjlctQAfUZVm0SdvdnaZHUNemaRO+tOKPxVlFPGd5aEIUW1lHWVbDm6p6qnyvLmuVrGk0bWfWSHDilaEeB60cy/wXYm1vtW1ahImktgLOoADFqHSeuN3tzoMwzS3NnntjlU70rRpfGfcjbDUZqWsvz7/6zeuvcEgxvN+Zqxq7fSoyDdNoMM1yJQcQ6ycK0TnA36ispE6f2PAzQcOsRd0MME9GMQiVNbQe/JWp8Fs93yXnJC/uPDFX+X9SoILYsG9gNR2tvns9m+3V/dUe95MilCsmROdEqkEAIBqB/vHTq4dnJcpmZ0miEr0Nx29zJFL/cxAYwwWquDD6uEvYxG63mA8eatjiOayw7P/uvqvy+KX8V0OYajNQlleOPfCjms7WA+3bXIJvmFebE6S1vOVaJ8JHXENbEIIHpgvjYuY4juc++3oH+dtVtvA15REYs/qAH7XVgSL0PnKruM32x20uzIhgD+Y+YM/LPtDhDyCx7Lwr7ZTTae2H91eZ6zzvDkvJbQwN0Y2fK88C9BbXeCW65kiJeH6xVKVfMo24FgEvrlsb+8Z0I0Ghy/ogGbsH1ivlTpwreV7vcnzplaqfef+d7Zk8rYMjk+1MYh56fxLv7v8O89RIo2C3JgXNy3m7ku1LCx6tRMYXA04jRIWLpRIySkoOATAqTKqoW2gCYtD+IsIkD6BxsNtvenAtRajddApRJumbdq5Zqdaoh5/Or6CN7Xp+/RF+4sut172vDk/NWzdnGjpmO4/minwWicYGAsIV8O180nJlJtBvXiLrmjyGDl7TAuWT3gNs4Nmj99sv1jdxXp80RmhGbvX756jmxPgEvGjtostF4v2FznH0pxoFZKNeXHpUeN2/FHaD/63m7vSaeGaeQQ5hcbgrlQytxo8pDZPDraHeZ1am9G2t7hZ3+N2zCsn5G+ufPNHs34UyELxoLadN3Y+feJpO+PuNy1IC3twdiyBT/BpeNYCP+/lrqJD4f1zMWJK9Bmu1bDX6zy+l1w5eipskvM+LEInbnWcqezw/MK3ZW97e/XbSjJA2z4CqjaKpX7x3S/eKnuLu4NjcH1ubF6Kt7/aE31wr3vTUaQWrMrFpMH8SEUIXKlE3zd6fCkzZehfwsBEf4p3oarN/NWVJqvDPZw5I3zG7g27p4dND0DpAqe2zv7Ozfs3n24+zd1RyYjHFyYlhE/KkRH8xgwPunteKgVYnQM0wblFi2bA6RugqdN9B2VJ0b+GA5/2gYxW6ovLjU3d7jlWGSH7vPDzh9Mf9ncBA6S2m4abq3evbre2c3fiwxSP5yeq5T4wRHB3LzzjXoQjJcF9s1G0cL1hjIzVDk6UwS6zx60UCftvEcAPE3QMi7692XahxsDdgQD+ecWfn5n3jF/LGAi1XWq9tHbPWqPd/cjLTQpdnxtHYD6rR3i6D9tr5MaGIQR56WhGIv8D1+Ok0wi+LcMo9zlVAM2Vs1tDfWvVhnC7xbSvpNlGuZ+qLy588ZXFr/jvE/2utnP6c4V7C00O18MOg3DtrOiFab4f0Ya3bNgH3cDuLk5CBFo0nZEJe3KLRaC8HitvwDy/B/SAii1UA/+PIVod9Htn6ztM7mM9fjLnJztW7cD8s/Tcv2o73Xz6ob0P9VEutyg4Bp8oSE7R+cu/KdRT+N+6QK/7xyqTgEVZTEKEQNd7Ga3w3G3cYPKQFQ7ZLVo2P3BOOfsdzCeXGjybcY9lPfbh2g/9MZHvR7WdaDyxYd8GK+UqhpzEty1KidX6eeGGkcHf74YNg5bfZCcwuSm0oAZHEAK3mvDSOoL1rH4pZH4cjtIDfcq5g2G/uNJY0+FuM65NXvvVhq98PjLiL7UdbTi68R8b+2nXcKJCgj+xKCVGE5A1QizATpjxb8yAcReNJMDMRDo7gSYEsFr5TideUkuY+wc9KdkcObNZC5T85I9h0dfXmm7q3W3rRbGLDm48GCrzZW/LL2o7XH+46B9FNsbVGlBKiW0FKVHqgJ7tApsp/ONu2E573lRIUW4KlRpFQ56mVTtN2NVaSadxsKRkGFOkYfN4dmmNEDh0Q3+1wT1DMyti1qV/uqQgfZYx36vt+J3j6/auo1nX1xwiJbYVpOhUfBwjxCBirxG7ZBmyNUQtZzPj6PQomiQC1GlFCDR1EZV6orV36OOcTZfST4bxZdKGc7Ki/Wx1B3e5Omn1oY2HfNWG87HarrZfXf7Fcq6tppKR2xamRIQEuiEyqITtNH7QiN22DblP4Cg1ks6Mo0KVfuxD2Bywuo2saiEt9qHmFEURzEMaNltwx3ldqjMcve2ewt46feuuB3dBX/SQfam2ZnNz/qf5LX0tzku1jHyyICVMyafUOLAaO37ACJup4f8KVTIJ4XRcGB2hYnz1hO2zYU1dRHM30d47uB8AAAAAqXBmjYrNVwp2y9uZ6o7vKt1D8c8teO7Vpa9OPlmfqc1CWZZ+vrS0o9R5KSXwf1maHqoQ1mAXfsWCHzVDIzPifwkcJYZTESomXMWEhTATGntGAJisWK8F77XiDZ2kqf8uOpJh9CoVsywECKmDPCKHbuhLGt1tuB2rdjyd8/Qk0gPAV2pjEVu0v2hfzT7nJY7BJ/JTEkMFOlsJmxz4eQt+vR/Qo5VdJWe1CkYlZ6QEInFEEkiCI5JANAMpBjpoSDHQTsF+B9ZjwXut+OgVyaZJmcVKdoZcsPZsaIYR+rKksarDNSyPQ3z3+t0bMzZOJk3fqO25s8/9z5X/4S4fnhM/O07w85QORJw0YxU2TE9NPrG7IoHMfAW9SoVUgrdmw6AY9qPL9fregRFTQn588/FFsYu8TtAHavvg1gc//OaH3OXiNN3KaYL2bD20CkwMVmHDv7dh1XZuPfCkwACbKGGzZMx0GYoJ5vVPAFgd9PuX6rotrsWIYbKwa09cS1IneZfaZNV2pvnM/V/d72BcY/dZUZqi3MRg3SOAAHbHgbVQsI3C2iislRqv+HDIRhIommSjCRRLsvESpAiS5+U46LE6PrhUa3G4hrSWxC05teUUDr0x1ZNSW6+9N2NnhqHftXAlRi3ftiCNxKdORcMOGtpYaGOBDUEbC+wstCFEQiDDkMz9l40ObgM2Jt1W+/9eqKYGdrS+VPDSy4te9iId79WGAFq3Z93RhqPOS5WU/GFBuiqoF86K3J3Spu7Dt5udcRzip7acWhI34cMCvbdD71x/h5MahPDR3GSVhOTbQ6gY/BVy48MyIzXOr5tBzNbDW3tsPRPVjJe2rbqnOvejXAvlWjG7alpMfpLOa+GKBAX9FLPzUpXJ5urCb562+cv1X04oBW9sG4OYbUe2cVJLDFUuSBSlNvWRk/iGmYncdMvuqt07b+ycUAre2Lb/vvzfL5570RmXENiP8qdp5MKaMxDxH2dq287Xu6btlaSyZGtJZljmON87YbWVdpQu/HQhN+RROD1+dqz3u2pFgg4WoY9LavVG15BvXlTela1XxjlnPzG12Whb3sd5t7puOS8zItRFs5P5Lr5IoDH2O94rrrbTrunmTws/fTzr8fG8cWLttpcvvsxJTSEh1mbF811wER7QyCX3pbmni5498yy3xmx08Jdffnmcn1FnrHvi8BOc18j12YnRqnvIO6SIJ1Eh8mqD2TnBYHKYSIxckbBizHdNwLY9f/Z5znnHjChtRria90EgMfAVIICr0mM4bbx29bVGU6PP1Hap9dLuyt3OOIlhy1Jj+C6vGHgOCdqQTJ3GKQkrZX327LO+URsC6Jenfsn59MuLjxCnDcQAEFiRGsM5PPii4ovz+vOjC2lcHs/2VO250HLBGVdKiAUJkXy7TxURBGqpJC9ed6mxAwCAAPr5dz+/8s9XRtlnP7ZtczCO588+z10uToySYBjvvyoxCCTkx0eGDLgFLWkv+azis1G0NLba3i57u6a3xhkPV8hmRofxXUAxCCiQOLY02T0a8serf/RebT22nlcuuZ3eLE+OxgDkv4hiEFLIjgwNlbt21pV1lJ1sPHk3OY3RbvtzyZ+7ba6NN4makJRQtdhiExlOXqzuWK1r9dtfSv6yMnHliC8bzbbZaNu71991xiEA96XG8l0oEYGSHamVD/jYPlx/uLK7csSXjaa2Tys+7ex3ueVMCVVHyGW8G20xCDMQEJsT5VqcwSL2jWtvjKio0Wblc3blXO+87owXZacmafzld01kCmCh6L+XfM8gBABQkIrGHzeGy8OHvOautu1U0ylOauFyWZI6hPcfkBiEHJQEkRWhdQrGSlnfLX93uKjuqjZPY5gbE8F3WcQQBCE3xr2E+62yt7hFkGOord5Yf6D2gDMuI/Dp4Vr+iyIGwQedXJaodjW3Wvpa9tfuH6KrkUdAdpTu4FYWzdSF4RATBz5ExkNOdESjyeVmeU/1nk3TNnn+dwS19VF97918zxnHIJwTGQFQsO5+FwkwSWq1FMftDAMAOFR3yEbbZITbQd0IT9JPvv+k197rjKeFakIkEr4ttBiCJmAQpmhdZ1GaHeZjd455SmsEtXHr2AAAOZER/JdADEEV0rUaTj97q/d6Smvok7Srv4s7ikotkcQolWKLTWRCJKpVJIZRLAsA2F+7n2IpEnMtEhlq2/bX7uccNKeFaibyKSIiAABAYFiSxnV0dret+3ST+xy9obbt65qvuXiqRiMaNhEvSNNqa3pcRy/sqd6zOmm1Mz7Itnk26xQEEaNU8t4IEEMwhmSVCh/w4LCvZh+LXK64Btm2I/VHbLTL03uKRgO4nQgiIhOBxPAElarBZAIAtFnaLrdeLogtAENsm2cPIs2jZyEiMlFSNGoufrH1ojPitm022na4/rAzLsXxOGWI2GgT8ZoohdujfHFbsTPiVtvxxuNmh+sUt2S12rUiXETEK8IkUm4cZAS1Hak/wsVT1BpRaSKTAkKdXN5isQAA6nrruvq7wuXh7nbb5dbLrpcBkBCi4r1fI4ZgD5Fy1+F/CKDi9mLA2bZ+ur+8s9wZD5PJCHHRh8ik0cndR00WtxWvTV7rUltpRynFuvypRsoVYotNZPJEygapDXC27UrrFfeL5ApRbCKTRyWRyHDCxtBgqNraPNQmE22biG+IlMsb+8wAgDZLW5O5aajaCAwLk8hEtYn4BJ1M4VQbAOCG4QYBADD0G+p66wb+LQcQimIT8QkqidvZvN6sJwAAxW3F3Iyo+BgV8SFK3H0SVaullQAeI20AAJ1MIY59iPgK+XC1lXWWcbcipaJtE/EZCtw9WdXS10IAADj/vATElKREFJuIr5DiBA6h012Dy7bp+/TO/ykIUjRsIr5FQZBmygGcts3O2DutLkdGSoIUG20ivkWOu9TWbm0n9H16rkOqJEgwvgOLRETGiYJwdRRolib0Zr37H7ho20R8jGdHgWjua+YulIREbLeJ+BY55h4EIZrNbrWJtk3Er2BchxQMHvkVEfEJnuZLtG0i/sXT1a673YZBKMPE8TYRP0J09Xc5YzKMAEAUm4iP8XxaEpyrNgmGi1oT8TmD2m0mh8kZIyEuNtpEfM6gdtug8xLuVbUhAFwmH3nEufto8GuGvBeNI+0JZMOHJfJzlsaXjINluDihlWqdB76YaPvl3mZXLSNXYgOVjgZuDsS5+2jwa1xvH/Ze7tVjpjnsvVx+BikAjFcZyH178H2PNEUCAxEmD3Oqzc7SFX0GvvMjMpXBUjWpfOdB5J4gQZUATzedvv+r+4cf2+FXMIhBACGEQyNg8B047M7wF8NhkcEvHi0FCDEwdgrDXwyhe6UMvPuqGc+XDf2Xr98lnJyM+C6VRPXcguf+P+owdGfsF2paAAAARHpUWHRDb21tZW50AAB42nNNySxJTVFIqlQISCzNUQjOSC3KTcxTSMsvUggPcM7JLEgsKtFRCChNyslMVnDJz03MzAMA0cYSC/gtqgsAAAAASUVORK5CYII="}}})]};
var Rappid = Backbone.Router.extend({routes: {"*path": "home"},initialize: function(options) {
    this.options = options || {}
},home: function() {
    this.initializeEditor()
},initializeEditor: function() {
    this.inspectorClosedGroups = {};
    this.initializePaper();
    this.initializeStencil();
    this.initializeSelection();
    this.initializeHaloAndInspector();
    this.initializeNavigator();
    this.initializeClipboard();
    this.initializeCommandManager();
    this.initializeToolbar();
    if (this.options.channelUrl) {
        this.initializeChannel(this.options.channelUrl)
    }
},initializePaper: function() {
    this.graph = new joint.dia.Graph;
    this.graph.on("add", function(cell, collection, opt) {
        if (opt.stencil) {
            this.createInspector(cell);
            this.commandManager.stopListening();
            this.inspector.updateCell();
            this.commandManager.listen();
            this.inspector.$("[data-attribute]:first").focus()
        }
    }, this);
    this.paper = new joint.dia.Paper({width: 1e3,height: 1e3,gridSize: 10,perpendicularLinks: true,model: this.graph,defaultLink: new joint.dia.Link({attrs: {".marker-source": {d: "M 10 0 L 0 5 L 10 10 z",transform: "scale(0.001)"},".marker-target": {d: "M 10 0 L 0 5 L 10 10 z"},".connection": {stroke: "black"}}})});
    this.paperScroller = new joint.ui.PaperScroller({autoResizePaper: true,padding: 50,paper: this.paper});
    this.paperScroller.$el.appendTo(".paper-container");
    this.paperScroller.center();
    this.graph.on("add", this.initializeLinkTooltips, this);
    $(".paper-scroller").on("mousewheel DOMMouseScroll", _.bind(function(evt) {
        if (_.contains(KeyboardJS.activeKeys(), "alt")) {
            evt.preventDefault();
            var delta = Math.max(-1, Math.min(1, evt.originalEvent.wheelDelta || -evt.originalEvent.detail));
            var offset = this.paperScroller.$el.offset();
            var o = this.paperScroller.toLocalPoint(evt.pageX - offset.left, evt.pageY - offset.top);
            this.paperScroller.zoom(delta / 10, {min: .2,max: 5,ox: o.x,oy: o.y})
        }
    }, this));
    this.snapLines = new joint.ui.Snaplines({paper: this.paper})
},initializeLinkTooltips: function(cell) {
    if (cell instanceof joint.dia.Link) {
        var linkView = this.paper.findViewByModel(cell);
        new joint.ui.Tooltip({className: "tooltip small",target: linkView.$(".tool-options"),content: "Click to open Inspector for this link",left: linkView.$(".tool-options"),direction: "left"})
    }
},initializeStencil: function() {
    this.stencil = new joint.ui.Stencil({graph: this.graph,paper: this.paper,width: 240,groups: Stencil.groups,search: {"*": ["type", "attrs/text/text", "attrs/.label/text"],"org.Member": ["attrs/.rank/text", "attrs/.name/text"]}});
    $(".stencil-container").append(this.stencil.render().el);
    this.stencil.$el.on("contextmenu", function(evt) {
        evt.preventDefault()
    });
    $(".stencil-paper-drag").on("contextmenu", function(evt) {
        evt.preventDefault()
    });
    var layoutOptions = {columnWidth: this.stencil.options.width / 2 - 10,columns: 2,rowHeight: 80,resizeToFit: true,dy: 10,dx: 10};
    _.each(Stencil.groups, function(group, name) {
        this.stencil.load(Stencil.shapes[name], name);
        joint.layout.GridLayout.layout(this.stencil.getGraph(name), layoutOptions);
        this.stencil.getPaper(name).fitToContent(1, 1, 10)
    }, this);
    this.stencil.on("filter", function(graph) {
        joint.layout.GridLayout.layout(graph, layoutOptions)
    });
    $(".stencil-container .btn-expand").on("click", _.bind(this.stencil.openGroups, this.stencil));
    $(".stencil-container .btn-collapse").on("click", _.bind(this.stencil.closeGroups, this.stencil));
    this.initializeStencilTooltips()
},initializeStencilTooltips: function() {
    _.each(this.stencil.graphs, function(graph) {
        graph.get("cells").each(function(cell) {
            new joint.ui.Tooltip({target: '.stencil [model-id="' + cell.id + '"]',content: cell.get("type").split(".").join(" "),left: ".stencil",direction: "left"})
        })
    })
},initializeSelection: function() {
    this.selection = new Backbone.Collection;
    this.selectionView = new joint.ui.SelectionView({paper: this.paper,graph: this.graph,model: this.selection});
    this.paper.on("blank:pointerdown", function(evt, x, y) {
        if (_.contains(KeyboardJS.activeKeys(), "shift")) {
            this.selectionView.startSelecting(evt, x, y)
        } else {
            this.selectionView.cancelSelection();
            this.paperScroller.startPanning(evt, x, y)
        }
    }, this);
    this.paper.on("cell:pointerdown", function(cellView, evt) {
        if ((evt.ctrlKey || evt.metaKey) && !(cellView.model instanceof joint.dia.Link)) {
            this.selection.add(cellView.model);
            this.selectionView.createSelectionBox(cellView)
        }
    }, this);
    this.selectionView.on("selection-box:pointerdown", function(evt) {
        if (evt.ctrlKey || evt.metaKey) {
            var cell = this.selection.get($(evt.target).data("model"));
            this.selection.reset(this.selection.without(cell));
            this.selectionView.destroySelectionBox(this.paper.findViewByModel(cell))
        }
    }, this);
    this.paper.el.oncontextmenu = function(evt) {
        evt.preventDefault()
    };
    KeyboardJS.on("delete, backspace", _.bind(function(evt, keys) {
        if (!$.contains(evt.target, this.paper.el)) {
            return
        }
        this.commandManager.initBatchCommand();
        this.selection.invoke("remove");
        this.commandManager.storeBatchCommand();
        this.selectionView.cancelSelection();
        if (_.contains(keys, "backspace") && !$(evt.target).is("input, textarea")) {
            evt.preventDefault()
        }
    }, this))
},createInspector: function(cellView) {
    var cell = cellView.model || cellView;
    if (!this.inspector || this.inspector.options.cell !== cell) {
        if (this.inspector) {
            this.inspectorClosedGroups[this.inspector.options.cell.id] = _.map(app.inspector.$(".group.closed"), function(g) {
                return $(g).attr("data-name")
            });
            this.inspector.updateCell();
            this.inspector.remove()
        }
        var inspectorDefs = InspectorDefs[cell.get("type")];
        this.inspector = new joint.ui.Inspector({inputs: inspectorDefs ? inspectorDefs.inputs : CommonInspectorInputs,groups: inspectorDefs ? inspectorDefs.groups : CommonInspectorGroups,cell: cell});
        this.initializeInspectorTooltips();
        this.inspector.render();
        $(".inspector-container").html(this.inspector.el);
        if (this.inspectorClosedGroups[cell.id]) {
            _.each(this.inspectorClosedGroups[cell.id], this.inspector.closeGroup, this.inspector)
        } else {
            this.inspector.$(".group:not(:first-child)").addClass("closed")
        }
    }
},initializeInspectorTooltips: function() {
    this.inspector.on("render", function() {
        this.inspector.$("[data-tooltip]").each(function() {
            var $label = $(this);
            new joint.ui.Tooltip({target: $label,content: $label.data("tooltip"),right: ".inspector",direction: "right"})
        })
    }, this)
},initializeHaloAndInspector: function() {
    this.paper.on("cell:pointerup", function(cellView, evt) {
        if (cellView.model instanceof joint.dia.Link || this.selection.contains(cellView.model))
            return;
        var freetransform = new joint.ui.FreeTransform({graph: this.graph,paper: this.paper,cell: cellView.model});
        var halo = new joint.ui.Halo({graph: this.graph,paper: this.paper,cellView: cellView});
        halo.removeHandle("resize");
        halo.changeHandle("clone", {position: "se"});
        freetransform.render();
        halo.render();
        this.initializeHaloTooltips(halo);
        this.createInspector(cellView);
        this.selectionView.cancelSelection();
        this.selection.reset([cellView.model])
    }, this);
    this.paper.on("link:options", function(evt, cellView, x, y) {
        this.createInspector(cellView)
    }, this)
},initializeNavigator: function() {
    var navigator = this.navigator = new joint.ui.Navigator({width: 240,height: 115,paperScroller: this.paperScroller,zoomOptions: {max: 5,min: .2}});
    navigator.$el.appendTo(".navigator-container");
    navigator.render()
},initializeHaloTooltips: function(halo) {
    new joint.ui.Tooltip({className: "tooltip small",target: halo.$(".remove"),content: "Click to remove the object",direction: "right",right: halo.$(".remove"),padding: 15});
    new joint.ui.Tooltip({className: "tooltip small",target: halo.$(".fork"),content: "Click and drag to clone and connect the object in one go",direction: "left",left: halo.$(".fork"),padding: 15});
    new joint.ui.Tooltip({className: "tooltip small",target: halo.$(".clone"),content: "Click and drag to clone the object",direction: "left",left: halo.$(".clone"),padding: 15});
    new joint.ui.Tooltip({className: "tooltip small",target: halo.$(".unlink"),content: "Click to break all connections to other objects",direction: "right",right: halo.$(".unlink"),padding: 15});
    new joint.ui.Tooltip({className: "tooltip small",target: halo.$(".link"),content: "Click and drag to connect the object",direction: "left",left: halo.$(".link"),padding: 15});
    new joint.ui.Tooltip({className: "tooltip small",target: halo.$(".rotate"),content: "Click and drag to rotate the object",direction: "right",right: halo.$(".rotate"),padding: 15})
},initializeClipboard: function() {
    this.clipboard = new joint.ui.Clipboard;
    KeyboardJS.on("ctrl + c", _.bind(function() {
        this.clipboard.copyElements(this.selection, this.graph, {translate: {dx: 20,dy: 20},useLocalStorage: true})
    }, this));
    KeyboardJS.on("ctrl + v", _.bind(function() {
        this.selectionView.cancelSelection();
        this.clipboard.pasteCells(this.graph, {link: {z: -1},useLocalStorage: true});
        this.clipboard.each(function(cell) {
            if (cell.get("type") === "link")
                return;
            this.selection.add(this.graph.getCell(cell.id));
            this.selectionView.createSelectionBox(cell.findView(this.paper))
        }, this)
    }, this));
    KeyboardJS.on("ctrl + x", _.bind(function() {
        var originalCells = this.clipboard.copyElements(this.selection, this.graph, {useLocalStorage: true});
        this.commandManager.initBatchCommand();
        _.invoke(originalCells, "remove");
        this.commandManager.storeBatchCommand();
        this.selectionView.cancelSelection()
    }, this))
},initializeCommandManager: function() {
    this.commandManager = new joint.dia.CommandManager({graph: this.graph});
    KeyboardJS.on("ctrl + z", _.bind(function() {
        this.commandManager.undo();
        this.selectionView.cancelSelection()
    }, this));
    KeyboardJS.on("ctrl + y", _.bind(function() {
        this.commandManager.redo();
        this.selectionView.cancelSelection()
    }, this))
},initializeValidator: function() {
    this.validator = new joint.dia.Validator({commandManager: this.commandManager});
    this.validator.validate("change:position change:size add", _.bind(function(err, command, next) {
        if (command.action === "add" && command.batch)
            return next();
        var cell = command.data.attributes || this.graph.getCell(command.data.id).toJSON();
        var area = g.rect(cell.position.x, cell.position.y, cell.size.width, cell.size.height);
        if (_.find(this.graph.getElements(), function(e) {
                var position = e.get("position");
                var size = e.get("size");
                return e.id !== cell.id && area.intersect(g.rect(position.x, position.y, size.width, size.height))
            }))
            return next("Another cell in the way!")
    }, this));
    this.validator.on("invalid", function(message) {
        $(".statusbar-container").text(message).addClass("error");
        _.delay(function() {
            $(".statusbar-container").text("").removeClass("error")
        }, 1500)
    })
},initializeToolbar: function() {
    this.initializeToolbarTooltips();
    $("#btn-undo").on("click", _.bind(this.commandManager.undo, this.commandManager));
    $("#btn-redo").on("click", _.bind(this.commandManager.redo, this.commandManager));
    $("#btn-clear").on("click", _.bind(this.graph.clear, this.graph));
    $("#btn-svg").on("click", _.bind(this.paper.openAsSVG, this.paper));
    $("#btn-png").on("click", _.bind(this.paper.openAsPNG, this.paper));
    $("#btn-zoom-in").on("click", _.bind(function() {
        this.paperScroller.zoom(.2, {max: 5,grid: .2})
    }, this));
    $("#btn-zoom-out").on("click", _.bind(function() {
        this.paperScroller.zoom(-.2, {min: .2,grid: .2})
    }, this));
    $("#btn-zoom-to-fit").on("click", _.bind(function() {
        this.paperScroller.zoomToFit({padding: 20,scaleGrid: .2,minScale: .2,maxScale: 5})
    }, this));
    $("#btn-fullscreen").on("click", _.bind(this.toggleFullscreen, this));
    $("#btn-print").on("click", _.bind(this.paper.print, this.paper));
    $("#btn-to-front").on("mousedown", _.bind(function(evt) {
        this.selection.invoke("toFront")
    }, this));
    $("#btn-to-back").on("mousedown", _.bind(function(evt) {
        this.selection.invoke("toBack")
    }, this));
    $("#btn-layout").on("click", _.bind(this.layoutDirectedGraph, this));
    $("#input-gridsize").on("change", _.bind(function(evt) {
        var gridSize = parseInt(evt.target.value, 10);
        $("#output-gridsize").text(gridSize);
        this.setGrid(gridSize)
    }, this));
    $("#snapline-switch").change(_.bind(function(evt) {
        if (evt.target.checked) {
            this.snapLines.startListening()
        } else {
            this.snapLines.stopListening()
        }
    }, this));
    var $zoomLevel = $("#zoom-level");
    this.paper.on("scale", function(scale) {
        $zoomLevel.text(Math.round(scale * 100))
    })
},initializeToolbarTooltips: function() {
    $(".toolbar-container [data-tooltip]").each(function() {
        new joint.ui.Tooltip({target: $(this),content: $(this).data("tooltip"),top: ".toolbar-container",direction: "top"})
    })
},toggleFullscreen: function() {
    var el = document.body;
    function prefixedResult(el, prop) {
        var prefixes = ["webkit", "moz", "ms", "o", ""];
        for (var i = 0; i < prefixes.length; i++) {
            var prefix = prefixes[i];
            var propName = prefix ? prefix + prop : prop.substr(0, 1).toLowerCase() + prop.substr(1);
            if (!_.isUndefined(el[propName])) {
                return _.isFunction(el[propName]) ? el[propName]() : el[propName]
            }
        }
    }
    if (prefixedResult(document, "FullScreen") || prefixedResult(document, "IsFullScreen")) {
        prefixedResult(document, "CancelFullScreen")
    } else {
        prefixedResult(el, "RequestFullScreen")
    }
},setGrid: function(gridSize) {
    this.paper.options.gridSize = gridSize;
    var backgroundImage = this.getGridBackgroundImage(gridSize);
    this.paper.$el.css("background-image", 'url("' + backgroundImage + '")')
},getGridBackgroundImage: function(gridSize, color) {
    var canvas = $("<canvas/>", {width: gridSize,height: gridSize});
    canvas[0].width = gridSize;
    canvas[0].height = gridSize;
    var context = canvas[0].getContext("2d");
    context.beginPath();
    context.rect(1, 1, 1, 1);
    context.fillStyle = color || "#AAAAAA";
    context.fill();
    return canvas[0].toDataURL("image/png")
},layoutDirectedGraph: function() {
    this.commandManager.initBatchCommand();
    _.each(this.graph.getLinks(), function(link) {
        link.set("vertices", []);
        if (!link.get("source").id || !link.get("target").id) {
            link.remove()
        }
    });
    var pad = 50;
    joint.layout.DirectedGraph.layout(this.graph, {setLinkVertices: false,rankDir: "LR",rankDir: "TB",setPosition: function(cell, box) {
        cell.position(box.x - box.width / 2 + pad, box.y - box.height / 2 + pad)
    }});
    this.paperScroller.el.scrollLeft = 0;
    this.paperScroller.el.scrollTop = 0;
    this.commandManager.storeBatchCommand()
},initializeChannel: function(url) {
    var room = location.hash && location.hash.substr(1);
    if (!room) {
        room = joint.util.uuid();
        this.navigate("#" + room)
    }
    var channel = this.channel = new joint.com.Channel({graph: this.graph,url: url || "ws://localhost:4141",query: {room: room}});
    console.log("room", room, "channel", channel.id);
    var roomUrl = location.href.replace(location.hash, "") + "#" + room;
    $(".statusbar-container .rt-colab").html('Send this link to a friend to <b>collaborate in real-time</b>: <a href="' + roomUrl + '" target="_blank">' + roomUrl + "</a>")
}});
var base64 = {};
base64.PADCHAR = "=";
base64.ALPHA = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
base64.makeDOMException = function() {
    var e, tmp;
    try {
        return new DOMException(DOMException.INVALID_CHARACTER_ERR)
    } catch (tmp) {
        var ex = new Error("DOM Exception 5");
        ex.code = ex.number = 5;
        ex.name = ex.description = "INVALID_CHARACTER_ERR";
        ex.toString = function() {
            return "Error: " + ex.name + ": " + ex.message
        };
        return ex
    }
};
base64.getbyte64 = function(s, i) {
    var idx = base64.ALPHA.indexOf(s.charAt(i));
    if (idx === -1) {
        throw base64.makeDOMException()
    }
    return idx
};
base64.decode = function(s) {
    s = "" + s;
    var getbyte64 = base64.getbyte64;
    var pads, i, b10;
    var imax = s.length;
    if (imax === 0) {
        return s
    }
    if (imax % 4 !== 0) {
        throw base64.makeDOMException()
    }
    pads = 0;
    if (s.charAt(imax - 1) === base64.PADCHAR) {
        pads = 1;
        if (s.charAt(imax - 2) === base64.PADCHAR) {
            pads = 2
        }
        imax -= 4
    }
    var x = [];
    for (i = 0; i < imax; i += 4) {
        b10 = getbyte64(s, i) << 18 | getbyte64(s, i + 1) << 12 | getbyte64(s, i + 2) << 6 | getbyte64(s, i + 3);
        x.push(String.fromCharCode(b10 >> 16, b10 >> 8 & 255, b10 & 255))
    }
    switch (pads) {
        case 1:
            b10 = getbyte64(s, i) << 18 | getbyte64(s, i + 1) << 12 | getbyte64(s, i + 2) << 6;
            x.push(String.fromCharCode(b10 >> 16, b10 >> 8 & 255));
            break;
        case 2:
            b10 = getbyte64(s, i) << 18 | getbyte64(s, i + 1) << 12;
            x.push(String.fromCharCode(b10 >> 16));
            break
    }
    return x.join("")
};
base64.getbyte = function(s, i) {
    var x = s.charCodeAt(i);
    if (x > 255) {
        throw base64.makeDOMException()
    }
    return x
};
base64.encode = function(s) {
    if (arguments.length !== 1) {
        throw new SyntaxError("Not enough arguments")
    }
    var padchar = base64.PADCHAR;
    var alpha = base64.ALPHA;
    var getbyte = base64.getbyte;
    var i, b10;
    var x = [];
    s = "" + s;
    var imax = s.length - s.length % 3;
    if (s.length === 0) {
        return s
    }
    for (i = 0; i < imax; i += 3) {
        b10 = getbyte(s, i) << 16 | getbyte(s, i + 1) << 8 | getbyte(s, i + 2);
        x.push(alpha.charAt(b10 >> 18));
        x.push(alpha.charAt(b10 >> 12 & 63));
        x.push(alpha.charAt(b10 >> 6 & 63));
        x.push(alpha.charAt(b10 & 63))
    }
    switch (s.length - imax) {
        case 1:
            b10 = getbyte(s, i) << 16;
            x.push(alpha.charAt(b10 >> 18) + alpha.charAt(b10 >> 12 & 63) + padchar + padchar);
            break;
        case 2:
            b10 = getbyte(s, i) << 16 | getbyte(s, i + 1) << 8;
            x.push(alpha.charAt(b10 >> 18) + alpha.charAt(b10 >> 12 & 63) + alpha.charAt(b10 >> 6 & 63) + padchar);
            break
    }
    return x.join("")
};

// Uncomment the following line and comment the line after if you
// want to use channels.
var app = new Rappid({channelUrl: 'ws://jointjs.com:4141'});
Backbone.history.start();

/*
</script>

<!--[if IE 9]>
<script type="text/javascript">
    // SVG Export requires window.btoa/atoa extension to convert binary data (the `b`)
    // to base64 (ascii, the `a`). Unfortunately it is not available in IE9.
    // To get it working under IE9 you may include compatible solution like `stringencoders`
    // (`https://code.google.com/p/stringencoders/source/browse/trunk/javascript/base64.js`)
    // and create a global alias `btoa`.
window.btoa = base64.encode
// `-ms-user-select: none` doesn't work in IE9
document.onselectstart = function() { return false; };
</script>
<![endif]-->

<script type="text/javascript">

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-5029684-2']);
_gaq.push(['_trackPageview']);

(function() {
    var ga = document.createElement('script');
    ga.type = 'text/javascript';
    ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>
*/
